{"version":3,"sources":["../../../server/lib/find-page-file.ts"],"names":["isTrueCasePagePath","pagePath","pagesDir","pageSegments","split","pathSeparator","filter","Boolean","segmentExistsPromises","map","segment","i","segmentParentDir","slice","parentDirEntries","promises","readdir","includes","Promise","all","every","findPageFile","rootDir","normalizedPagePath","pageExtensions","page","allPages","prefix","startsWith","nameMatch","endsWith","replace","foundPagePaths","path","match","RegExp","join","length","chalk","cyan"],"mappings":"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","sourcesContent":["import { join, sep as pathSeparator, normalize } from 'path'\nimport chalk from 'chalk'\nimport { warn } from '../../build/output/log'\nimport { promises } from 'fs'\nimport {\n  denormalizePagePath,\n  normalizePathSep,\n} from '../../next-server/server/normalize-page-path'\n// import { fileExists } from '../../lib/file-exists'\nimport { recursiveFindPages } from '../../lib/recursive-readdir'\nimport { buildPageExtensionRegex } from '../../build/utils'\n\nasync function isTrueCasePagePath(pagePath: string, pagesDir: string) {\n  const pageSegments = normalize(pagePath).split(pathSeparator).filter(Boolean)\n\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = join(pagesDir, ...pageSegments.slice(0, i))\n    const parentDirEntries = await promises.readdir(segmentParentDir)\n    return parentDirEntries.includes(segment)\n  })\n\n  return (await Promise.all(segmentExistsPromises)).every(Boolean)\n}\n\nexport async function findPageFile(\n  rootDir: string,\n  normalizedPagePath: string,\n  pageExtensions: string[]\n): Promise<string | null> {\n  const page = denormalizePagePath(normalizedPagePath)\n  // console.log('[findPageFile]', { rootDir, normalizedPagePath, page })\n\n  const allPages = await recursiveFindPages(\n    rootDir,\n    buildPageExtensionRegex(pageExtensions)\n  )\n  // console.log('allPages', allPages)\n\n  let prefix: string\n  if (normalizedPagePath.startsWith('/api/')) {\n    prefix = ''\n  } else {\n    prefix = '/pages'\n  }\n\n  let nameMatch: string\n  if (page === '/') {\n    nameMatch = normalizedPagePath\n  } else if (page.endsWith('/index')) {\n    nameMatch = `${page}/index`\n  } else {\n    nameMatch = `(${page}|${page}/index)`\n  }\n\n  // Make the regex work for dynamic routes like [...auth].ts\n  nameMatch = nameMatch.replace(/[[\\]\\\\]/g, '\\\\$&')\n\n  const foundPagePaths = allPages.filter((path) =>\n    normalizePathSep(path).match(\n      new RegExp(`${prefix}${nameMatch}\\\\.(?:${pageExtensions.join('|')})$`)\n    )\n  )\n  // console.log(\n  //   new RegExp(`${prefix}${nameMatch}\\\\.(?:${pageExtensions.join('|')})$`)\n  // )\n  // console.log('FOUND', foundPagePaths)\n\n  // for (const extension of pageExtensions) {\n  //   if (!normalizedPagePath.endsWith('/index')) {\n  //     const relativePagePath = `${page}.${extension}`\n  //     const pagePath = join(rootDir, relativePagePath)\n  //\n  //     if (await fileExists(pagePath)) {\n  //       foundPagePaths.push(relativePagePath)\n  //     }\n  //   }\n  //\n  //   const relativePagePathWithIndex = join(page, `index.${extension}`)\n  //   const pagePathWithIndex = join(rootDir, relativePagePathWithIndex)\n  //   if (await fileExists(pagePathWithIndex)) {\n  //     foundPagePaths.push(relativePagePathWithIndex)\n  //   }\n  // }\n\n  if (foundPagePaths.length < 1) {\n    return null\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null\n  }\n\n  if (foundPagePaths.length > 1) {\n    warn(\n      `Duplicate page detected. ${chalk.cyan(\n        join('pages', foundPagePaths[0])\n      )} and ${chalk.cyan(\n        join('pages', foundPagePaths[1])\n      )} both resolve to ${chalk.cyan(normalizedPagePath)}.`\n    )\n  }\n\n  return foundPagePaths[0]\n}\n"]}