
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  updatedAt: Date
  name: string
  email: string
  hashedPassword: string
  userDescription: string
  lien: string
  getNotifications: boolean
  isActive: boolean
  emailIsVerified: boolean
  bio: string
  role: string
  avatar: string
  isPublic: boolean
  userLat: number
  userLon: number
  ip: string[]
}

/**
 * Model Session
 */

export type Session = {
  id: number
  createdAt: Date
  updatedAt: Date
  expiresAt: Date | null
  handle: string
  hashedSessionToken: string | null
  antiCSRFToken: string | null
  publicData: string | null
  privateData: string | null
  name: string | null
  userId: string
  emailIsVerified: boolean | null
}

/**
 * Model BannedIp
 */

export type BannedIp = {
  id: string
  createdAt: Date
  ip: string
}

/**
 * Model MainPage
 */

export type MainPage = {
  id: number
  createdAt: Date
  updatedAt: Date
  usesEditor: boolean
  maincontent: string
}

/**
 * Model Apost
 */

export type Apost = {
  id: string
  createdAt: Date
  updatedAt: Date
  content: string
  userId: string
}

/**
 * Model Areply
 */

export type Areply = {
  id: string
  createdAt: Date
  content: string
  number: number
  userId: string
  apostId: string
}

/**
 * Model Faq
 */

export type Faq = {
  id: string
  createdAt: Date
  updatedAt: Date
  subject: string
  content: string
  orderSubject: number
}

/**
 * Model Token
 */

export type Token = {
  id: number
  createdAt: Date
  updatedAt: Date
  hashedToken: string
  type: string
  expiresAt: Date
  sentTo: string
  userId: string
}

/**
 * Model TokenMailVerification
 */

export type TokenMailVerification = {
  id: number
  createdAt: Date
  updatedAt: Date
  hashedToken: string
  type: string
  expiresAt: Date
  sentTo: string
  hashedPassword: string
  name: string
}

/**
 * Model Image
 */

export type Image = {
  id: string
  createdAt: Date
  userId: string
  asset_id: string
  url: string
}

/**
 * Model Team
 */

export type Team = {
  id: string
  createdAt: Date
  updatedAt: Date
  name: string
  description: string
  corpus: string
  anneeCreation: number
  secteur: string
  typeOrg: string
  taille: number
  teamLatitude: number
  teamLongitude: number
  image: string
  imageCover: string
  TeamMastersID: string[]
  TeamMemberId: string[]
  public: boolean
  findIndex: number
  publishDemand: boolean
}

/**
 * Model Tag
 */

export type Tag = {
  createdAt: Date
  updatedAt: Date
  id: string
  isPublic: boolean
  catSpecific: string
}

/**
 * Model TeamFollower
 */

export type TeamFollower = {
  id: string
  createdAt: Date
  updatedAt: Date
  teamId: string
  followerId: string
}

/**
 * Model Tpost
 */

export type Tpost = {
  id: string
  createdAt: Date
  updatedAt: Date
  content: string
  number: number
  teamId: string
  userId: string
}

/**
 * Model Tevent
 */

export type Tevent = {
  id: string
  createdAt: Date
  updatedAt: Date
  subject: string
  startAt: Date
  endsAt: Date
  content: string
  maxParticipants: number
  teamId: string
  userId: string
  eventLat: number
  eventLon: number
  locationDescription: string | null
  visioPres: boolean
  linkVisio: string | null
  visioCode: string | null
  infoPostscritum: string | null
  isCancel: boolean
  visible: boolean
  postScriptWriterId: string | null
  recallEmailSent: boolean
}

/**
 * Model UserParticipeEvent
 */

export type UserParticipeEvent = {
  id: string
  createdAt: Date
  updatedAt: Date
  teventId: string
  participantId: string
}

/**
 * Model Ereply
 */

export type Ereply = {
  id: string
  createdAt: Date
  content: string
  number: number
  teventId: string
  teamId: string
  userId: string
}

/**
 * Model Treply
 */

export type Treply = {
  id: string
  createdAt: Date
  content: string
  number: number
  tpostId: string
  teamId: string
  userId: string
}

/**
 * Model Message
 */

export type Message = {
  id: string
  sentAt: Date
  content: string
  htmlContent: string | null
  sentFromId: string
  sentToId: string[]
  sentInId: string
}

/**
 * Model SignalAdmin
 */

export type SignalAdmin = {
  id: string
  createdAt: Date
  content: string
  isTreated: boolean
  chatId: string
  subject: string
  userId: string
}

/**
 * Model Chat
 */

export type Chat = {
  id: string
  subject: string
  private: boolean
  IsDeletedByAdmin: boolean
}

/**
 * Model AdminMessage
 */

export type AdminMessage = {
  id: string
  sentAt: Date
  content: string
  htmlContent: string | null
  sentInId: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.bannedIp`: Exposes CRUD operations for the **BannedIp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannedIps
    * const bannedIps = await prisma.bannedIp.findMany()
    * ```
    */
  get bannedIp(): Prisma.BannedIpDelegate<GlobalReject>;

  /**
   * `prisma.mainPage`: Exposes CRUD operations for the **MainPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainPages
    * const mainPages = await prisma.mainPage.findMany()
    * ```
    */
  get mainPage(): Prisma.MainPageDelegate<GlobalReject>;

  /**
   * `prisma.apost`: Exposes CRUD operations for the **Apost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aposts
    * const aposts = await prisma.apost.findMany()
    * ```
    */
  get apost(): Prisma.ApostDelegate<GlobalReject>;

  /**
   * `prisma.areply`: Exposes CRUD operations for the **Areply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areplies
    * const areplies = await prisma.areply.findMany()
    * ```
    */
  get areply(): Prisma.AreplyDelegate<GlobalReject>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **Faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.FaqDelegate<GlobalReject>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<GlobalReject>;

  /**
   * `prisma.tokenMailVerification`: Exposes CRUD operations for the **TokenMailVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenMailVerifications
    * const tokenMailVerifications = await prisma.tokenMailVerification.findMany()
    * ```
    */
  get tokenMailVerification(): Prisma.TokenMailVerificationDelegate<GlobalReject>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<GlobalReject>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.teamFollower`: Exposes CRUD operations for the **TeamFollower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamFollowers
    * const teamFollowers = await prisma.teamFollower.findMany()
    * ```
    */
  get teamFollower(): Prisma.TeamFollowerDelegate<GlobalReject>;

  /**
   * `prisma.tpost`: Exposes CRUD operations for the **Tpost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tposts
    * const tposts = await prisma.tpost.findMany()
    * ```
    */
  get tpost(): Prisma.TpostDelegate<GlobalReject>;

  /**
   * `prisma.tevent`: Exposes CRUD operations for the **Tevent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tevents
    * const tevents = await prisma.tevent.findMany()
    * ```
    */
  get tevent(): Prisma.TeventDelegate<GlobalReject>;

  /**
   * `prisma.userParticipeEvent`: Exposes CRUD operations for the **UserParticipeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserParticipeEvents
    * const userParticipeEvents = await prisma.userParticipeEvent.findMany()
    * ```
    */
  get userParticipeEvent(): Prisma.UserParticipeEventDelegate<GlobalReject>;

  /**
   * `prisma.ereply`: Exposes CRUD operations for the **Ereply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ereplies
    * const ereplies = await prisma.ereply.findMany()
    * ```
    */
  get ereply(): Prisma.EreplyDelegate<GlobalReject>;

  /**
   * `prisma.treply`: Exposes CRUD operations for the **Treply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treplies
    * const treplies = await prisma.treply.findMany()
    * ```
    */
  get treply(): Prisma.TreplyDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.signalAdmin`: Exposes CRUD operations for the **SignalAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignalAdmins
    * const signalAdmins = await prisma.signalAdmin.findMany()
    * ```
    */
  get signalAdmin(): Prisma.SignalAdminDelegate<GlobalReject>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<GlobalReject>;

  /**
   * `prisma.adminMessage`: Exposes CRUD operations for the **AdminMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminMessages
    * const adminMessages = await prisma.adminMessage.findMany()
    * ```
    */
  get adminMessage(): Prisma.AdminMessageDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.29.1
   * Query Engine version: 1be4cd60b89afa04b192acb1ef47758a39810f3a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Session: 'Session',
    BannedIp: 'BannedIp',
    MainPage: 'MainPage',
    Apost: 'Apost',
    Areply: 'Areply',
    Faq: 'Faq',
    Token: 'Token',
    TokenMailVerification: 'TokenMailVerification',
    Image: 'Image',
    Team: 'Team',
    Tag: 'Tag',
    TeamFollower: 'TeamFollower',
    Tpost: 'Tpost',
    Tevent: 'Tevent',
    UserParticipeEvent: 'UserParticipeEvent',
    Ereply: 'Ereply',
    Treply: 'Treply',
    Message: 'Message',
    SignalAdmin: 'SignalAdmin',
    Chat: 'Chat',
    AdminMessage: 'AdminMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userLat: number | null
    userLon: number | null
  }

  export type UserSumAggregateOutputType = {
    userLat: number | null
    userLon: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    hashedPassword: string | null
    userDescription: string | null
    lien: string | null
    getNotifications: boolean | null
    isActive: boolean | null
    emailIsVerified: boolean | null
    bio: string | null
    role: string | null
    avatar: string | null
    isPublic: boolean | null
    userLat: number | null
    userLon: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    hashedPassword: string | null
    userDescription: string | null
    lien: string | null
    getNotifications: boolean | null
    isActive: boolean | null
    emailIsVerified: boolean | null
    bio: string | null
    role: string | null
    avatar: string | null
    isPublic: boolean | null
    userLat: number | null
    userLon: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    email: number
    hashedPassword: number
    userDescription: number
    lien: number
    getNotifications: number
    isActive: number
    emailIsVerified: number
    bio: number
    role: number
    avatar: number
    isPublic: number
    userLat: number
    userLon: number
    ip: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userLat?: true
    userLon?: true
  }

  export type UserSumAggregateInputType = {
    userLat?: true
    userLon?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    hashedPassword?: true
    userDescription?: true
    lien?: true
    getNotifications?: true
    isActive?: true
    emailIsVerified?: true
    bio?: true
    role?: true
    avatar?: true
    isPublic?: true
    userLat?: true
    userLon?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    hashedPassword?: true
    userDescription?: true
    lien?: true
    getNotifications?: true
    isActive?: true
    emailIsVerified?: true
    bio?: true
    role?: true
    avatar?: true
    isPublic?: true
    userLat?: true
    userLon?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    hashedPassword?: true
    userDescription?: true
    lien?: true
    getNotifications?: true
    isActive?: true
    emailIsVerified?: true
    bio?: true
    role?: true
    avatar?: true
    isPublic?: true
    userLat?: true
    userLon?: true
    ip?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    email: string
    hashedPassword: string
    userDescription: string
    lien: string
    getNotifications: boolean
    isActive: boolean
    emailIsVerified: boolean
    bio: string
    role: string
    avatar: string
    isPublic: boolean
    userLat: number
    userLon: number
    ip: string[]
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    hashedPassword?: boolean
    userDescription?: boolean
    lien?: boolean
    getNotifications?: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: boolean
    role?: boolean
    avatar?: boolean
    tokens?: boolean | TokenFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    teams?: boolean | TeamFindManyArgs
    tposts?: boolean | TpostFindManyArgs
    tevents?: boolean | TeventFindManyArgs
    treplies?: boolean | TreplyFindManyArgs
    aposts?: boolean | ApostFindManyArgs
    following?: boolean | TeamFollowerFindManyArgs
    ereplies?: boolean | EreplyFindManyArgs
    sentMessages?: boolean | MessageFindManyArgs
    receivedMessages?: boolean | MessageFindManyArgs
    participatesIn?: boolean | ChatFindManyArgs
    images?: boolean | ImageFindManyArgs
    hasRead?: boolean | AdminMessageFindManyArgs
    isPublic?: boolean
    userLat?: boolean
    userLon?: boolean
    invitedInEvent?: boolean | TeventFindManyArgs
    UserPartInEvents?: boolean | UserParticipeEventFindManyArgs
    ip?: boolean
    Areply?: boolean | AreplyFindManyArgs
    signalsToAdmin?: boolean | SignalAdminFindManyArgs
  }

  export type UserInclude = {
    tokens?: boolean | TokenFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    teams?: boolean | TeamFindManyArgs
    tposts?: boolean | TpostFindManyArgs
    tevents?: boolean | TeventFindManyArgs
    treplies?: boolean | TreplyFindManyArgs
    aposts?: boolean | ApostFindManyArgs
    following?: boolean | TeamFollowerFindManyArgs
    ereplies?: boolean | EreplyFindManyArgs
    sentMessages?: boolean | MessageFindManyArgs
    receivedMessages?: boolean | MessageFindManyArgs
    participatesIn?: boolean | ChatFindManyArgs
    images?: boolean | ImageFindManyArgs
    hasRead?: boolean | AdminMessageFindManyArgs
    invitedInEvent?: boolean | TeventFindManyArgs
    UserPartInEvents?: boolean | UserParticipeEventFindManyArgs
    Areply?: boolean | AreplyFindManyArgs
    signalsToAdmin?: boolean | SignalAdminFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tokens'
        ? Array < TokenGetPayload<S['include'][P]>>  :
        P extends 'sessions'
        ? Array < SessionGetPayload<S['include'][P]>>  :
        P extends 'teams'
        ? Array < TeamGetPayload<S['include'][P]>>  :
        P extends 'tposts'
        ? Array < TpostGetPayload<S['include'][P]>>  :
        P extends 'tevents'
        ? Array < TeventGetPayload<S['include'][P]>>  :
        P extends 'treplies'
        ? Array < TreplyGetPayload<S['include'][P]>>  :
        P extends 'aposts'
        ? Array < ApostGetPayload<S['include'][P]>>  :
        P extends 'following'
        ? Array < TeamFollowerGetPayload<S['include'][P]>>  :
        P extends 'ereplies'
        ? Array < EreplyGetPayload<S['include'][P]>>  :
        P extends 'sentMessages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'receivedMessages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'participatesIn'
        ? Array < ChatGetPayload<S['include'][P]>>  :
        P extends 'images'
        ? Array < ImageGetPayload<S['include'][P]>>  :
        P extends 'hasRead'
        ? Array < AdminMessageGetPayload<S['include'][P]>>  :
        P extends 'invitedInEvent'
        ? Array < TeventGetPayload<S['include'][P]>>  :
        P extends 'UserPartInEvents'
        ? Array < UserParticipeEventGetPayload<S['include'][P]>>  :
        P extends 'Areply'
        ? Array < AreplyGetPayload<S['include'][P]>>  :
        P extends 'signalsToAdmin'
        ? Array < SignalAdminGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'tokens'
        ? Array < TokenGetPayload<S['select'][P]>>  :
        P extends 'sessions'
        ? Array < SessionGetPayload<S['select'][P]>>  :
        P extends 'teams'
        ? Array < TeamGetPayload<S['select'][P]>>  :
        P extends 'tposts'
        ? Array < TpostGetPayload<S['select'][P]>>  :
        P extends 'tevents'
        ? Array < TeventGetPayload<S['select'][P]>>  :
        P extends 'treplies'
        ? Array < TreplyGetPayload<S['select'][P]>>  :
        P extends 'aposts'
        ? Array < ApostGetPayload<S['select'][P]>>  :
        P extends 'following'
        ? Array < TeamFollowerGetPayload<S['select'][P]>>  :
        P extends 'ereplies'
        ? Array < EreplyGetPayload<S['select'][P]>>  :
        P extends 'sentMessages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'receivedMessages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'participatesIn'
        ? Array < ChatGetPayload<S['select'][P]>>  :
        P extends 'images'
        ? Array < ImageGetPayload<S['select'][P]>>  :
        P extends 'hasRead'
        ? Array < AdminMessageGetPayload<S['select'][P]>>  :
        P extends 'invitedInEvent'
        ? Array < TeventGetPayload<S['select'][P]>>  :
        P extends 'UserPartInEvents'
        ? Array < UserParticipeEventGetPayload<S['select'][P]>>  :
        P extends 'Areply'
        ? Array < AreplyGetPayload<S['select'][P]>>  :
        P extends 'signalsToAdmin'
        ? Array < SignalAdminGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tokens<T extends TokenFindManyArgs = {}>(args?: Subset<T, TokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Token>>, PrismaPromise<Array<TokenGetPayload<T>>>>;

    sessions<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>;

    teams<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>;

    tposts<T extends TpostFindManyArgs = {}>(args?: Subset<T, TpostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tpost>>, PrismaPromise<Array<TpostGetPayload<T>>>>;

    tevents<T extends TeventFindManyArgs = {}>(args?: Subset<T, TeventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tevent>>, PrismaPromise<Array<TeventGetPayload<T>>>>;

    treplies<T extends TreplyFindManyArgs = {}>(args?: Subset<T, TreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Treply>>, PrismaPromise<Array<TreplyGetPayload<T>>>>;

    aposts<T extends ApostFindManyArgs = {}>(args?: Subset<T, ApostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Apost>>, PrismaPromise<Array<ApostGetPayload<T>>>>;

    following<T extends TeamFollowerFindManyArgs = {}>(args?: Subset<T, TeamFollowerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamFollower>>, PrismaPromise<Array<TeamFollowerGetPayload<T>>>>;

    ereplies<T extends EreplyFindManyArgs = {}>(args?: Subset<T, EreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ereply>>, PrismaPromise<Array<EreplyGetPayload<T>>>>;

    sentMessages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    receivedMessages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    participatesIn<T extends ChatFindManyArgs = {}>(args?: Subset<T, ChatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Chat>>, PrismaPromise<Array<ChatGetPayload<T>>>>;

    images<T extends ImageFindManyArgs = {}>(args?: Subset<T, ImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Image>>, PrismaPromise<Array<ImageGetPayload<T>>>>;

    hasRead<T extends AdminMessageFindManyArgs = {}>(args?: Subset<T, AdminMessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdminMessage>>, PrismaPromise<Array<AdminMessageGetPayload<T>>>>;

    invitedInEvent<T extends TeventFindManyArgs = {}>(args?: Subset<T, TeventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tevent>>, PrismaPromise<Array<TeventGetPayload<T>>>>;

    UserPartInEvents<T extends UserParticipeEventFindManyArgs = {}>(args?: Subset<T, UserParticipeEventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserParticipeEvent>>, PrismaPromise<Array<UserParticipeEventGetPayload<T>>>>;

    Areply<T extends AreplyFindManyArgs = {}>(args?: Subset<T, AreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Areply>>, PrismaPromise<Array<AreplyGetPayload<T>>>>;

    signalsToAdmin<T extends SignalAdminFindManyArgs = {}>(args?: Subset<T, SignalAdminFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SignalAdmin>>, PrismaPromise<Array<SignalAdminGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
    max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    handle: string | null
    hashedSessionToken: string | null
    antiCSRFToken: string | null
    publicData: string | null
    privateData: string | null
    name: string | null
    userId: string | null
    emailIsVerified: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    handle: string | null
    hashedSessionToken: string | null
    antiCSRFToken: string | null
    publicData: string | null
    privateData: string | null
    name: string | null
    userId: string | null
    emailIsVerified: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    handle: number
    hashedSessionToken: number
    antiCSRFToken: number
    publicData: number
    privateData: number
    name: number
    userId: number
    emailIsVerified: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    handle?: true
    hashedSessionToken?: true
    antiCSRFToken?: true
    publicData?: true
    privateData?: true
    name?: true
    userId?: true
    emailIsVerified?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    handle?: true
    hashedSessionToken?: true
    antiCSRFToken?: true
    publicData?: true
    privateData?: true
    name?: true
    userId?: true
    emailIsVerified?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    handle?: true
    hashedSessionToken?: true
    antiCSRFToken?: true
    publicData?: true
    privateData?: true
    name?: true
    userId?: true
    emailIsVerified?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }


    
    
  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    handle: string
    hashedSessionToken: string | null
    antiCSRFToken: string | null
    publicData: string | null
    privateData: string | null
    name: string | null
    userId: string
    emailIsVerified: boolean | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Promise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SessionGroupByOutputType[P]> 
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      > 
    >


  export type SessionSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    handle?: boolean
    hashedSessionToken?: boolean
    antiCSRFToken?: boolean
    publicData?: boolean
    privateData?: boolean
    name?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    emailIsVerified?: boolean
  }

  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Session ?Session [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model BannedIp
   */


  export type AggregateBannedIp = {
    _count: BannedIpCountAggregateOutputType | null
    count: BannedIpCountAggregateOutputType | null
    _min: BannedIpMinAggregateOutputType | null
    min: BannedIpMinAggregateOutputType | null
    _max: BannedIpMaxAggregateOutputType | null
    max: BannedIpMaxAggregateOutputType | null
  }

  export type BannedIpMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    ip: string | null
  }

  export type BannedIpMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    ip: string | null
  }

  export type BannedIpCountAggregateOutputType = {
    id: number
    createdAt: number
    ip: number
    _all: number
  }


  export type BannedIpMinAggregateInputType = {
    id?: true
    createdAt?: true
    ip?: true
  }

  export type BannedIpMaxAggregateInputType = {
    id?: true
    createdAt?: true
    ip?: true
  }

  export type BannedIpCountAggregateInputType = {
    id?: true
    createdAt?: true
    ip?: true
    _all?: true
  }

  export type BannedIpAggregateArgs = {
    /**
     * Filter which BannedIp to aggregate.
     * 
    **/
    where?: BannedIpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedIps to fetch.
     * 
    **/
    orderBy?: Enumerable<BannedIpOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BannedIpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedIps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedIps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannedIps
    **/
    _count?: true | BannedIpCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | BannedIpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannedIpMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: BannedIpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannedIpMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: BannedIpMaxAggregateInputType
  }

  export type GetBannedIpAggregateType<T extends BannedIpAggregateArgs> = {
        [P in keyof T & keyof AggregateBannedIp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannedIp[P]>
      : GetScalarType<T[P], AggregateBannedIp[P]>
  }


    
    
  export type BannedIpGroupByArgs = {
    where?: BannedIpWhereInput
    orderBy?: Enumerable<BannedIpOrderByInput>
    by: Array<BannedIpScalarFieldEnum>
    having?: BannedIpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannedIpCountAggregateInputType | true
    _min?: BannedIpMinAggregateInputType
    _max?: BannedIpMaxAggregateInputType
  }


  export type BannedIpGroupByOutputType = {
    id: string
    createdAt: Date
    ip: string
    _count: BannedIpCountAggregateOutputType | null
    _min: BannedIpMinAggregateOutputType | null
    _max: BannedIpMaxAggregateOutputType | null
  }

  type GetBannedIpGroupByPayload<T extends BannedIpGroupByArgs> = Promise<
    Array<
      PickArray<BannedIpGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof BannedIpGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], BannedIpGroupByOutputType[P]> 
            : GetScalarType<T[P], BannedIpGroupByOutputType[P]>
        }
      > 
    >


  export type BannedIpSelect = {
    id?: boolean
    createdAt?: boolean
    ip?: boolean
  }

  export type BannedIpGetPayload<
    S extends boolean | null | undefined | BannedIpArgs,
    U = keyof S
      > = S extends true
        ? BannedIp
    : S extends undefined
    ? never
    : S extends BannedIpArgs | BannedIpFindManyArgs
    ?'include' extends U
    ? BannedIp 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BannedIp ?BannedIp [P]
  : 
     never
  } 
    : BannedIp
  : BannedIp


  type BannedIpCountArgs = Merge<
    Omit<BannedIpFindManyArgs, 'select' | 'include'> & {
      select?: BannedIpCountAggregateInputType | true
    }
  >

  export interface BannedIpDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BannedIp that matches the filter.
     * @param {BannedIpFindUniqueArgs} args - Arguments to find a BannedIp
     * @example
     * // Get one BannedIp
     * const bannedIp = await prisma.bannedIp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannedIpFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BannedIpFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BannedIp'> extends True ? CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>> : CheckSelect<T, Prisma__BannedIpClient<BannedIp | null >, Prisma__BannedIpClient<BannedIpGetPayload<T> | null >>

    /**
     * Find the first BannedIp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpFindFirstArgs} args - Arguments to find a BannedIp
     * @example
     * // Get one BannedIp
     * const bannedIp = await prisma.bannedIp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannedIpFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BannedIpFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BannedIp'> extends True ? CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>> : CheckSelect<T, Prisma__BannedIpClient<BannedIp | null >, Prisma__BannedIpClient<BannedIpGetPayload<T> | null >>

    /**
     * Find zero or more BannedIps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannedIps
     * const bannedIps = await prisma.bannedIp.findMany()
     * 
     * // Get first 10 BannedIps
     * const bannedIps = await prisma.bannedIp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannedIpWithIdOnly = await prisma.bannedIp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannedIpFindManyArgs>(
      args?: SelectSubset<T, BannedIpFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BannedIp>>, PrismaPromise<Array<BannedIpGetPayload<T>>>>

    /**
     * Create a BannedIp.
     * @param {BannedIpCreateArgs} args - Arguments to create a BannedIp.
     * @example
     * // Create one BannedIp
     * const BannedIp = await prisma.bannedIp.create({
     *   data: {
     *     // ... data to create a BannedIp
     *   }
     * })
     * 
    **/
    create<T extends BannedIpCreateArgs>(
      args: SelectSubset<T, BannedIpCreateArgs>
    ): CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>>

    /**
     * Create many BannedIps.
     *     @param {BannedIpCreateManyArgs} args - Arguments to create many BannedIps.
     *     @example
     *     // Create many BannedIps
     *     const bannedIp = await prisma.bannedIp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannedIpCreateManyArgs>(
      args?: SelectSubset<T, BannedIpCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BannedIp.
     * @param {BannedIpDeleteArgs} args - Arguments to delete one BannedIp.
     * @example
     * // Delete one BannedIp
     * const BannedIp = await prisma.bannedIp.delete({
     *   where: {
     *     // ... filter to delete one BannedIp
     *   }
     * })
     * 
    **/
    delete<T extends BannedIpDeleteArgs>(
      args: SelectSubset<T, BannedIpDeleteArgs>
    ): CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>>

    /**
     * Update one BannedIp.
     * @param {BannedIpUpdateArgs} args - Arguments to update one BannedIp.
     * @example
     * // Update one BannedIp
     * const bannedIp = await prisma.bannedIp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannedIpUpdateArgs>(
      args: SelectSubset<T, BannedIpUpdateArgs>
    ): CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>>

    /**
     * Delete zero or more BannedIps.
     * @param {BannedIpDeleteManyArgs} args - Arguments to filter BannedIps to delete.
     * @example
     * // Delete a few BannedIps
     * const { count } = await prisma.bannedIp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannedIpDeleteManyArgs>(
      args?: SelectSubset<T, BannedIpDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannedIps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannedIps
     * const bannedIp = await prisma.bannedIp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannedIpUpdateManyArgs>(
      args: SelectSubset<T, BannedIpUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BannedIp.
     * @param {BannedIpUpsertArgs} args - Arguments to update or create a BannedIp.
     * @example
     * // Update or create a BannedIp
     * const bannedIp = await prisma.bannedIp.upsert({
     *   create: {
     *     // ... data to create a BannedIp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannedIp we want to update
     *   }
     * })
    **/
    upsert<T extends BannedIpUpsertArgs>(
      args: SelectSubset<T, BannedIpUpsertArgs>
    ): CheckSelect<T, Prisma__BannedIpClient<BannedIp>, Prisma__BannedIpClient<BannedIpGetPayload<T>>>

    /**
     * Count the number of BannedIps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpCountArgs} args - Arguments to filter BannedIps to count.
     * @example
     * // Count the number of BannedIps
     * const count = await prisma.bannedIp.count({
     *   where: {
     *     // ... the filter for the BannedIps we want to count
     *   }
     * })
    **/
    count<T extends BannedIpCountArgs>(
      args?: Subset<T, BannedIpCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannedIpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannedIp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannedIpAggregateArgs>(args: Subset<T, BannedIpAggregateArgs>): PrismaPromise<GetBannedIpAggregateType<T>>

    /**
     * Group by BannedIp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannedIpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannedIpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannedIpGroupByArgs['orderBy'] }
        : { orderBy?: BannedIpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannedIpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannedIpGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannedIp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BannedIpClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BannedIp findUnique
   */
  export type BannedIpFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * Throw an Error if a BannedIp can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BannedIp to fetch.
     * 
    **/
    where: BannedIpWhereUniqueInput
  }


  /**
   * BannedIp findFirst
   */
  export type BannedIpFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * Throw an Error if a BannedIp can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BannedIp to fetch.
     * 
    **/
    where?: BannedIpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedIps to fetch.
     * 
    **/
    orderBy?: Enumerable<BannedIpOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannedIps.
     * 
    **/
    cursor?: BannedIpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedIps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedIps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannedIps.
     * 
    **/
    distinct?: Enumerable<BannedIpScalarFieldEnum>
  }


  /**
   * BannedIp findMany
   */
  export type BannedIpFindManyArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * Filter, which BannedIps to fetch.
     * 
    **/
    where?: BannedIpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannedIps to fetch.
     * 
    **/
    orderBy?: Enumerable<BannedIpOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannedIps.
     * 
    **/
    cursor?: BannedIpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannedIps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannedIps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BannedIpScalarFieldEnum>
  }


  /**
   * BannedIp create
   */
  export type BannedIpCreateArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * The data needed to create a BannedIp.
     * 
    **/
    data: XOR<BannedIpCreateInput, BannedIpUncheckedCreateInput>
  }


  /**
   * BannedIp createMany
   */
  export type BannedIpCreateManyArgs = {
    data: Enumerable<BannedIpCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BannedIp update
   */
  export type BannedIpUpdateArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * The data needed to update a BannedIp.
     * 
    **/
    data: XOR<BannedIpUpdateInput, BannedIpUncheckedUpdateInput>
    /**
     * Choose, which BannedIp to update.
     * 
    **/
    where: BannedIpWhereUniqueInput
  }


  /**
   * BannedIp updateMany
   */
  export type BannedIpUpdateManyArgs = {
    data: XOR<BannedIpUpdateManyMutationInput, BannedIpUncheckedUpdateManyInput>
    where?: BannedIpWhereInput
  }


  /**
   * BannedIp upsert
   */
  export type BannedIpUpsertArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * The filter to search for the BannedIp to update in case it exists.
     * 
    **/
    where: BannedIpWhereUniqueInput
    /**
     * In case the BannedIp found by the `where` argument doesn't exist, create a new BannedIp with this data.
     * 
    **/
    create: XOR<BannedIpCreateInput, BannedIpUncheckedCreateInput>
    /**
     * In case the BannedIp was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BannedIpUpdateInput, BannedIpUncheckedUpdateInput>
  }


  /**
   * BannedIp delete
   */
  export type BannedIpDeleteArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
    /**
     * Filter which BannedIp to delete.
     * 
    **/
    where: BannedIpWhereUniqueInput
  }


  /**
   * BannedIp deleteMany
   */
  export type BannedIpDeleteManyArgs = {
    where?: BannedIpWhereInput
  }


  /**
   * BannedIp without action
   */
  export type BannedIpArgs = {
    /**
     * Select specific fields to fetch from the BannedIp
     * 
    **/
    select?: BannedIpSelect | null
  }



  /**
   * Model MainPage
   */


  export type AggregateMainPage = {
    _count: MainPageCountAggregateOutputType | null
    count: MainPageCountAggregateOutputType | null
    _avg: MainPageAvgAggregateOutputType | null
    avg: MainPageAvgAggregateOutputType | null
    _sum: MainPageSumAggregateOutputType | null
    sum: MainPageSumAggregateOutputType | null
    _min: MainPageMinAggregateOutputType | null
    min: MainPageMinAggregateOutputType | null
    _max: MainPageMaxAggregateOutputType | null
    max: MainPageMaxAggregateOutputType | null
  }

  export type MainPageAvgAggregateOutputType = {
    id: number | null
  }

  export type MainPageSumAggregateOutputType = {
    id: number | null
  }

  export type MainPageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usesEditor: boolean | null
    maincontent: string | null
  }

  export type MainPageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usesEditor: boolean | null
    maincontent: string | null
  }

  export type MainPageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    usesEditor: number
    maincontent: number
    _all: number
  }


  export type MainPageAvgAggregateInputType = {
    id?: true
  }

  export type MainPageSumAggregateInputType = {
    id?: true
  }

  export type MainPageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    usesEditor?: true
    maincontent?: true
  }

  export type MainPageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    usesEditor?: true
    maincontent?: true
  }

  export type MainPageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    usesEditor?: true
    maincontent?: true
    _all?: true
  }

  export type MainPageAggregateArgs = {
    /**
     * Filter which MainPage to aggregate.
     * 
    **/
    where?: MainPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainPages to fetch.
     * 
    **/
    orderBy?: Enumerable<MainPageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MainPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainPages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainPages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainPages
    **/
    _count?: true | MainPageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MainPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainPageAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MainPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainPageSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MainPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainPageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MainPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainPageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MainPageMaxAggregateInputType
  }

  export type GetMainPageAggregateType<T extends MainPageAggregateArgs> = {
        [P in keyof T & keyof AggregateMainPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainPage[P]>
      : GetScalarType<T[P], AggregateMainPage[P]>
  }


    
    
  export type MainPageGroupByArgs = {
    where?: MainPageWhereInput
    orderBy?: Enumerable<MainPageOrderByInput>
    by: Array<MainPageScalarFieldEnum>
    having?: MainPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainPageCountAggregateInputType | true
    _avg?: MainPageAvgAggregateInputType
    _sum?: MainPageSumAggregateInputType
    _min?: MainPageMinAggregateInputType
    _max?: MainPageMaxAggregateInputType
  }


  export type MainPageGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    usesEditor: boolean
    maincontent: string
    _count: MainPageCountAggregateOutputType | null
    _avg: MainPageAvgAggregateOutputType | null
    _sum: MainPageSumAggregateOutputType | null
    _min: MainPageMinAggregateOutputType | null
    _max: MainPageMaxAggregateOutputType | null
  }

  type GetMainPageGroupByPayload<T extends MainPageGroupByArgs> = Promise<
    Array<
      PickArray<MainPageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MainPageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MainPageGroupByOutputType[P]> 
            : GetScalarType<T[P], MainPageGroupByOutputType[P]>
        }
      > 
    >


  export type MainPageSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usesEditor?: boolean
    maincontent?: boolean
  }

  export type MainPageGetPayload<
    S extends boolean | null | undefined | MainPageArgs,
    U = keyof S
      > = S extends true
        ? MainPage
    : S extends undefined
    ? never
    : S extends MainPageArgs | MainPageFindManyArgs
    ?'include' extends U
    ? MainPage 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MainPage ?MainPage [P]
  : 
     never
  } 
    : MainPage
  : MainPage


  type MainPageCountArgs = Merge<
    Omit<MainPageFindManyArgs, 'select' | 'include'> & {
      select?: MainPageCountAggregateInputType | true
    }
  >

  export interface MainPageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MainPage that matches the filter.
     * @param {MainPageFindUniqueArgs} args - Arguments to find a MainPage
     * @example
     * // Get one MainPage
     * const mainPage = await prisma.mainPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MainPageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MainPageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MainPage'> extends True ? CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>> : CheckSelect<T, Prisma__MainPageClient<MainPage | null >, Prisma__MainPageClient<MainPageGetPayload<T> | null >>

    /**
     * Find the first MainPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageFindFirstArgs} args - Arguments to find a MainPage
     * @example
     * // Get one MainPage
     * const mainPage = await prisma.mainPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MainPageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MainPageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MainPage'> extends True ? CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>> : CheckSelect<T, Prisma__MainPageClient<MainPage | null >, Prisma__MainPageClient<MainPageGetPayload<T> | null >>

    /**
     * Find zero or more MainPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainPages
     * const mainPages = await prisma.mainPage.findMany()
     * 
     * // Get first 10 MainPages
     * const mainPages = await prisma.mainPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainPageWithIdOnly = await prisma.mainPage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MainPageFindManyArgs>(
      args?: SelectSubset<T, MainPageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MainPage>>, PrismaPromise<Array<MainPageGetPayload<T>>>>

    /**
     * Create a MainPage.
     * @param {MainPageCreateArgs} args - Arguments to create a MainPage.
     * @example
     * // Create one MainPage
     * const MainPage = await prisma.mainPage.create({
     *   data: {
     *     // ... data to create a MainPage
     *   }
     * })
     * 
    **/
    create<T extends MainPageCreateArgs>(
      args: SelectSubset<T, MainPageCreateArgs>
    ): CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>>

    /**
     * Create many MainPages.
     *     @param {MainPageCreateManyArgs} args - Arguments to create many MainPages.
     *     @example
     *     // Create many MainPages
     *     const mainPage = await prisma.mainPage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MainPageCreateManyArgs>(
      args?: SelectSubset<T, MainPageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MainPage.
     * @param {MainPageDeleteArgs} args - Arguments to delete one MainPage.
     * @example
     * // Delete one MainPage
     * const MainPage = await prisma.mainPage.delete({
     *   where: {
     *     // ... filter to delete one MainPage
     *   }
     * })
     * 
    **/
    delete<T extends MainPageDeleteArgs>(
      args: SelectSubset<T, MainPageDeleteArgs>
    ): CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>>

    /**
     * Update one MainPage.
     * @param {MainPageUpdateArgs} args - Arguments to update one MainPage.
     * @example
     * // Update one MainPage
     * const mainPage = await prisma.mainPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MainPageUpdateArgs>(
      args: SelectSubset<T, MainPageUpdateArgs>
    ): CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>>

    /**
     * Delete zero or more MainPages.
     * @param {MainPageDeleteManyArgs} args - Arguments to filter MainPages to delete.
     * @example
     * // Delete a few MainPages
     * const { count } = await prisma.mainPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MainPageDeleteManyArgs>(
      args?: SelectSubset<T, MainPageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainPages
     * const mainPage = await prisma.mainPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MainPageUpdateManyArgs>(
      args: SelectSubset<T, MainPageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MainPage.
     * @param {MainPageUpsertArgs} args - Arguments to update or create a MainPage.
     * @example
     * // Update or create a MainPage
     * const mainPage = await prisma.mainPage.upsert({
     *   create: {
     *     // ... data to create a MainPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainPage we want to update
     *   }
     * })
    **/
    upsert<T extends MainPageUpsertArgs>(
      args: SelectSubset<T, MainPageUpsertArgs>
    ): CheckSelect<T, Prisma__MainPageClient<MainPage>, Prisma__MainPageClient<MainPageGetPayload<T>>>

    /**
     * Count the number of MainPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageCountArgs} args - Arguments to filter MainPages to count.
     * @example
     * // Count the number of MainPages
     * const count = await prisma.mainPage.count({
     *   where: {
     *     // ... the filter for the MainPages we want to count
     *   }
     * })
    **/
    count<T extends MainPageCountArgs>(
      args?: Subset<T, MainPageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainPageAggregateArgs>(args: Subset<T, MainPageAggregateArgs>): PrismaPromise<GetMainPageAggregateType<T>>

    /**
     * Group by MainPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainPageGroupByArgs['orderBy'] }
        : { orderBy?: MainPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainPageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MainPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MainPageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MainPage findUnique
   */
  export type MainPageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * Throw an Error if a MainPage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MainPage to fetch.
     * 
    **/
    where: MainPageWhereUniqueInput
  }


  /**
   * MainPage findFirst
   */
  export type MainPageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * Throw an Error if a MainPage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MainPage to fetch.
     * 
    **/
    where?: MainPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainPages to fetch.
     * 
    **/
    orderBy?: Enumerable<MainPageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainPages.
     * 
    **/
    cursor?: MainPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainPages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainPages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainPages.
     * 
    **/
    distinct?: Enumerable<MainPageScalarFieldEnum>
  }


  /**
   * MainPage findMany
   */
  export type MainPageFindManyArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * Filter, which MainPages to fetch.
     * 
    **/
    where?: MainPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainPages to fetch.
     * 
    **/
    orderBy?: Enumerable<MainPageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainPages.
     * 
    **/
    cursor?: MainPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainPages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainPages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MainPageScalarFieldEnum>
  }


  /**
   * MainPage create
   */
  export type MainPageCreateArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * The data needed to create a MainPage.
     * 
    **/
    data: XOR<MainPageCreateInput, MainPageUncheckedCreateInput>
  }


  /**
   * MainPage createMany
   */
  export type MainPageCreateManyArgs = {
    data: Enumerable<MainPageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MainPage update
   */
  export type MainPageUpdateArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * The data needed to update a MainPage.
     * 
    **/
    data: XOR<MainPageUpdateInput, MainPageUncheckedUpdateInput>
    /**
     * Choose, which MainPage to update.
     * 
    **/
    where: MainPageWhereUniqueInput
  }


  /**
   * MainPage updateMany
   */
  export type MainPageUpdateManyArgs = {
    data: XOR<MainPageUpdateManyMutationInput, MainPageUncheckedUpdateManyInput>
    where?: MainPageWhereInput
  }


  /**
   * MainPage upsert
   */
  export type MainPageUpsertArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * The filter to search for the MainPage to update in case it exists.
     * 
    **/
    where: MainPageWhereUniqueInput
    /**
     * In case the MainPage found by the `where` argument doesn't exist, create a new MainPage with this data.
     * 
    **/
    create: XOR<MainPageCreateInput, MainPageUncheckedCreateInput>
    /**
     * In case the MainPage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MainPageUpdateInput, MainPageUncheckedUpdateInput>
  }


  /**
   * MainPage delete
   */
  export type MainPageDeleteArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
    /**
     * Filter which MainPage to delete.
     * 
    **/
    where: MainPageWhereUniqueInput
  }


  /**
   * MainPage deleteMany
   */
  export type MainPageDeleteManyArgs = {
    where?: MainPageWhereInput
  }


  /**
   * MainPage without action
   */
  export type MainPageArgs = {
    /**
     * Select specific fields to fetch from the MainPage
     * 
    **/
    select?: MainPageSelect | null
  }



  /**
   * Model Apost
   */


  export type AggregateApost = {
    _count: ApostCountAggregateOutputType | null
    count: ApostCountAggregateOutputType | null
    _min: ApostMinAggregateOutputType | null
    min: ApostMinAggregateOutputType | null
    _max: ApostMaxAggregateOutputType | null
    max: ApostMaxAggregateOutputType | null
  }

  export type ApostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    userId: string | null
  }

  export type ApostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    userId: string | null
  }

  export type ApostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    userId: number
    _all: number
  }


  export type ApostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    userId?: true
  }

  export type ApostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    userId?: true
  }

  export type ApostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    userId?: true
    _all?: true
  }

  export type ApostAggregateArgs = {
    /**
     * Filter which Apost to aggregate.
     * 
    **/
    where?: ApostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aposts to fetch.
     * 
    **/
    orderBy?: Enumerable<ApostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ApostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aposts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Aposts
    **/
    _count?: true | ApostCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ApostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApostMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ApostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApostMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ApostMaxAggregateInputType
  }

  export type GetApostAggregateType<T extends ApostAggregateArgs> = {
        [P in keyof T & keyof AggregateApost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApost[P]>
      : GetScalarType<T[P], AggregateApost[P]>
  }


    
    
  export type ApostGroupByArgs = {
    where?: ApostWhereInput
    orderBy?: Enumerable<ApostOrderByInput>
    by: Array<ApostScalarFieldEnum>
    having?: ApostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApostCountAggregateInputType | true
    _min?: ApostMinAggregateInputType
    _max?: ApostMaxAggregateInputType
  }


  export type ApostGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    content: string
    userId: string
    _count: ApostCountAggregateOutputType | null
    _min: ApostMinAggregateOutputType | null
    _max: ApostMaxAggregateOutputType | null
  }

  type GetApostGroupByPayload<T extends ApostGroupByArgs> = Promise<
    Array<
      PickArray<ApostGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ApostGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ApostGroupByOutputType[P]> 
            : GetScalarType<T[P], ApostGroupByOutputType[P]>
        }
      > 
    >


  export type ApostSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    areplys?: boolean | AreplyFindManyArgs
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type ApostInclude = {
    areplys?: boolean | AreplyFindManyArgs
    user?: boolean | UserArgs
  }

  export type ApostGetPayload<
    S extends boolean | null | undefined | ApostArgs,
    U = keyof S
      > = S extends true
        ? Apost
    : S extends undefined
    ? never
    : S extends ApostArgs | ApostFindManyArgs
    ?'include' extends U
    ? Apost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'areplys'
        ? Array < AreplyGetPayload<S['include'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Apost ?Apost [P]
  : 
          P extends 'areplys'
        ? Array < AreplyGetPayload<S['select'][P]>>  :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Apost
  : Apost


  type ApostCountArgs = Merge<
    Omit<ApostFindManyArgs, 'select' | 'include'> & {
      select?: ApostCountAggregateInputType | true
    }
  >

  export interface ApostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Apost that matches the filter.
     * @param {ApostFindUniqueArgs} args - Arguments to find a Apost
     * @example
     * // Get one Apost
     * const apost = await prisma.apost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ApostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Apost'> extends True ? CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>> : CheckSelect<T, Prisma__ApostClient<Apost | null >, Prisma__ApostClient<ApostGetPayload<T> | null >>

    /**
     * Find the first Apost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostFindFirstArgs} args - Arguments to find a Apost
     * @example
     * // Get one Apost
     * const apost = await prisma.apost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ApostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Apost'> extends True ? CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>> : CheckSelect<T, Prisma__ApostClient<Apost | null >, Prisma__ApostClient<ApostGetPayload<T> | null >>

    /**
     * Find zero or more Aposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aposts
     * const aposts = await prisma.apost.findMany()
     * 
     * // Get first 10 Aposts
     * const aposts = await prisma.apost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apostWithIdOnly = await prisma.apost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApostFindManyArgs>(
      args?: SelectSubset<T, ApostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Apost>>, PrismaPromise<Array<ApostGetPayload<T>>>>

    /**
     * Create a Apost.
     * @param {ApostCreateArgs} args - Arguments to create a Apost.
     * @example
     * // Create one Apost
     * const Apost = await prisma.apost.create({
     *   data: {
     *     // ... data to create a Apost
     *   }
     * })
     * 
    **/
    create<T extends ApostCreateArgs>(
      args: SelectSubset<T, ApostCreateArgs>
    ): CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>>

    /**
     * Create many Aposts.
     *     @param {ApostCreateManyArgs} args - Arguments to create many Aposts.
     *     @example
     *     // Create many Aposts
     *     const apost = await prisma.apost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApostCreateManyArgs>(
      args?: SelectSubset<T, ApostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Apost.
     * @param {ApostDeleteArgs} args - Arguments to delete one Apost.
     * @example
     * // Delete one Apost
     * const Apost = await prisma.apost.delete({
     *   where: {
     *     // ... filter to delete one Apost
     *   }
     * })
     * 
    **/
    delete<T extends ApostDeleteArgs>(
      args: SelectSubset<T, ApostDeleteArgs>
    ): CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>>

    /**
     * Update one Apost.
     * @param {ApostUpdateArgs} args - Arguments to update one Apost.
     * @example
     * // Update one Apost
     * const apost = await prisma.apost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApostUpdateArgs>(
      args: SelectSubset<T, ApostUpdateArgs>
    ): CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>>

    /**
     * Delete zero or more Aposts.
     * @param {ApostDeleteManyArgs} args - Arguments to filter Aposts to delete.
     * @example
     * // Delete a few Aposts
     * const { count } = await prisma.apost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApostDeleteManyArgs>(
      args?: SelectSubset<T, ApostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aposts
     * const apost = await prisma.apost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApostUpdateManyArgs>(
      args: SelectSubset<T, ApostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Apost.
     * @param {ApostUpsertArgs} args - Arguments to update or create a Apost.
     * @example
     * // Update or create a Apost
     * const apost = await prisma.apost.upsert({
     *   create: {
     *     // ... data to create a Apost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apost we want to update
     *   }
     * })
    **/
    upsert<T extends ApostUpsertArgs>(
      args: SelectSubset<T, ApostUpsertArgs>
    ): CheckSelect<T, Prisma__ApostClient<Apost>, Prisma__ApostClient<ApostGetPayload<T>>>

    /**
     * Count the number of Aposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostCountArgs} args - Arguments to filter Aposts to count.
     * @example
     * // Count the number of Aposts
     * const count = await prisma.apost.count({
     *   where: {
     *     // ... the filter for the Aposts we want to count
     *   }
     * })
    **/
    count<T extends ApostCountArgs>(
      args?: Subset<T, ApostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApostAggregateArgs>(args: Subset<T, ApostAggregateArgs>): PrismaPromise<GetApostAggregateType<T>>

    /**
     * Group by Apost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApostGroupByArgs['orderBy'] }
        : { orderBy?: ApostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Apost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ApostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    areplys<T extends AreplyFindManyArgs = {}>(args?: Subset<T, AreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Areply>>, PrismaPromise<Array<AreplyGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Apost findUnique
   */
  export type ApostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * Throw an Error if a Apost can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Apost to fetch.
     * 
    **/
    where: ApostWhereUniqueInput
  }


  /**
   * Apost findFirst
   */
  export type ApostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * Throw an Error if a Apost can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Apost to fetch.
     * 
    **/
    where?: ApostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aposts to fetch.
     * 
    **/
    orderBy?: Enumerable<ApostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Aposts.
     * 
    **/
    cursor?: ApostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aposts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Aposts.
     * 
    **/
    distinct?: Enumerable<ApostScalarFieldEnum>
  }


  /**
   * Apost findMany
   */
  export type ApostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * Filter, which Aposts to fetch.
     * 
    **/
    where?: ApostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Aposts to fetch.
     * 
    **/
    orderBy?: Enumerable<ApostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Aposts.
     * 
    **/
    cursor?: ApostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Aposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Aposts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ApostScalarFieldEnum>
  }


  /**
   * Apost create
   */
  export type ApostCreateArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * The data needed to create a Apost.
     * 
    **/
    data: XOR<ApostCreateInput, ApostUncheckedCreateInput>
  }


  /**
   * Apost createMany
   */
  export type ApostCreateManyArgs = {
    data: Enumerable<ApostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Apost update
   */
  export type ApostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * The data needed to update a Apost.
     * 
    **/
    data: XOR<ApostUpdateInput, ApostUncheckedUpdateInput>
    /**
     * Choose, which Apost to update.
     * 
    **/
    where: ApostWhereUniqueInput
  }


  /**
   * Apost updateMany
   */
  export type ApostUpdateManyArgs = {
    data: XOR<ApostUpdateManyMutationInput, ApostUncheckedUpdateManyInput>
    where?: ApostWhereInput
  }


  /**
   * Apost upsert
   */
  export type ApostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * The filter to search for the Apost to update in case it exists.
     * 
    **/
    where: ApostWhereUniqueInput
    /**
     * In case the Apost found by the `where` argument doesn't exist, create a new Apost with this data.
     * 
    **/
    create: XOR<ApostCreateInput, ApostUncheckedCreateInput>
    /**
     * In case the Apost was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ApostUpdateInput, ApostUncheckedUpdateInput>
  }


  /**
   * Apost delete
   */
  export type ApostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
    /**
     * Filter which Apost to delete.
     * 
    **/
    where: ApostWhereUniqueInput
  }


  /**
   * Apost deleteMany
   */
  export type ApostDeleteManyArgs = {
    where?: ApostWhereInput
  }


  /**
   * Apost without action
   */
  export type ApostArgs = {
    /**
     * Select specific fields to fetch from the Apost
     * 
    **/
    select?: ApostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApostInclude | null
  }



  /**
   * Model Areply
   */


  export type AggregateAreply = {
    _count: AreplyCountAggregateOutputType | null
    count: AreplyCountAggregateOutputType | null
    _avg: AreplyAvgAggregateOutputType | null
    avg: AreplyAvgAggregateOutputType | null
    _sum: AreplySumAggregateOutputType | null
    sum: AreplySumAggregateOutputType | null
    _min: AreplyMinAggregateOutputType | null
    min: AreplyMinAggregateOutputType | null
    _max: AreplyMaxAggregateOutputType | null
    max: AreplyMaxAggregateOutputType | null
  }

  export type AreplyAvgAggregateOutputType = {
    number: number | null
  }

  export type AreplySumAggregateOutputType = {
    number: number | null
  }

  export type AreplyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    userId: string | null
    apostId: string | null
  }

  export type AreplyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    userId: string | null
    apostId: string | null
  }

  export type AreplyCountAggregateOutputType = {
    id: number
    createdAt: number
    content: number
    number: number
    userId: number
    apostId: number
    _all: number
  }


  export type AreplyAvgAggregateInputType = {
    number?: true
  }

  export type AreplySumAggregateInputType = {
    number?: true
  }

  export type AreplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    userId?: true
    apostId?: true
  }

  export type AreplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    userId?: true
    apostId?: true
  }

  export type AreplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    userId?: true
    apostId?: true
    _all?: true
  }

  export type AreplyAggregateArgs = {
    /**
     * Filter which Areply to aggregate.
     * 
    **/
    where?: AreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areplies to fetch.
     * 
    **/
    orderBy?: Enumerable<AreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areplies
    **/
    _count?: true | AreplyCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AreplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreplyAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AreplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreplySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AreplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreplyMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AreplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreplyMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AreplyMaxAggregateInputType
  }

  export type GetAreplyAggregateType<T extends AreplyAggregateArgs> = {
        [P in keyof T & keyof AggregateAreply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreply[P]>
      : GetScalarType<T[P], AggregateAreply[P]>
  }


    
    
  export type AreplyGroupByArgs = {
    where?: AreplyWhereInput
    orderBy?: Enumerable<AreplyOrderByInput>
    by: Array<AreplyScalarFieldEnum>
    having?: AreplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreplyCountAggregateInputType | true
    _avg?: AreplyAvgAggregateInputType
    _sum?: AreplySumAggregateInputType
    _min?: AreplyMinAggregateInputType
    _max?: AreplyMaxAggregateInputType
  }


  export type AreplyGroupByOutputType = {
    id: string
    createdAt: Date
    content: string
    number: number
    userId: string
    apostId: string
    _count: AreplyCountAggregateOutputType | null
    _avg: AreplyAvgAggregateOutputType | null
    _sum: AreplySumAggregateOutputType | null
    _min: AreplyMinAggregateOutputType | null
    _max: AreplyMaxAggregateOutputType | null
  }

  type GetAreplyGroupByPayload<T extends AreplyGroupByArgs> = Promise<
    Array<
      PickArray<AreplyGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AreplyGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AreplyGroupByOutputType[P]> 
            : GetScalarType<T[P], AreplyGroupByOutputType[P]>
        }
      > 
    >


  export type AreplySelect = {
    id?: boolean
    createdAt?: boolean
    content?: boolean
    number?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    apost?: boolean | ApostArgs
    apostId?: boolean
  }

  export type AreplyInclude = {
    user?: boolean | UserArgs
    apost?: boolean | ApostArgs
  }

  export type AreplyGetPayload<
    S extends boolean | null | undefined | AreplyArgs,
    U = keyof S
      > = S extends true
        ? Areply
    : S extends undefined
    ? never
    : S extends AreplyArgs | AreplyFindManyArgs
    ?'include' extends U
    ? Areply  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'apost'
        ? ApostGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Areply ?Areply [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'apost'
        ? ApostGetPayload<S['select'][P]> : never
  } 
    : Areply
  : Areply


  type AreplyCountArgs = Merge<
    Omit<AreplyFindManyArgs, 'select' | 'include'> & {
      select?: AreplyCountAggregateInputType | true
    }
  >

  export interface AreplyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Areply that matches the filter.
     * @param {AreplyFindUniqueArgs} args - Arguments to find a Areply
     * @example
     * // Get one Areply
     * const areply = await prisma.areply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AreplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Areply'> extends True ? CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>> : CheckSelect<T, Prisma__AreplyClient<Areply | null >, Prisma__AreplyClient<AreplyGetPayload<T> | null >>

    /**
     * Find the first Areply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyFindFirstArgs} args - Arguments to find a Areply
     * @example
     * // Get one Areply
     * const areply = await prisma.areply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AreplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Areply'> extends True ? CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>> : CheckSelect<T, Prisma__AreplyClient<Areply | null >, Prisma__AreplyClient<AreplyGetPayload<T> | null >>

    /**
     * Find zero or more Areplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areplies
     * const areplies = await prisma.areply.findMany()
     * 
     * // Get first 10 Areplies
     * const areplies = await prisma.areply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areplyWithIdOnly = await prisma.areply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AreplyFindManyArgs>(
      args?: SelectSubset<T, AreplyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Areply>>, PrismaPromise<Array<AreplyGetPayload<T>>>>

    /**
     * Create a Areply.
     * @param {AreplyCreateArgs} args - Arguments to create a Areply.
     * @example
     * // Create one Areply
     * const Areply = await prisma.areply.create({
     *   data: {
     *     // ... data to create a Areply
     *   }
     * })
     * 
    **/
    create<T extends AreplyCreateArgs>(
      args: SelectSubset<T, AreplyCreateArgs>
    ): CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>>

    /**
     * Create many Areplies.
     *     @param {AreplyCreateManyArgs} args - Arguments to create many Areplies.
     *     @example
     *     // Create many Areplies
     *     const areply = await prisma.areply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AreplyCreateManyArgs>(
      args?: SelectSubset<T, AreplyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Areply.
     * @param {AreplyDeleteArgs} args - Arguments to delete one Areply.
     * @example
     * // Delete one Areply
     * const Areply = await prisma.areply.delete({
     *   where: {
     *     // ... filter to delete one Areply
     *   }
     * })
     * 
    **/
    delete<T extends AreplyDeleteArgs>(
      args: SelectSubset<T, AreplyDeleteArgs>
    ): CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>>

    /**
     * Update one Areply.
     * @param {AreplyUpdateArgs} args - Arguments to update one Areply.
     * @example
     * // Update one Areply
     * const areply = await prisma.areply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreplyUpdateArgs>(
      args: SelectSubset<T, AreplyUpdateArgs>
    ): CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>>

    /**
     * Delete zero or more Areplies.
     * @param {AreplyDeleteManyArgs} args - Arguments to filter Areplies to delete.
     * @example
     * // Delete a few Areplies
     * const { count } = await prisma.areply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreplyDeleteManyArgs>(
      args?: SelectSubset<T, AreplyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areplies
     * const areply = await prisma.areply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreplyUpdateManyArgs>(
      args: SelectSubset<T, AreplyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Areply.
     * @param {AreplyUpsertArgs} args - Arguments to update or create a Areply.
     * @example
     * // Update or create a Areply
     * const areply = await prisma.areply.upsert({
     *   create: {
     *     // ... data to create a Areply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Areply we want to update
     *   }
     * })
    **/
    upsert<T extends AreplyUpsertArgs>(
      args: SelectSubset<T, AreplyUpsertArgs>
    ): CheckSelect<T, Prisma__AreplyClient<Areply>, Prisma__AreplyClient<AreplyGetPayload<T>>>

    /**
     * Count the number of Areplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyCountArgs} args - Arguments to filter Areplies to count.
     * @example
     * // Count the number of Areplies
     * const count = await prisma.areply.count({
     *   where: {
     *     // ... the filter for the Areplies we want to count
     *   }
     * })
    **/
    count<T extends AreplyCountArgs>(
      args?: Subset<T, AreplyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Areply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreplyAggregateArgs>(args: Subset<T, AreplyAggregateArgs>): PrismaPromise<GetAreplyAggregateType<T>>

    /**
     * Group by Areply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreplyGroupByArgs['orderBy'] }
        : { orderBy?: AreplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreplyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Areply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AreplyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    apost<T extends ApostArgs = {}>(args?: Subset<T, ApostArgs>): CheckSelect<T, Prisma__ApostClient<Apost | null >, Prisma__ApostClient<ApostGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Areply findUnique
   */
  export type AreplyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * Throw an Error if a Areply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Areply to fetch.
     * 
    **/
    where: AreplyWhereUniqueInput
  }


  /**
   * Areply findFirst
   */
  export type AreplyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * Throw an Error if a Areply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Areply to fetch.
     * 
    **/
    where?: AreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areplies to fetch.
     * 
    **/
    orderBy?: Enumerable<AreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areplies.
     * 
    **/
    cursor?: AreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areplies.
     * 
    **/
    distinct?: Enumerable<AreplyScalarFieldEnum>
  }


  /**
   * Areply findMany
   */
  export type AreplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * Filter, which Areplies to fetch.
     * 
    **/
    where?: AreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areplies to fetch.
     * 
    **/
    orderBy?: Enumerable<AreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areplies.
     * 
    **/
    cursor?: AreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AreplyScalarFieldEnum>
  }


  /**
   * Areply create
   */
  export type AreplyCreateArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * The data needed to create a Areply.
     * 
    **/
    data: XOR<AreplyCreateInput, AreplyUncheckedCreateInput>
  }


  /**
   * Areply createMany
   */
  export type AreplyCreateManyArgs = {
    data: Enumerable<AreplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Areply update
   */
  export type AreplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * The data needed to update a Areply.
     * 
    **/
    data: XOR<AreplyUpdateInput, AreplyUncheckedUpdateInput>
    /**
     * Choose, which Areply to update.
     * 
    **/
    where: AreplyWhereUniqueInput
  }


  /**
   * Areply updateMany
   */
  export type AreplyUpdateManyArgs = {
    data: XOR<AreplyUpdateManyMutationInput, AreplyUncheckedUpdateManyInput>
    where?: AreplyWhereInput
  }


  /**
   * Areply upsert
   */
  export type AreplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * The filter to search for the Areply to update in case it exists.
     * 
    **/
    where: AreplyWhereUniqueInput
    /**
     * In case the Areply found by the `where` argument doesn't exist, create a new Areply with this data.
     * 
    **/
    create: XOR<AreplyCreateInput, AreplyUncheckedCreateInput>
    /**
     * In case the Areply was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AreplyUpdateInput, AreplyUncheckedUpdateInput>
  }


  /**
   * Areply delete
   */
  export type AreplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
    /**
     * Filter which Areply to delete.
     * 
    **/
    where: AreplyWhereUniqueInput
  }


  /**
   * Areply deleteMany
   */
  export type AreplyDeleteManyArgs = {
    where?: AreplyWhereInput
  }


  /**
   * Areply without action
   */
  export type AreplyArgs = {
    /**
     * Select specific fields to fetch from the Areply
     * 
    **/
    select?: AreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AreplyInclude | null
  }



  /**
   * Model Faq
   */


  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
    max: FaqMaxAggregateOutputType | null
  }

  export type FaqAvgAggregateOutputType = {
    orderSubject: number | null
  }

  export type FaqSumAggregateOutputType = {
    orderSubject: number | null
  }

  export type FaqMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    content: string | null
    orderSubject: number | null
  }

  export type FaqMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    content: string | null
    orderSubject: number | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    subject: number
    content: number
    orderSubject: number
    _all: number
  }


  export type FaqAvgAggregateInputType = {
    orderSubject?: true
  }

  export type FaqSumAggregateInputType = {
    orderSubject?: true
  }

  export type FaqMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    content?: true
    orderSubject?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    content?: true
    orderSubject?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    content?: true
    orderSubject?: true
    _all?: true
  }

  export type FaqAggregateArgs = {
    /**
     * Filter which Faq to aggregate.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: FaqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: FaqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }


    
    
  export type FaqGroupByArgs = {
    where?: FaqWhereInput
    orderBy?: Enumerable<FaqOrderByInput>
    by: Array<FaqScalarFieldEnum>
    having?: FaqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _avg?: FaqAvgAggregateInputType
    _sum?: FaqSumAggregateInputType
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }


  export type FaqGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    subject: string
    content: string
    orderSubject: number
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = Promise<
    Array<
      PickArray<FaqGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], FaqGroupByOutputType[P]> 
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      > 
    >


  export type FaqSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    content?: boolean
    orderSubject?: boolean
  }

  export type FaqGetPayload<
    S extends boolean | null | undefined | FaqArgs,
    U = keyof S
      > = S extends true
        ? Faq
    : S extends undefined
    ? never
    : S extends FaqArgs | FaqFindManyArgs
    ?'include' extends U
    ? Faq 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Faq ?Faq [P]
  : 
     never
  } 
    : Faq
  : Faq


  type FaqCountArgs = Merge<
    Omit<FaqFindManyArgs, 'select' | 'include'> & {
      select?: FaqCountAggregateInputType | true
    }
  >

  export interface FaqDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Faq that matches the filter.
     * @param {FaqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FaqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FaqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null >, Prisma__FaqClient<FaqGetPayload<T> | null >>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FaqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FaqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null >, Prisma__FaqClient<FaqGetPayload<T> | null >>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FaqFindManyArgs>(
      args?: SelectSubset<T, FaqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Faq>>, PrismaPromise<Array<FaqGetPayload<T>>>>

    /**
     * Create a Faq.
     * @param {FaqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
    **/
    create<T extends FaqCreateArgs>(
      args: SelectSubset<T, FaqCreateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Create many Faqs.
     *     @param {FaqCreateManyArgs} args - Arguments to create many Faqs.
     *     @example
     *     // Create many Faqs
     *     const faq = await prisma.faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FaqCreateManyArgs>(
      args?: SelectSubset<T, FaqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {FaqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
    **/
    delete<T extends FaqDeleteArgs>(
      args: SelectSubset<T, FaqDeleteArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Update one Faq.
     * @param {FaqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FaqUpdateArgs>(
      args: SelectSubset<T, FaqUpdateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Delete zero or more Faqs.
     * @param {FaqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FaqDeleteManyArgs>(
      args?: SelectSubset<T, FaqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FaqUpdateManyArgs>(
      args: SelectSubset<T, FaqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {FaqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
    **/
    upsert<T extends FaqUpsertArgs>(
      args: SelectSubset<T, FaqUpsertArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqCountArgs>(
      args?: Subset<T, FaqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FaqClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Faq findUnique
   */
  export type FaqFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Throw an Error if a Faq can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq findFirst
   */
  export type FaqFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Throw an Error if a Faq can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     * 
    **/
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * Faq findMany
   */
  export type FaqFindManyArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter, which Faqs to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * Faq create
   */
  export type FaqCreateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to create a Faq.
     * 
    **/
    data: XOR<FaqCreateInput, FaqUncheckedCreateInput>
  }


  /**
   * Faq createMany
   */
  export type FaqCreateManyArgs = {
    data: Enumerable<FaqCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Faq update
   */
  export type FaqUpdateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to update a Faq.
     * 
    **/
    data: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
    /**
     * Choose, which Faq to update.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq updateMany
   */
  export type FaqUpdateManyArgs = {
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    where?: FaqWhereInput
  }


  /**
   * Faq upsert
   */
  export type FaqUpsertArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The filter to search for the Faq to update in case it exists.
     * 
    **/
    where: FaqWhereUniqueInput
    /**
     * In case the Faq found by the `where` argument doesn't exist, create a new Faq with this data.
     * 
    **/
    create: XOR<FaqCreateInput, FaqUncheckedCreateInput>
    /**
     * In case the Faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
  }


  /**
   * Faq delete
   */
  export type FaqDeleteArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter which Faq to delete.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq deleteMany
   */
  export type FaqDeleteManyArgs = {
    where?: FaqWhereInput
  }


  /**
   * Faq without action
   */
  export type FaqArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
  }



  /**
   * Model Token
   */


  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
    max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    id: number | null
  }

  export type TokenSumAggregateOutputType = {
    id: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hashedToken: string | null
    type: string | null
    expiresAt: Date | null
    sentTo: string | null
    userId: string | null
  }

  export type TokenMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hashedToken: string | null
    type: string | null
    expiresAt: Date | null
    sentTo: string | null
    userId: string | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    hashedToken: number
    type: number
    expiresAt: number
    sentTo: number
    userId: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    id?: true
  }

  export type TokenSumAggregateInputType = {
    id?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    userId?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    userId?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    userId?: true
    _all?: true
  }

  export type TokenAggregateArgs = {
    /**
     * Filter which Token to aggregate.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }


    
    
  export type TokenGroupByArgs = {
    where?: TokenWhereInput
    orderBy?: Enumerable<TokenOrderByInput>
    by: Array<TokenScalarFieldEnum>
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }


  export type TokenGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    hashedToken: string
    type: string
    expiresAt: Date
    sentTo: string
    userId: string
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Promise<
    Array<
      PickArray<TokenGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TokenGroupByOutputType[P]> 
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      > 
    >


  export type TokenSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashedToken?: boolean
    type?: boolean
    expiresAt?: boolean
    sentTo?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type TokenInclude = {
    user?: boolean | UserArgs
  }

  export type TokenGetPayload<
    S extends boolean | null | undefined | TokenArgs,
    U = keyof S
      > = S extends true
        ? Token
    : S extends undefined
    ? never
    : S extends TokenArgs | TokenFindManyArgs
    ?'include' extends U
    ? Token  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Token ?Token [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Token
  : Token


  type TokenCountArgs = Merge<
    Omit<TokenFindManyArgs, 'select' | 'include'> & {
      select?: TokenCountAggregateInputType | true
    }
  >

  export interface TokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null >, Prisma__TokenClient<TokenGetPayload<T> | null >>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null >, Prisma__TokenClient<TokenGetPayload<T> | null >>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenFindManyArgs>(
      args?: SelectSubset<T, TokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Token>>, PrismaPromise<Array<TokenGetPayload<T>>>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
    **/
    create<T extends TokenCreateArgs>(
      args: SelectSubset<T, TokenCreateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Create many Tokens.
     *     @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const token = await prisma.token.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenCreateManyArgs>(
      args?: SelectSubset<T, TokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
    **/
    delete<T extends TokenDeleteArgs>(
      args: SelectSubset<T, TokenDeleteArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenUpdateArgs>(
      args: SelectSubset<T, TokenUpdateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenDeleteManyArgs>(
      args?: SelectSubset<T, TokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenUpdateManyArgs>(
      args: SelectSubset<T, TokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
    **/
    upsert<T extends TokenUpsertArgs>(
      args: SelectSubset<T, TokenUpsertArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Throw an Error if a Token can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Throw an Error if a Token can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     * 
    **/
    distinct?: Enumerable<TokenScalarFieldEnum>
  }


  /**
   * Token findMany
   */
  export type TokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter, which Tokens to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TokenScalarFieldEnum>
  }


  /**
   * Token create
   */
  export type TokenCreateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to create a Token.
     * 
    **/
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }


  /**
   * Token createMany
   */
  export type TokenCreateManyArgs = {
    data: Enumerable<TokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Token update
   */
  export type TokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to update a Token.
     * 
    **/
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs = {
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    where?: TokenWhereInput
  }


  /**
   * Token upsert
   */
  export type TokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The filter to search for the Token to update in case it exists.
     * 
    **/
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     * 
    **/
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }


  /**
   * Token delete
   */
  export type TokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter which Token to delete.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs = {
    where?: TokenWhereInput
  }


  /**
   * Token without action
   */
  export type TokenArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
  }



  /**
   * Model TokenMailVerification
   */


  export type AggregateTokenMailVerification = {
    _count: TokenMailVerificationCountAggregateOutputType | null
    count: TokenMailVerificationCountAggregateOutputType | null
    _avg: TokenMailVerificationAvgAggregateOutputType | null
    avg: TokenMailVerificationAvgAggregateOutputType | null
    _sum: TokenMailVerificationSumAggregateOutputType | null
    sum: TokenMailVerificationSumAggregateOutputType | null
    _min: TokenMailVerificationMinAggregateOutputType | null
    min: TokenMailVerificationMinAggregateOutputType | null
    _max: TokenMailVerificationMaxAggregateOutputType | null
    max: TokenMailVerificationMaxAggregateOutputType | null
  }

  export type TokenMailVerificationAvgAggregateOutputType = {
    id: number | null
  }

  export type TokenMailVerificationSumAggregateOutputType = {
    id: number | null
  }

  export type TokenMailVerificationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hashedToken: string | null
    type: string | null
    expiresAt: Date | null
    sentTo: string | null
    hashedPassword: string | null
    name: string | null
  }

  export type TokenMailVerificationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hashedToken: string | null
    type: string | null
    expiresAt: Date | null
    sentTo: string | null
    hashedPassword: string | null
    name: string | null
  }

  export type TokenMailVerificationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    hashedToken: number
    type: number
    expiresAt: number
    sentTo: number
    hashedPassword: number
    name: number
    _all: number
  }


  export type TokenMailVerificationAvgAggregateInputType = {
    id?: true
  }

  export type TokenMailVerificationSumAggregateInputType = {
    id?: true
  }

  export type TokenMailVerificationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    hashedPassword?: true
    name?: true
  }

  export type TokenMailVerificationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    hashedPassword?: true
    name?: true
  }

  export type TokenMailVerificationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    hashedToken?: true
    type?: true
    expiresAt?: true
    sentTo?: true
    hashedPassword?: true
    name?: true
    _all?: true
  }

  export type TokenMailVerificationAggregateArgs = {
    /**
     * Filter which TokenMailVerification to aggregate.
     * 
    **/
    where?: TokenMailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenMailVerifications to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenMailVerificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TokenMailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenMailVerifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenMailVerifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenMailVerifications
    **/
    _count?: true | TokenMailVerificationCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TokenMailVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenMailVerificationAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TokenMailVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenMailVerificationSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TokenMailVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMailVerificationMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TokenMailVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMailVerificationMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TokenMailVerificationMaxAggregateInputType
  }

  export type GetTokenMailVerificationAggregateType<T extends TokenMailVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenMailVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenMailVerification[P]>
      : GetScalarType<T[P], AggregateTokenMailVerification[P]>
  }


    
    
  export type TokenMailVerificationGroupByArgs = {
    where?: TokenMailVerificationWhereInput
    orderBy?: Enumerable<TokenMailVerificationOrderByInput>
    by: Array<TokenMailVerificationScalarFieldEnum>
    having?: TokenMailVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenMailVerificationCountAggregateInputType | true
    _avg?: TokenMailVerificationAvgAggregateInputType
    _sum?: TokenMailVerificationSumAggregateInputType
    _min?: TokenMailVerificationMinAggregateInputType
    _max?: TokenMailVerificationMaxAggregateInputType
  }


  export type TokenMailVerificationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    hashedToken: string
    type: string
    expiresAt: Date
    sentTo: string
    hashedPassword: string
    name: string
    _count: TokenMailVerificationCountAggregateOutputType | null
    _avg: TokenMailVerificationAvgAggregateOutputType | null
    _sum: TokenMailVerificationSumAggregateOutputType | null
    _min: TokenMailVerificationMinAggregateOutputType | null
    _max: TokenMailVerificationMaxAggregateOutputType | null
  }

  type GetTokenMailVerificationGroupByPayload<T extends TokenMailVerificationGroupByArgs> = Promise<
    Array<
      PickArray<TokenMailVerificationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TokenMailVerificationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TokenMailVerificationGroupByOutputType[P]> 
            : GetScalarType<T[P], TokenMailVerificationGroupByOutputType[P]>
        }
      > 
    >


  export type TokenMailVerificationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hashedToken?: boolean
    type?: boolean
    expiresAt?: boolean
    sentTo?: boolean
    hashedPassword?: boolean
    name?: boolean
  }

  export type TokenMailVerificationGetPayload<
    S extends boolean | null | undefined | TokenMailVerificationArgs,
    U = keyof S
      > = S extends true
        ? TokenMailVerification
    : S extends undefined
    ? never
    : S extends TokenMailVerificationArgs | TokenMailVerificationFindManyArgs
    ?'include' extends U
    ? TokenMailVerification 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TokenMailVerification ?TokenMailVerification [P]
  : 
     never
  } 
    : TokenMailVerification
  : TokenMailVerification


  type TokenMailVerificationCountArgs = Merge<
    Omit<TokenMailVerificationFindManyArgs, 'select' | 'include'> & {
      select?: TokenMailVerificationCountAggregateInputType | true
    }
  >

  export interface TokenMailVerificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TokenMailVerification that matches the filter.
     * @param {TokenMailVerificationFindUniqueArgs} args - Arguments to find a TokenMailVerification
     * @example
     * // Get one TokenMailVerification
     * const tokenMailVerification = await prisma.tokenMailVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenMailVerificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TokenMailVerificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TokenMailVerification'> extends True ? CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>> : CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification | null >, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T> | null >>

    /**
     * Find the first TokenMailVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationFindFirstArgs} args - Arguments to find a TokenMailVerification
     * @example
     * // Get one TokenMailVerification
     * const tokenMailVerification = await prisma.tokenMailVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenMailVerificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TokenMailVerificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TokenMailVerification'> extends True ? CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>> : CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification | null >, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T> | null >>

    /**
     * Find zero or more TokenMailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenMailVerifications
     * const tokenMailVerifications = await prisma.tokenMailVerification.findMany()
     * 
     * // Get first 10 TokenMailVerifications
     * const tokenMailVerifications = await prisma.tokenMailVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenMailVerificationWithIdOnly = await prisma.tokenMailVerification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenMailVerificationFindManyArgs>(
      args?: SelectSubset<T, TokenMailVerificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TokenMailVerification>>, PrismaPromise<Array<TokenMailVerificationGetPayload<T>>>>

    /**
     * Create a TokenMailVerification.
     * @param {TokenMailVerificationCreateArgs} args - Arguments to create a TokenMailVerification.
     * @example
     * // Create one TokenMailVerification
     * const TokenMailVerification = await prisma.tokenMailVerification.create({
     *   data: {
     *     // ... data to create a TokenMailVerification
     *   }
     * })
     * 
    **/
    create<T extends TokenMailVerificationCreateArgs>(
      args: SelectSubset<T, TokenMailVerificationCreateArgs>
    ): CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>>

    /**
     * Create many TokenMailVerifications.
     *     @param {TokenMailVerificationCreateManyArgs} args - Arguments to create many TokenMailVerifications.
     *     @example
     *     // Create many TokenMailVerifications
     *     const tokenMailVerification = await prisma.tokenMailVerification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenMailVerificationCreateManyArgs>(
      args?: SelectSubset<T, TokenMailVerificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TokenMailVerification.
     * @param {TokenMailVerificationDeleteArgs} args - Arguments to delete one TokenMailVerification.
     * @example
     * // Delete one TokenMailVerification
     * const TokenMailVerification = await prisma.tokenMailVerification.delete({
     *   where: {
     *     // ... filter to delete one TokenMailVerification
     *   }
     * })
     * 
    **/
    delete<T extends TokenMailVerificationDeleteArgs>(
      args: SelectSubset<T, TokenMailVerificationDeleteArgs>
    ): CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>>

    /**
     * Update one TokenMailVerification.
     * @param {TokenMailVerificationUpdateArgs} args - Arguments to update one TokenMailVerification.
     * @example
     * // Update one TokenMailVerification
     * const tokenMailVerification = await prisma.tokenMailVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenMailVerificationUpdateArgs>(
      args: SelectSubset<T, TokenMailVerificationUpdateArgs>
    ): CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>>

    /**
     * Delete zero or more TokenMailVerifications.
     * @param {TokenMailVerificationDeleteManyArgs} args - Arguments to filter TokenMailVerifications to delete.
     * @example
     * // Delete a few TokenMailVerifications
     * const { count } = await prisma.tokenMailVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenMailVerificationDeleteManyArgs>(
      args?: SelectSubset<T, TokenMailVerificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenMailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenMailVerifications
     * const tokenMailVerification = await prisma.tokenMailVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenMailVerificationUpdateManyArgs>(
      args: SelectSubset<T, TokenMailVerificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenMailVerification.
     * @param {TokenMailVerificationUpsertArgs} args - Arguments to update or create a TokenMailVerification.
     * @example
     * // Update or create a TokenMailVerification
     * const tokenMailVerification = await prisma.tokenMailVerification.upsert({
     *   create: {
     *     // ... data to create a TokenMailVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenMailVerification we want to update
     *   }
     * })
    **/
    upsert<T extends TokenMailVerificationUpsertArgs>(
      args: SelectSubset<T, TokenMailVerificationUpsertArgs>
    ): CheckSelect<T, Prisma__TokenMailVerificationClient<TokenMailVerification>, Prisma__TokenMailVerificationClient<TokenMailVerificationGetPayload<T>>>

    /**
     * Count the number of TokenMailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationCountArgs} args - Arguments to filter TokenMailVerifications to count.
     * @example
     * // Count the number of TokenMailVerifications
     * const count = await prisma.tokenMailVerification.count({
     *   where: {
     *     // ... the filter for the TokenMailVerifications we want to count
     *   }
     * })
    **/
    count<T extends TokenMailVerificationCountArgs>(
      args?: Subset<T, TokenMailVerificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenMailVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenMailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenMailVerificationAggregateArgs>(args: Subset<T, TokenMailVerificationAggregateArgs>): PrismaPromise<GetTokenMailVerificationAggregateType<T>>

    /**
     * Group by TokenMailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenMailVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenMailVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenMailVerificationGroupByArgs['orderBy'] }
        : { orderBy?: TokenMailVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenMailVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenMailVerificationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenMailVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokenMailVerificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TokenMailVerification findUnique
   */
  export type TokenMailVerificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * Throw an Error if a TokenMailVerification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TokenMailVerification to fetch.
     * 
    **/
    where: TokenMailVerificationWhereUniqueInput
  }


  /**
   * TokenMailVerification findFirst
   */
  export type TokenMailVerificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * Throw an Error if a TokenMailVerification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TokenMailVerification to fetch.
     * 
    **/
    where?: TokenMailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenMailVerifications to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenMailVerificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenMailVerifications.
     * 
    **/
    cursor?: TokenMailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenMailVerifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenMailVerifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenMailVerifications.
     * 
    **/
    distinct?: Enumerable<TokenMailVerificationScalarFieldEnum>
  }


  /**
   * TokenMailVerification findMany
   */
  export type TokenMailVerificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * Filter, which TokenMailVerifications to fetch.
     * 
    **/
    where?: TokenMailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenMailVerifications to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenMailVerificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenMailVerifications.
     * 
    **/
    cursor?: TokenMailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenMailVerifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenMailVerifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TokenMailVerificationScalarFieldEnum>
  }


  /**
   * TokenMailVerification create
   */
  export type TokenMailVerificationCreateArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * The data needed to create a TokenMailVerification.
     * 
    **/
    data: XOR<TokenMailVerificationCreateInput, TokenMailVerificationUncheckedCreateInput>
  }


  /**
   * TokenMailVerification createMany
   */
  export type TokenMailVerificationCreateManyArgs = {
    data: Enumerable<TokenMailVerificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TokenMailVerification update
   */
  export type TokenMailVerificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * The data needed to update a TokenMailVerification.
     * 
    **/
    data: XOR<TokenMailVerificationUpdateInput, TokenMailVerificationUncheckedUpdateInput>
    /**
     * Choose, which TokenMailVerification to update.
     * 
    **/
    where: TokenMailVerificationWhereUniqueInput
  }


  /**
   * TokenMailVerification updateMany
   */
  export type TokenMailVerificationUpdateManyArgs = {
    data: XOR<TokenMailVerificationUpdateManyMutationInput, TokenMailVerificationUncheckedUpdateManyInput>
    where?: TokenMailVerificationWhereInput
  }


  /**
   * TokenMailVerification upsert
   */
  export type TokenMailVerificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * The filter to search for the TokenMailVerification to update in case it exists.
     * 
    **/
    where: TokenMailVerificationWhereUniqueInput
    /**
     * In case the TokenMailVerification found by the `where` argument doesn't exist, create a new TokenMailVerification with this data.
     * 
    **/
    create: XOR<TokenMailVerificationCreateInput, TokenMailVerificationUncheckedCreateInput>
    /**
     * In case the TokenMailVerification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TokenMailVerificationUpdateInput, TokenMailVerificationUncheckedUpdateInput>
  }


  /**
   * TokenMailVerification delete
   */
  export type TokenMailVerificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
    /**
     * Filter which TokenMailVerification to delete.
     * 
    **/
    where: TokenMailVerificationWhereUniqueInput
  }


  /**
   * TokenMailVerification deleteMany
   */
  export type TokenMailVerificationDeleteManyArgs = {
    where?: TokenMailVerificationWhereInput
  }


  /**
   * TokenMailVerification without action
   */
  export type TokenMailVerificationArgs = {
    /**
     * Select specific fields to fetch from the TokenMailVerification
     * 
    **/
    select?: TokenMailVerificationSelect | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
    max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    asset_id: string | null
    url: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    asset_id: string | null
    url: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    asset_id: number
    url: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    asset_id?: true
    url?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    asset_id?: true
    url?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    asset_id?: true
    url?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which Image to aggregate.
     * 
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }


    
    
  export type ImageGroupByArgs = {
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByInput>
    by: Array<ImageScalarFieldEnum>
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: string
    createdAt: Date
    userId: string
    asset_id: string
    url: string
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Promise<
    Array<
      PickArray<ImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ImageGroupByOutputType[P]> 
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      > 
    >


  export type ImageSelect = {
    id?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    asset_id?: boolean
    url?: boolean
  }

  export type ImageInclude = {
    user?: boolean | UserArgs
  }

  export type ImageGetPayload<
    S extends boolean | null | undefined | ImageArgs,
    U = keyof S
      > = S extends true
        ? Image
    : S extends undefined
    ? never
    : S extends ImageArgs | ImageFindManyArgs
    ?'include' extends U
    ? Image  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Image ?Image [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Image
  : Image


  type ImageCountArgs = Merge<
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }
  >

  export interface ImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Image'> extends True ? CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>> : CheckSelect<T, Prisma__ImageClient<Image | null >, Prisma__ImageClient<ImageGetPayload<T> | null >>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Image'> extends True ? CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>> : CheckSelect<T, Prisma__ImageClient<Image | null >, Prisma__ImageClient<ImageGetPayload<T> | null >>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Image>>, PrismaPromise<Array<ImageGetPayload<T>>>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs>(
      args?: SelectSubset<T, ImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
     * 
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
     * 
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     * 
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     * 
    **/
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * Filter, which Images to fetch.
     * 
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     * 
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     * 
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * The data needed to create a Image.
     * 
    **/
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs = {
    data: Enumerable<ImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * The data needed to update a Image.
     * 
    **/
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     * 
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs = {
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * The filter to search for the Image to update in case it exists.
     * 
    **/
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     * 
    **/
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
    /**
     * Filter which Image to delete.
     * 
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs = {
    where?: ImageWhereInput
  }


  /**
   * Image without action
   */
  export type ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
     * 
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ImageInclude | null
  }



  /**
   * Model Team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
    max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    anneeCreation: number | null
    taille: number | null
    teamLatitude: number | null
    teamLongitude: number | null
    findIndex: number | null
  }

  export type TeamSumAggregateOutputType = {
    anneeCreation: number | null
    taille: number | null
    teamLatitude: number | null
    teamLongitude: number | null
    findIndex: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    corpus: string | null
    anneeCreation: number | null
    secteur: string | null
    typeOrg: string | null
    taille: number | null
    teamLatitude: number | null
    teamLongitude: number | null
    image: string | null
    imageCover: string | null
    public: boolean | null
    findIndex: number | null
    publishDemand: boolean | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    corpus: string | null
    anneeCreation: number | null
    secteur: string | null
    typeOrg: string | null
    taille: number | null
    teamLatitude: number | null
    teamLongitude: number | null
    image: string | null
    imageCover: string | null
    public: boolean | null
    findIndex: number | null
    publishDemand: boolean | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    corpus: number
    anneeCreation: number
    secteur: number
    typeOrg: number
    taille: number
    teamLatitude: number
    teamLongitude: number
    image: number
    imageCover: number
    TeamMastersID: number
    TeamMemberId: number
    public: number
    findIndex: number
    publishDemand: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    anneeCreation?: true
    taille?: true
    teamLatitude?: true
    teamLongitude?: true
    findIndex?: true
  }

  export type TeamSumAggregateInputType = {
    anneeCreation?: true
    taille?: true
    teamLatitude?: true
    teamLongitude?: true
    findIndex?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    corpus?: true
    anneeCreation?: true
    secteur?: true
    typeOrg?: true
    taille?: true
    teamLatitude?: true
    teamLongitude?: true
    image?: true
    imageCover?: true
    public?: true
    findIndex?: true
    publishDemand?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    corpus?: true
    anneeCreation?: true
    secteur?: true
    typeOrg?: true
    taille?: true
    teamLatitude?: true
    teamLongitude?: true
    image?: true
    imageCover?: true
    public?: true
    findIndex?: true
    publishDemand?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    corpus?: true
    anneeCreation?: true
    secteur?: true
    typeOrg?: true
    taille?: true
    teamLatitude?: true
    teamLongitude?: true
    image?: true
    imageCover?: true
    TeamMastersID?: true
    TeamMemberId?: true
    public?: true
    findIndex?: true
    publishDemand?: true
    _all?: true
  }

  export type TeamAggregateArgs = {
    /**
     * Filter which Team to aggregate.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }


    
    
  export type TeamGroupByArgs = {
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByInput>
    by: Array<TeamScalarFieldEnum>
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string
    corpus: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image: string
    imageCover: string
    TeamMastersID: string[]
    TeamMemberId: string[]
    public: boolean
    findIndex: number
    publishDemand: boolean
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Promise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TeamGroupByOutputType[P]> 
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      > 
    >


  export type TeamSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    corpus?: boolean
    anneeCreation?: boolean
    secteur?: boolean
    typeOrg?: boolean
    taille?: boolean
    teamLatitude?: boolean
    teamLongitude?: boolean
    image?: boolean
    imageCover?: boolean
    TeamMastersID?: boolean
    TeamMemberId?: boolean
    users?: boolean | UserFindManyArgs
    public?: boolean
    tposts?: boolean | TpostFindManyArgs
    findIndex?: boolean
    tevents?: boolean | TeventFindManyArgs
    treplies?: boolean | TreplyFindManyArgs
    ereplies?: boolean | EreplyFindManyArgs
    tags?: boolean | TagFindManyArgs
    teamFollowers?: boolean | TeamFollowerFindManyArgs
    publishDemand?: boolean
  }

  export type TeamInclude = {
    users?: boolean | UserFindManyArgs
    tposts?: boolean | TpostFindManyArgs
    tevents?: boolean | TeventFindManyArgs
    treplies?: boolean | TreplyFindManyArgs
    ereplies?: boolean | EreplyFindManyArgs
    tags?: boolean | TagFindManyArgs
    teamFollowers?: boolean | TeamFollowerFindManyArgs
  }

  export type TeamGetPayload<
    S extends boolean | null | undefined | TeamArgs,
    U = keyof S
      > = S extends true
        ? Team
    : S extends undefined
    ? never
    : S extends TeamArgs | TeamFindManyArgs
    ?'include' extends U
    ? Team  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'tposts'
        ? Array < TpostGetPayload<S['include'][P]>>  :
        P extends 'tevents'
        ? Array < TeventGetPayload<S['include'][P]>>  :
        P extends 'treplies'
        ? Array < TreplyGetPayload<S['include'][P]>>  :
        P extends 'ereplies'
        ? Array < EreplyGetPayload<S['include'][P]>>  :
        P extends 'tags'
        ? Array < TagGetPayload<S['include'][P]>>  :
        P extends 'teamFollowers'
        ? Array < TeamFollowerGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Team ?Team [P]
  : 
          P extends 'users'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'tposts'
        ? Array < TpostGetPayload<S['select'][P]>>  :
        P extends 'tevents'
        ? Array < TeventGetPayload<S['select'][P]>>  :
        P extends 'treplies'
        ? Array < TreplyGetPayload<S['select'][P]>>  :
        P extends 'ereplies'
        ? Array < EreplyGetPayload<S['select'][P]>>  :
        P extends 'tags'
        ? Array < TagGetPayload<S['select'][P]>>  :
        P extends 'teamFollowers'
        ? Array < TeamFollowerGetPayload<S['select'][P]>>  : never
  } 
    : Team
  : Team


  type TeamCountArgs = Merge<
    Omit<TeamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }
  >

  export interface TeamDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Team'> extends True ? CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>> : CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Team'> extends True ? CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>> : CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Create many Teams.
     *     @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamCreateManyArgs>(
      args?: SelectSubset<T, TeamCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    tposts<T extends TpostFindManyArgs = {}>(args?: Subset<T, TpostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tpost>>, PrismaPromise<Array<TpostGetPayload<T>>>>;

    tevents<T extends TeventFindManyArgs = {}>(args?: Subset<T, TeventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tevent>>, PrismaPromise<Array<TeventGetPayload<T>>>>;

    treplies<T extends TreplyFindManyArgs = {}>(args?: Subset<T, TreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Treply>>, PrismaPromise<Array<TreplyGetPayload<T>>>>;

    ereplies<T extends EreplyFindManyArgs = {}>(args?: Subset<T, EreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ereply>>, PrismaPromise<Array<EreplyGetPayload<T>>>>;

    tags<T extends TagFindManyArgs = {}>(args?: Subset<T, TagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>;

    teamFollowers<T extends TeamFollowerFindManyArgs = {}>(args?: Subset<T, TeamFollowerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamFollower>>, PrismaPromise<Array<TeamFollowerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     * 
    **/
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team findMany
   */
  export type TeamFindManyArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Filter, which Teams to fetch.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team create
   */
  export type TeamCreateArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The data needed to create a Team.
     * 
    **/
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }


  /**
   * Team createMany
   */
  export type TeamCreateManyArgs = {
    data: Enumerable<TeamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Team update
   */
  export type TeamUpdateArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The data needed to update a Team.
     * 
    **/
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs = {
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    where?: TeamWhereInput
  }


  /**
   * Team upsert
   */
  export type TeamUpsertArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The filter to search for the Team to update in case it exists.
     * 
    **/
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     * 
    **/
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }


  /**
   * Team delete
   */
  export type TeamDeleteArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Filter which Team to delete.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs = {
    where?: TeamWhereInput
  }


  /**
   * Team without action
   */
  export type TeamArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
    max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    isPublic: boolean | null
    catSpecific: string | null
  }

  export type TagMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    isPublic: boolean | null
    catSpecific: string | null
  }

  export type TagCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    isPublic: number
    catSpecific: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    isPublic?: true
    catSpecific?: true
  }

  export type TagMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    isPublic?: true
    catSpecific?: true
  }

  export type TagCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    isPublic?: true
    catSpecific?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }


    
    
  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByInput>
    by: Array<TagScalarFieldEnum>
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    isPublic: boolean
    catSpecific: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Promise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TagGroupByOutputType[P]> 
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      > 
    >


  export type TagSelect = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    teams?: boolean | TeamFindManyArgs
    isPublic?: boolean
    catSpecific?: boolean
  }

  export type TagInclude = {
    teams?: boolean | TeamFindManyArgs
  }

  export type TagGetPayload<
    S extends boolean | null | undefined | TagArgs,
    U = keyof S
      > = S extends true
        ? Tag
    : S extends undefined
    ? never
    : S extends TagArgs | TagFindManyArgs
    ?'include' extends U
    ? Tag  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'teams'
        ? Array < TeamGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tag ?Tag [P]
  : 
          P extends 'teams'
        ? Array < TeamGetPayload<S['select'][P]>>  : never
  } 
    : Tag
  : Tag


  type TagCountArgs = Merge<
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }
  >

  export interface TagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const tagWithCreatedAtOnly = await prisma.tag.findMany({ select: { createdAt: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    teams<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to create a Tag.
     * 
    **/
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to update a Tag.
     * 
    **/
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The filter to search for the Tag to update in case it exists.
     * 
    **/
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     * 
    **/
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter which Tag to delete.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    where?: TagWhereInput
  }


  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
  }



  /**
   * Model TeamFollower
   */


  export type AggregateTeamFollower = {
    _count: TeamFollowerCountAggregateOutputType | null
    count: TeamFollowerCountAggregateOutputType | null
    _min: TeamFollowerMinAggregateOutputType | null
    min: TeamFollowerMinAggregateOutputType | null
    _max: TeamFollowerMaxAggregateOutputType | null
    max: TeamFollowerMaxAggregateOutputType | null
  }

  export type TeamFollowerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    followerId: string | null
  }

  export type TeamFollowerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    followerId: string | null
  }

  export type TeamFollowerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    teamId: number
    followerId: number
    _all: number
  }


  export type TeamFollowerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    followerId?: true
  }

  export type TeamFollowerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    followerId?: true
  }

  export type TeamFollowerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    followerId?: true
    _all?: true
  }

  export type TeamFollowerAggregateArgs = {
    /**
     * Filter which TeamFollower to aggregate.
     * 
    **/
    where?: TeamFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFollowers to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamFollowerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFollowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFollowers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamFollowers
    **/
    _count?: true | TeamFollowerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TeamFollowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamFollowerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TeamFollowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamFollowerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TeamFollowerMaxAggregateInputType
  }

  export type GetTeamFollowerAggregateType<T extends TeamFollowerAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamFollower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamFollower[P]>
      : GetScalarType<T[P], AggregateTeamFollower[P]>
  }


    
    
  export type TeamFollowerGroupByArgs = {
    where?: TeamFollowerWhereInput
    orderBy?: Enumerable<TeamFollowerOrderByInput>
    by: Array<TeamFollowerScalarFieldEnum>
    having?: TeamFollowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamFollowerCountAggregateInputType | true
    _min?: TeamFollowerMinAggregateInputType
    _max?: TeamFollowerMaxAggregateInputType
  }


  export type TeamFollowerGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    teamId: string
    followerId: string
    _count: TeamFollowerCountAggregateOutputType | null
    _min: TeamFollowerMinAggregateOutputType | null
    _max: TeamFollowerMaxAggregateOutputType | null
  }

  type GetTeamFollowerGroupByPayload<T extends TeamFollowerGroupByArgs> = Promise<
    Array<
      PickArray<TeamFollowerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TeamFollowerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TeamFollowerGroupByOutputType[P]> 
            : GetScalarType<T[P], TeamFollowerGroupByOutputType[P]>
        }
      > 
    >


  export type TeamFollowerSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamFindManyArgs
    teamId?: boolean
    user?: boolean | UserFindManyArgs
    followerId?: boolean
  }

  export type TeamFollowerInclude = {
    team?: boolean | TeamFindManyArgs
    user?: boolean | UserFindManyArgs
  }

  export type TeamFollowerGetPayload<
    S extends boolean | null | undefined | TeamFollowerArgs,
    U = keyof S
      > = S extends true
        ? TeamFollower
    : S extends undefined
    ? never
    : S extends TeamFollowerArgs | TeamFollowerFindManyArgs
    ?'include' extends U
    ? TeamFollower  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'team'
        ? Array < TeamGetPayload<S['include'][P]>>  :
        P extends 'user'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TeamFollower ?TeamFollower [P]
  : 
          P extends 'team'
        ? Array < TeamGetPayload<S['select'][P]>>  :
        P extends 'user'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : TeamFollower
  : TeamFollower


  type TeamFollowerCountArgs = Merge<
    Omit<TeamFollowerFindManyArgs, 'select' | 'include'> & {
      select?: TeamFollowerCountAggregateInputType | true
    }
  >

  export interface TeamFollowerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TeamFollower that matches the filter.
     * @param {TeamFollowerFindUniqueArgs} args - Arguments to find a TeamFollower
     * @example
     * // Get one TeamFollower
     * const teamFollower = await prisma.teamFollower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFollowerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamFollowerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamFollower'> extends True ? CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>> : CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower | null >, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T> | null >>

    /**
     * Find the first TeamFollower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerFindFirstArgs} args - Arguments to find a TeamFollower
     * @example
     * // Get one TeamFollower
     * const teamFollower = await prisma.teamFollower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFollowerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamFollowerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamFollower'> extends True ? CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>> : CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower | null >, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T> | null >>

    /**
     * Find zero or more TeamFollowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamFollowers
     * const teamFollowers = await prisma.teamFollower.findMany()
     * 
     * // Get first 10 TeamFollowers
     * const teamFollowers = await prisma.teamFollower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamFollowerWithIdOnly = await prisma.teamFollower.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFollowerFindManyArgs>(
      args?: SelectSubset<T, TeamFollowerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TeamFollower>>, PrismaPromise<Array<TeamFollowerGetPayload<T>>>>

    /**
     * Create a TeamFollower.
     * @param {TeamFollowerCreateArgs} args - Arguments to create a TeamFollower.
     * @example
     * // Create one TeamFollower
     * const TeamFollower = await prisma.teamFollower.create({
     *   data: {
     *     // ... data to create a TeamFollower
     *   }
     * })
     * 
    **/
    create<T extends TeamFollowerCreateArgs>(
      args: SelectSubset<T, TeamFollowerCreateArgs>
    ): CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>>

    /**
     * Create many TeamFollowers.
     *     @param {TeamFollowerCreateManyArgs} args - Arguments to create many TeamFollowers.
     *     @example
     *     // Create many TeamFollowers
     *     const teamFollower = await prisma.teamFollower.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamFollowerCreateManyArgs>(
      args?: SelectSubset<T, TeamFollowerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeamFollower.
     * @param {TeamFollowerDeleteArgs} args - Arguments to delete one TeamFollower.
     * @example
     * // Delete one TeamFollower
     * const TeamFollower = await prisma.teamFollower.delete({
     *   where: {
     *     // ... filter to delete one TeamFollower
     *   }
     * })
     * 
    **/
    delete<T extends TeamFollowerDeleteArgs>(
      args: SelectSubset<T, TeamFollowerDeleteArgs>
    ): CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>>

    /**
     * Update one TeamFollower.
     * @param {TeamFollowerUpdateArgs} args - Arguments to update one TeamFollower.
     * @example
     * // Update one TeamFollower
     * const teamFollower = await prisma.teamFollower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamFollowerUpdateArgs>(
      args: SelectSubset<T, TeamFollowerUpdateArgs>
    ): CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>>

    /**
     * Delete zero or more TeamFollowers.
     * @param {TeamFollowerDeleteManyArgs} args - Arguments to filter TeamFollowers to delete.
     * @example
     * // Delete a few TeamFollowers
     * const { count } = await prisma.teamFollower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamFollowerDeleteManyArgs>(
      args?: SelectSubset<T, TeamFollowerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamFollowers
     * const teamFollower = await prisma.teamFollower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamFollowerUpdateManyArgs>(
      args: SelectSubset<T, TeamFollowerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamFollower.
     * @param {TeamFollowerUpsertArgs} args - Arguments to update or create a TeamFollower.
     * @example
     * // Update or create a TeamFollower
     * const teamFollower = await prisma.teamFollower.upsert({
     *   create: {
     *     // ... data to create a TeamFollower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamFollower we want to update
     *   }
     * })
    **/
    upsert<T extends TeamFollowerUpsertArgs>(
      args: SelectSubset<T, TeamFollowerUpsertArgs>
    ): CheckSelect<T, Prisma__TeamFollowerClient<TeamFollower>, Prisma__TeamFollowerClient<TeamFollowerGetPayload<T>>>

    /**
     * Count the number of TeamFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerCountArgs} args - Arguments to filter TeamFollowers to count.
     * @example
     * // Count the number of TeamFollowers
     * const count = await prisma.teamFollower.count({
     *   where: {
     *     // ... the filter for the TeamFollowers we want to count
     *   }
     * })
    **/
    count<T extends TeamFollowerCountArgs>(
      args?: Subset<T, TeamFollowerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamFollowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamFollowerAggregateArgs>(args: Subset<T, TeamFollowerAggregateArgs>): PrismaPromise<GetTeamFollowerAggregateType<T>>

    /**
     * Group by TeamFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFollowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamFollowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamFollowerGroupByArgs['orderBy'] }
        : { orderBy?: TeamFollowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamFollowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamFollowerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamFollower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamFollowerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    team<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>;

    user<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TeamFollower findUnique
   */
  export type TeamFollowerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * Throw an Error if a TeamFollower can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamFollower to fetch.
     * 
    **/
    where: TeamFollowerWhereUniqueInput
  }


  /**
   * TeamFollower findFirst
   */
  export type TeamFollowerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * Throw an Error if a TeamFollower can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamFollower to fetch.
     * 
    **/
    where?: TeamFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFollowers to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamFollowerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamFollowers.
     * 
    **/
    cursor?: TeamFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFollowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFollowers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamFollowers.
     * 
    **/
    distinct?: Enumerable<TeamFollowerScalarFieldEnum>
  }


  /**
   * TeamFollower findMany
   */
  export type TeamFollowerFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * Filter, which TeamFollowers to fetch.
     * 
    **/
    where?: TeamFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamFollowers to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamFollowerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamFollowers.
     * 
    **/
    cursor?: TeamFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamFollowers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamFollowers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamFollowerScalarFieldEnum>
  }


  /**
   * TeamFollower create
   */
  export type TeamFollowerCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * The data needed to create a TeamFollower.
     * 
    **/
    data: XOR<TeamFollowerCreateInput, TeamFollowerUncheckedCreateInput>
  }


  /**
   * TeamFollower createMany
   */
  export type TeamFollowerCreateManyArgs = {
    data: Enumerable<TeamFollowerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamFollower update
   */
  export type TeamFollowerUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * The data needed to update a TeamFollower.
     * 
    **/
    data: XOR<TeamFollowerUpdateInput, TeamFollowerUncheckedUpdateInput>
    /**
     * Choose, which TeamFollower to update.
     * 
    **/
    where: TeamFollowerWhereUniqueInput
  }


  /**
   * TeamFollower updateMany
   */
  export type TeamFollowerUpdateManyArgs = {
    data: XOR<TeamFollowerUpdateManyMutationInput, TeamFollowerUncheckedUpdateManyInput>
    where?: TeamFollowerWhereInput
  }


  /**
   * TeamFollower upsert
   */
  export type TeamFollowerUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * The filter to search for the TeamFollower to update in case it exists.
     * 
    **/
    where: TeamFollowerWhereUniqueInput
    /**
     * In case the TeamFollower found by the `where` argument doesn't exist, create a new TeamFollower with this data.
     * 
    **/
    create: XOR<TeamFollowerCreateInput, TeamFollowerUncheckedCreateInput>
    /**
     * In case the TeamFollower was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamFollowerUpdateInput, TeamFollowerUncheckedUpdateInput>
  }


  /**
   * TeamFollower delete
   */
  export type TeamFollowerDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
    /**
     * Filter which TeamFollower to delete.
     * 
    **/
    where: TeamFollowerWhereUniqueInput
  }


  /**
   * TeamFollower deleteMany
   */
  export type TeamFollowerDeleteManyArgs = {
    where?: TeamFollowerWhereInput
  }


  /**
   * TeamFollower without action
   */
  export type TeamFollowerArgs = {
    /**
     * Select specific fields to fetch from the TeamFollower
     * 
    **/
    select?: TeamFollowerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamFollowerInclude | null
  }



  /**
   * Model Tpost
   */


  export type AggregateTpost = {
    _count: TpostCountAggregateOutputType | null
    count: TpostCountAggregateOutputType | null
    _avg: TpostAvgAggregateOutputType | null
    avg: TpostAvgAggregateOutputType | null
    _sum: TpostSumAggregateOutputType | null
    sum: TpostSumAggregateOutputType | null
    _min: TpostMinAggregateOutputType | null
    min: TpostMinAggregateOutputType | null
    _max: TpostMaxAggregateOutputType | null
    max: TpostMaxAggregateOutputType | null
  }

  export type TpostAvgAggregateOutputType = {
    number: number | null
  }

  export type TpostSumAggregateOutputType = {
    number: number | null
  }

  export type TpostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    number: number | null
    teamId: string | null
    userId: string | null
  }

  export type TpostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    number: number | null
    teamId: string | null
    userId: string | null
  }

  export type TpostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    number: number
    teamId: number
    userId: number
    _all: number
  }


  export type TpostAvgAggregateInputType = {
    number?: true
  }

  export type TpostSumAggregateInputType = {
    number?: true
  }

  export type TpostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    number?: true
    teamId?: true
    userId?: true
  }

  export type TpostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    number?: true
    teamId?: true
    userId?: true
  }

  export type TpostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    number?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type TpostAggregateArgs = {
    /**
     * Filter which Tpost to aggregate.
     * 
    **/
    where?: TpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tposts to fetch.
     * 
    **/
    orderBy?: Enumerable<TpostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tposts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tposts
    **/
    _count?: true | TpostCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TpostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TpostAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TpostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TpostSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TpostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TpostMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TpostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TpostMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TpostMaxAggregateInputType
  }

  export type GetTpostAggregateType<T extends TpostAggregateArgs> = {
        [P in keyof T & keyof AggregateTpost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTpost[P]>
      : GetScalarType<T[P], AggregateTpost[P]>
  }


    
    
  export type TpostGroupByArgs = {
    where?: TpostWhereInput
    orderBy?: Enumerable<TpostOrderByInput>
    by: Array<TpostScalarFieldEnum>
    having?: TpostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TpostCountAggregateInputType | true
    _avg?: TpostAvgAggregateInputType
    _sum?: TpostSumAggregateInputType
    _min?: TpostMinAggregateInputType
    _max?: TpostMaxAggregateInputType
  }


  export type TpostGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    content: string
    number: number
    teamId: string
    userId: string
    _count: TpostCountAggregateOutputType | null
    _avg: TpostAvgAggregateOutputType | null
    _sum: TpostSumAggregateOutputType | null
    _min: TpostMinAggregateOutputType | null
    _max: TpostMaxAggregateOutputType | null
  }

  type GetTpostGroupByPayload<T extends TpostGroupByArgs> = Promise<
    Array<
      PickArray<TpostGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TpostGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TpostGroupByOutputType[P]> 
            : GetScalarType<T[P], TpostGroupByOutputType[P]>
        }
      > 
    >


  export type TpostSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    number?: boolean
    treplys?: boolean | TreplyFindManyArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    teamId?: boolean
    userId?: boolean
  }

  export type TpostInclude = {
    treplys?: boolean | TreplyFindManyArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
  }

  export type TpostGetPayload<
    S extends boolean | null | undefined | TpostArgs,
    U = keyof S
      > = S extends true
        ? Tpost
    : S extends undefined
    ? never
    : S extends TpostArgs | TpostFindManyArgs
    ?'include' extends U
    ? Tpost  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'treplys'
        ? Array < TreplyGetPayload<S['include'][P]>>  :
        P extends 'teamRef'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tpost ?Tpost [P]
  : 
          P extends 'treplys'
        ? Array < TreplyGetPayload<S['select'][P]>>  :
        P extends 'teamRef'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Tpost
  : Tpost


  type TpostCountArgs = Merge<
    Omit<TpostFindManyArgs, 'select' | 'include'> & {
      select?: TpostCountAggregateInputType | true
    }
  >

  export interface TpostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tpost that matches the filter.
     * @param {TpostFindUniqueArgs} args - Arguments to find a Tpost
     * @example
     * // Get one Tpost
     * const tpost = await prisma.tpost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TpostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TpostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tpost'> extends True ? CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>> : CheckSelect<T, Prisma__TpostClient<Tpost | null >, Prisma__TpostClient<TpostGetPayload<T> | null >>

    /**
     * Find the first Tpost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostFindFirstArgs} args - Arguments to find a Tpost
     * @example
     * // Get one Tpost
     * const tpost = await prisma.tpost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TpostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TpostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tpost'> extends True ? CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>> : CheckSelect<T, Prisma__TpostClient<Tpost | null >, Prisma__TpostClient<TpostGetPayload<T> | null >>

    /**
     * Find zero or more Tposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tposts
     * const tposts = await prisma.tpost.findMany()
     * 
     * // Get first 10 Tposts
     * const tposts = await prisma.tpost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tpostWithIdOnly = await prisma.tpost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TpostFindManyArgs>(
      args?: SelectSubset<T, TpostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tpost>>, PrismaPromise<Array<TpostGetPayload<T>>>>

    /**
     * Create a Tpost.
     * @param {TpostCreateArgs} args - Arguments to create a Tpost.
     * @example
     * // Create one Tpost
     * const Tpost = await prisma.tpost.create({
     *   data: {
     *     // ... data to create a Tpost
     *   }
     * })
     * 
    **/
    create<T extends TpostCreateArgs>(
      args: SelectSubset<T, TpostCreateArgs>
    ): CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>>

    /**
     * Create many Tposts.
     *     @param {TpostCreateManyArgs} args - Arguments to create many Tposts.
     *     @example
     *     // Create many Tposts
     *     const tpost = await prisma.tpost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TpostCreateManyArgs>(
      args?: SelectSubset<T, TpostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tpost.
     * @param {TpostDeleteArgs} args - Arguments to delete one Tpost.
     * @example
     * // Delete one Tpost
     * const Tpost = await prisma.tpost.delete({
     *   where: {
     *     // ... filter to delete one Tpost
     *   }
     * })
     * 
    **/
    delete<T extends TpostDeleteArgs>(
      args: SelectSubset<T, TpostDeleteArgs>
    ): CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>>

    /**
     * Update one Tpost.
     * @param {TpostUpdateArgs} args - Arguments to update one Tpost.
     * @example
     * // Update one Tpost
     * const tpost = await prisma.tpost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TpostUpdateArgs>(
      args: SelectSubset<T, TpostUpdateArgs>
    ): CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>>

    /**
     * Delete zero or more Tposts.
     * @param {TpostDeleteManyArgs} args - Arguments to filter Tposts to delete.
     * @example
     * // Delete a few Tposts
     * const { count } = await prisma.tpost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TpostDeleteManyArgs>(
      args?: SelectSubset<T, TpostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tposts
     * const tpost = await prisma.tpost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TpostUpdateManyArgs>(
      args: SelectSubset<T, TpostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tpost.
     * @param {TpostUpsertArgs} args - Arguments to update or create a Tpost.
     * @example
     * // Update or create a Tpost
     * const tpost = await prisma.tpost.upsert({
     *   create: {
     *     // ... data to create a Tpost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tpost we want to update
     *   }
     * })
    **/
    upsert<T extends TpostUpsertArgs>(
      args: SelectSubset<T, TpostUpsertArgs>
    ): CheckSelect<T, Prisma__TpostClient<Tpost>, Prisma__TpostClient<TpostGetPayload<T>>>

    /**
     * Count the number of Tposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostCountArgs} args - Arguments to filter Tposts to count.
     * @example
     * // Count the number of Tposts
     * const count = await prisma.tpost.count({
     *   where: {
     *     // ... the filter for the Tposts we want to count
     *   }
     * })
    **/
    count<T extends TpostCountArgs>(
      args?: Subset<T, TpostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TpostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tpost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TpostAggregateArgs>(args: Subset<T, TpostAggregateArgs>): PrismaPromise<GetTpostAggregateType<T>>

    /**
     * Group by Tpost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TpostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TpostGroupByArgs['orderBy'] }
        : { orderBy?: TpostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TpostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTpostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tpost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TpostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    treplys<T extends TreplyFindManyArgs = {}>(args?: Subset<T, TreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Treply>>, PrismaPromise<Array<TreplyGetPayload<T>>>>;

    teamRef<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tpost findUnique
   */
  export type TpostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * Throw an Error if a Tpost can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tpost to fetch.
     * 
    **/
    where: TpostWhereUniqueInput
  }


  /**
   * Tpost findFirst
   */
  export type TpostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * Throw an Error if a Tpost can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tpost to fetch.
     * 
    **/
    where?: TpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tposts to fetch.
     * 
    **/
    orderBy?: Enumerable<TpostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tposts.
     * 
    **/
    cursor?: TpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tposts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tposts.
     * 
    **/
    distinct?: Enumerable<TpostScalarFieldEnum>
  }


  /**
   * Tpost findMany
   */
  export type TpostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * Filter, which Tposts to fetch.
     * 
    **/
    where?: TpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tposts to fetch.
     * 
    **/
    orderBy?: Enumerable<TpostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tposts.
     * 
    **/
    cursor?: TpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tposts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tposts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TpostScalarFieldEnum>
  }


  /**
   * Tpost create
   */
  export type TpostCreateArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * The data needed to create a Tpost.
     * 
    **/
    data: XOR<TpostCreateInput, TpostUncheckedCreateInput>
  }


  /**
   * Tpost createMany
   */
  export type TpostCreateManyArgs = {
    data: Enumerable<TpostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tpost update
   */
  export type TpostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * The data needed to update a Tpost.
     * 
    **/
    data: XOR<TpostUpdateInput, TpostUncheckedUpdateInput>
    /**
     * Choose, which Tpost to update.
     * 
    **/
    where: TpostWhereUniqueInput
  }


  /**
   * Tpost updateMany
   */
  export type TpostUpdateManyArgs = {
    data: XOR<TpostUpdateManyMutationInput, TpostUncheckedUpdateManyInput>
    where?: TpostWhereInput
  }


  /**
   * Tpost upsert
   */
  export type TpostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * The filter to search for the Tpost to update in case it exists.
     * 
    **/
    where: TpostWhereUniqueInput
    /**
     * In case the Tpost found by the `where` argument doesn't exist, create a new Tpost with this data.
     * 
    **/
    create: XOR<TpostCreateInput, TpostUncheckedCreateInput>
    /**
     * In case the Tpost was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TpostUpdateInput, TpostUncheckedUpdateInput>
  }


  /**
   * Tpost delete
   */
  export type TpostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
    /**
     * Filter which Tpost to delete.
     * 
    **/
    where: TpostWhereUniqueInput
  }


  /**
   * Tpost deleteMany
   */
  export type TpostDeleteManyArgs = {
    where?: TpostWhereInput
  }


  /**
   * Tpost without action
   */
  export type TpostArgs = {
    /**
     * Select specific fields to fetch from the Tpost
     * 
    **/
    select?: TpostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TpostInclude | null
  }



  /**
   * Model Tevent
   */


  export type AggregateTevent = {
    _count: TeventCountAggregateOutputType | null
    count: TeventCountAggregateOutputType | null
    _avg: TeventAvgAggregateOutputType | null
    avg: TeventAvgAggregateOutputType | null
    _sum: TeventSumAggregateOutputType | null
    sum: TeventSumAggregateOutputType | null
    _min: TeventMinAggregateOutputType | null
    min: TeventMinAggregateOutputType | null
    _max: TeventMaxAggregateOutputType | null
    max: TeventMaxAggregateOutputType | null
  }

  export type TeventAvgAggregateOutputType = {
    maxParticipants: number | null
    eventLat: number | null
    eventLon: number | null
  }

  export type TeventSumAggregateOutputType = {
    maxParticipants: number | null
    eventLat: number | null
    eventLon: number | null
  }

  export type TeventMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    startAt: Date | null
    endsAt: Date | null
    content: string | null
    maxParticipants: number | null
    teamId: string | null
    userId: string | null
    eventLat: number | null
    eventLon: number | null
    locationDescription: string | null
    visioPres: boolean | null
    linkVisio: string | null
    visioCode: string | null
    infoPostscritum: string | null
    isCancel: boolean | null
    visible: boolean | null
    postScriptWriterId: string | null
    recallEmailSent: boolean | null
  }

  export type TeventMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subject: string | null
    startAt: Date | null
    endsAt: Date | null
    content: string | null
    maxParticipants: number | null
    teamId: string | null
    userId: string | null
    eventLat: number | null
    eventLon: number | null
    locationDescription: string | null
    visioPres: boolean | null
    linkVisio: string | null
    visioCode: string | null
    infoPostscritum: string | null
    isCancel: boolean | null
    visible: boolean | null
    postScriptWriterId: string | null
    recallEmailSent: boolean | null
  }

  export type TeventCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    subject: number
    startAt: number
    endsAt: number
    content: number
    maxParticipants: number
    teamId: number
    userId: number
    eventLat: number
    eventLon: number
    locationDescription: number
    visioPres: number
    linkVisio: number
    visioCode: number
    infoPostscritum: number
    isCancel: number
    visible: number
    postScriptWriterId: number
    recallEmailSent: number
    _all: number
  }


  export type TeventAvgAggregateInputType = {
    maxParticipants?: true
    eventLat?: true
    eventLon?: true
  }

  export type TeventSumAggregateInputType = {
    maxParticipants?: true
    eventLat?: true
    eventLon?: true
  }

  export type TeventMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    startAt?: true
    endsAt?: true
    content?: true
    maxParticipants?: true
    teamId?: true
    userId?: true
    eventLat?: true
    eventLon?: true
    locationDescription?: true
    visioPres?: true
    linkVisio?: true
    visioCode?: true
    infoPostscritum?: true
    isCancel?: true
    visible?: true
    postScriptWriterId?: true
    recallEmailSent?: true
  }

  export type TeventMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    startAt?: true
    endsAt?: true
    content?: true
    maxParticipants?: true
    teamId?: true
    userId?: true
    eventLat?: true
    eventLon?: true
    locationDescription?: true
    visioPres?: true
    linkVisio?: true
    visioCode?: true
    infoPostscritum?: true
    isCancel?: true
    visible?: true
    postScriptWriterId?: true
    recallEmailSent?: true
  }

  export type TeventCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    subject?: true
    startAt?: true
    endsAt?: true
    content?: true
    maxParticipants?: true
    teamId?: true
    userId?: true
    eventLat?: true
    eventLon?: true
    locationDescription?: true
    visioPres?: true
    linkVisio?: true
    visioCode?: true
    infoPostscritum?: true
    isCancel?: true
    visible?: true
    postScriptWriterId?: true
    recallEmailSent?: true
    _all?: true
  }

  export type TeventAggregateArgs = {
    /**
     * Filter which Tevent to aggregate.
     * 
    **/
    where?: TeventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tevents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tevents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tevents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tevents
    **/
    _count?: true | TeventCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TeventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeventAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TeventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeventSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TeventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeventMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TeventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeventMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TeventMaxAggregateInputType
  }

  export type GetTeventAggregateType<T extends TeventAggregateArgs> = {
        [P in keyof T & keyof AggregateTevent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTevent[P]>
      : GetScalarType<T[P], AggregateTevent[P]>
  }


    
    
  export type TeventGroupByArgs = {
    where?: TeventWhereInput
    orderBy?: Enumerable<TeventOrderByInput>
    by: Array<TeventScalarFieldEnum>
    having?: TeventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeventCountAggregateInputType | true
    _avg?: TeventAvgAggregateInputType
    _sum?: TeventSumAggregateInputType
    _min?: TeventMinAggregateInputType
    _max?: TeventMaxAggregateInputType
  }


  export type TeventGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    subject: string
    startAt: Date
    endsAt: Date
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription: string | null
    visioPres: boolean
    linkVisio: string | null
    visioCode: string | null
    infoPostscritum: string | null
    isCancel: boolean
    visible: boolean
    postScriptWriterId: string | null
    recallEmailSent: boolean
    _count: TeventCountAggregateOutputType | null
    _avg: TeventAvgAggregateOutputType | null
    _sum: TeventSumAggregateOutputType | null
    _min: TeventMinAggregateOutputType | null
    _max: TeventMaxAggregateOutputType | null
  }

  type GetTeventGroupByPayload<T extends TeventGroupByArgs> = Promise<
    Array<
      PickArray<TeventGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TeventGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TeventGroupByOutputType[P]> 
            : GetScalarType<T[P], TeventGroupByOutputType[P]>
        }
      > 
    >


  export type TeventSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean
    startAt?: boolean
    endsAt?: boolean
    content?: boolean
    maxParticipants?: boolean
    ereplys?: boolean | EreplyFindManyArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    teamId?: boolean
    userId?: boolean
    invitedUsers?: boolean | UserFindManyArgs
    eventLat?: boolean
    eventLon?: boolean
    locationDescription?: boolean
    visioPres?: boolean
    linkVisio?: boolean
    visioCode?: boolean
    infoPostscritum?: boolean
    isCancel?: boolean
    usersParticipeEvent?: boolean | UserParticipeEventFindManyArgs
    visible?: boolean
    postScriptWriterId?: boolean
    recallEmailSent?: boolean
  }

  export type TeventInclude = {
    ereplys?: boolean | EreplyFindManyArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    invitedUsers?: boolean | UserFindManyArgs
    usersParticipeEvent?: boolean | UserParticipeEventFindManyArgs
  }

  export type TeventGetPayload<
    S extends boolean | null | undefined | TeventArgs,
    U = keyof S
      > = S extends true
        ? Tevent
    : S extends undefined
    ? never
    : S extends TeventArgs | TeventFindManyArgs
    ?'include' extends U
    ? Tevent  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ereplys'
        ? Array < EreplyGetPayload<S['include'][P]>>  :
        P extends 'teamRef'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'invitedUsers'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'usersParticipeEvent'
        ? Array < UserParticipeEventGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tevent ?Tevent [P]
  : 
          P extends 'ereplys'
        ? Array < EreplyGetPayload<S['select'][P]>>  :
        P extends 'teamRef'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'invitedUsers'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'usersParticipeEvent'
        ? Array < UserParticipeEventGetPayload<S['select'][P]>>  : never
  } 
    : Tevent
  : Tevent


  type TeventCountArgs = Merge<
    Omit<TeventFindManyArgs, 'select' | 'include'> & {
      select?: TeventCountAggregateInputType | true
    }
  >

  export interface TeventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tevent that matches the filter.
     * @param {TeventFindUniqueArgs} args - Arguments to find a Tevent
     * @example
     * // Get one Tevent
     * const tevent = await prisma.tevent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tevent'> extends True ? CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>> : CheckSelect<T, Prisma__TeventClient<Tevent | null >, Prisma__TeventClient<TeventGetPayload<T> | null >>

    /**
     * Find the first Tevent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventFindFirstArgs} args - Arguments to find a Tevent
     * @example
     * // Get one Tevent
     * const tevent = await prisma.tevent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tevent'> extends True ? CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>> : CheckSelect<T, Prisma__TeventClient<Tevent | null >, Prisma__TeventClient<TeventGetPayload<T> | null >>

    /**
     * Find zero or more Tevents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tevents
     * const tevents = await prisma.tevent.findMany()
     * 
     * // Get first 10 Tevents
     * const tevents = await prisma.tevent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teventWithIdOnly = await prisma.tevent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeventFindManyArgs>(
      args?: SelectSubset<T, TeventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tevent>>, PrismaPromise<Array<TeventGetPayload<T>>>>

    /**
     * Create a Tevent.
     * @param {TeventCreateArgs} args - Arguments to create a Tevent.
     * @example
     * // Create one Tevent
     * const Tevent = await prisma.tevent.create({
     *   data: {
     *     // ... data to create a Tevent
     *   }
     * })
     * 
    **/
    create<T extends TeventCreateArgs>(
      args: SelectSubset<T, TeventCreateArgs>
    ): CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>>

    /**
     * Create many Tevents.
     *     @param {TeventCreateManyArgs} args - Arguments to create many Tevents.
     *     @example
     *     // Create many Tevents
     *     const tevent = await prisma.tevent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeventCreateManyArgs>(
      args?: SelectSubset<T, TeventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tevent.
     * @param {TeventDeleteArgs} args - Arguments to delete one Tevent.
     * @example
     * // Delete one Tevent
     * const Tevent = await prisma.tevent.delete({
     *   where: {
     *     // ... filter to delete one Tevent
     *   }
     * })
     * 
    **/
    delete<T extends TeventDeleteArgs>(
      args: SelectSubset<T, TeventDeleteArgs>
    ): CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>>

    /**
     * Update one Tevent.
     * @param {TeventUpdateArgs} args - Arguments to update one Tevent.
     * @example
     * // Update one Tevent
     * const tevent = await prisma.tevent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeventUpdateArgs>(
      args: SelectSubset<T, TeventUpdateArgs>
    ): CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>>

    /**
     * Delete zero or more Tevents.
     * @param {TeventDeleteManyArgs} args - Arguments to filter Tevents to delete.
     * @example
     * // Delete a few Tevents
     * const { count } = await prisma.tevent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeventDeleteManyArgs>(
      args?: SelectSubset<T, TeventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tevents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tevents
     * const tevent = await prisma.tevent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeventUpdateManyArgs>(
      args: SelectSubset<T, TeventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tevent.
     * @param {TeventUpsertArgs} args - Arguments to update or create a Tevent.
     * @example
     * // Update or create a Tevent
     * const tevent = await prisma.tevent.upsert({
     *   create: {
     *     // ... data to create a Tevent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tevent we want to update
     *   }
     * })
    **/
    upsert<T extends TeventUpsertArgs>(
      args: SelectSubset<T, TeventUpsertArgs>
    ): CheckSelect<T, Prisma__TeventClient<Tevent>, Prisma__TeventClient<TeventGetPayload<T>>>

    /**
     * Count the number of Tevents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventCountArgs} args - Arguments to filter Tevents to count.
     * @example
     * // Count the number of Tevents
     * const count = await prisma.tevent.count({
     *   where: {
     *     // ... the filter for the Tevents we want to count
     *   }
     * })
    **/
    count<T extends TeventCountArgs>(
      args?: Subset<T, TeventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tevent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeventAggregateArgs>(args: Subset<T, TeventAggregateArgs>): PrismaPromise<GetTeventAggregateType<T>>

    /**
     * Group by Tevent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeventGroupByArgs['orderBy'] }
        : { orderBy?: TeventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeventGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tevent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ereplys<T extends EreplyFindManyArgs = {}>(args?: Subset<T, EreplyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ereply>>, PrismaPromise<Array<EreplyGetPayload<T>>>>;

    teamRef<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    invitedUsers<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    usersParticipeEvent<T extends UserParticipeEventFindManyArgs = {}>(args?: Subset<T, UserParticipeEventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserParticipeEvent>>, PrismaPromise<Array<UserParticipeEventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tevent findUnique
   */
  export type TeventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * Throw an Error if a Tevent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tevent to fetch.
     * 
    **/
    where: TeventWhereUniqueInput
  }


  /**
   * Tevent findFirst
   */
  export type TeventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * Throw an Error if a Tevent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tevent to fetch.
     * 
    **/
    where?: TeventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tevents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tevents.
     * 
    **/
    cursor?: TeventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tevents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tevents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tevents.
     * 
    **/
    distinct?: Enumerable<TeventScalarFieldEnum>
  }


  /**
   * Tevent findMany
   */
  export type TeventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * Filter, which Tevents to fetch.
     * 
    **/
    where?: TeventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tevents to fetch.
     * 
    **/
    orderBy?: Enumerable<TeventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tevents.
     * 
    **/
    cursor?: TeventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tevents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tevents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeventScalarFieldEnum>
  }


  /**
   * Tevent create
   */
  export type TeventCreateArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * The data needed to create a Tevent.
     * 
    **/
    data: XOR<TeventCreateInput, TeventUncheckedCreateInput>
  }


  /**
   * Tevent createMany
   */
  export type TeventCreateManyArgs = {
    data: Enumerable<TeventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tevent update
   */
  export type TeventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * The data needed to update a Tevent.
     * 
    **/
    data: XOR<TeventUpdateInput, TeventUncheckedUpdateInput>
    /**
     * Choose, which Tevent to update.
     * 
    **/
    where: TeventWhereUniqueInput
  }


  /**
   * Tevent updateMany
   */
  export type TeventUpdateManyArgs = {
    data: XOR<TeventUpdateManyMutationInput, TeventUncheckedUpdateManyInput>
    where?: TeventWhereInput
  }


  /**
   * Tevent upsert
   */
  export type TeventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * The filter to search for the Tevent to update in case it exists.
     * 
    **/
    where: TeventWhereUniqueInput
    /**
     * In case the Tevent found by the `where` argument doesn't exist, create a new Tevent with this data.
     * 
    **/
    create: XOR<TeventCreateInput, TeventUncheckedCreateInput>
    /**
     * In case the Tevent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeventUpdateInput, TeventUncheckedUpdateInput>
  }


  /**
   * Tevent delete
   */
  export type TeventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
    /**
     * Filter which Tevent to delete.
     * 
    **/
    where: TeventWhereUniqueInput
  }


  /**
   * Tevent deleteMany
   */
  export type TeventDeleteManyArgs = {
    where?: TeventWhereInput
  }


  /**
   * Tevent without action
   */
  export type TeventArgs = {
    /**
     * Select specific fields to fetch from the Tevent
     * 
    **/
    select?: TeventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeventInclude | null
  }



  /**
   * Model UserParticipeEvent
   */


  export type AggregateUserParticipeEvent = {
    _count: UserParticipeEventCountAggregateOutputType | null
    count: UserParticipeEventCountAggregateOutputType | null
    _min: UserParticipeEventMinAggregateOutputType | null
    min: UserParticipeEventMinAggregateOutputType | null
    _max: UserParticipeEventMaxAggregateOutputType | null
    max: UserParticipeEventMaxAggregateOutputType | null
  }

  export type UserParticipeEventMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teventId: string | null
    participantId: string | null
  }

  export type UserParticipeEventMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teventId: string | null
    participantId: string | null
  }

  export type UserParticipeEventCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    teventId: number
    participantId: number
    _all: number
  }


  export type UserParticipeEventMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teventId?: true
    participantId?: true
  }

  export type UserParticipeEventMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teventId?: true
    participantId?: true
  }

  export type UserParticipeEventCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teventId?: true
    participantId?: true
    _all?: true
  }

  export type UserParticipeEventAggregateArgs = {
    /**
     * Filter which UserParticipeEvent to aggregate.
     * 
    **/
    where?: UserParticipeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParticipeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<UserParticipeEventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserParticipeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParticipeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParticipeEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserParticipeEvents
    **/
    _count?: true | UserParticipeEventCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserParticipeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserParticipeEventMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserParticipeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserParticipeEventMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserParticipeEventMaxAggregateInputType
  }

  export type GetUserParticipeEventAggregateType<T extends UserParticipeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateUserParticipeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserParticipeEvent[P]>
      : GetScalarType<T[P], AggregateUserParticipeEvent[P]>
  }


    
    
  export type UserParticipeEventGroupByArgs = {
    where?: UserParticipeEventWhereInput
    orderBy?: Enumerable<UserParticipeEventOrderByInput>
    by: Array<UserParticipeEventScalarFieldEnum>
    having?: UserParticipeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserParticipeEventCountAggregateInputType | true
    _min?: UserParticipeEventMinAggregateInputType
    _max?: UserParticipeEventMaxAggregateInputType
  }


  export type UserParticipeEventGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    teventId: string
    participantId: string
    _count: UserParticipeEventCountAggregateOutputType | null
    _min: UserParticipeEventMinAggregateOutputType | null
    _max: UserParticipeEventMaxAggregateOutputType | null
  }

  type GetUserParticipeEventGroupByPayload<T extends UserParticipeEventGroupByArgs> = Promise<
    Array<
      PickArray<UserParticipeEventGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserParticipeEventGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserParticipeEventGroupByOutputType[P]> 
            : GetScalarType<T[P], UserParticipeEventGroupByOutputType[P]>
        }
      > 
    >


  export type UserParticipeEventSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tevent?: boolean | TeventFindManyArgs
    teventId?: boolean
    user?: boolean | UserFindManyArgs
    participantId?: boolean
  }

  export type UserParticipeEventInclude = {
    tevent?: boolean | TeventFindManyArgs
    user?: boolean | UserFindManyArgs
  }

  export type UserParticipeEventGetPayload<
    S extends boolean | null | undefined | UserParticipeEventArgs,
    U = keyof S
      > = S extends true
        ? UserParticipeEvent
    : S extends undefined
    ? never
    : S extends UserParticipeEventArgs | UserParticipeEventFindManyArgs
    ?'include' extends U
    ? UserParticipeEvent  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tevent'
        ? Array < TeventGetPayload<S['include'][P]>>  :
        P extends 'user'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserParticipeEvent ?UserParticipeEvent [P]
  : 
          P extends 'tevent'
        ? Array < TeventGetPayload<S['select'][P]>>  :
        P extends 'user'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : UserParticipeEvent
  : UserParticipeEvent


  type UserParticipeEventCountArgs = Merge<
    Omit<UserParticipeEventFindManyArgs, 'select' | 'include'> & {
      select?: UserParticipeEventCountAggregateInputType | true
    }
  >

  export interface UserParticipeEventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserParticipeEvent that matches the filter.
     * @param {UserParticipeEventFindUniqueArgs} args - Arguments to find a UserParticipeEvent
     * @example
     * // Get one UserParticipeEvent
     * const userParticipeEvent = await prisma.userParticipeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserParticipeEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserParticipeEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserParticipeEvent'> extends True ? CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>> : CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent | null >, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T> | null >>

    /**
     * Find the first UserParticipeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventFindFirstArgs} args - Arguments to find a UserParticipeEvent
     * @example
     * // Get one UserParticipeEvent
     * const userParticipeEvent = await prisma.userParticipeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserParticipeEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserParticipeEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserParticipeEvent'> extends True ? CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>> : CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent | null >, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T> | null >>

    /**
     * Find zero or more UserParticipeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserParticipeEvents
     * const userParticipeEvents = await prisma.userParticipeEvent.findMany()
     * 
     * // Get first 10 UserParticipeEvents
     * const userParticipeEvents = await prisma.userParticipeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userParticipeEventWithIdOnly = await prisma.userParticipeEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserParticipeEventFindManyArgs>(
      args?: SelectSubset<T, UserParticipeEventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserParticipeEvent>>, PrismaPromise<Array<UserParticipeEventGetPayload<T>>>>

    /**
     * Create a UserParticipeEvent.
     * @param {UserParticipeEventCreateArgs} args - Arguments to create a UserParticipeEvent.
     * @example
     * // Create one UserParticipeEvent
     * const UserParticipeEvent = await prisma.userParticipeEvent.create({
     *   data: {
     *     // ... data to create a UserParticipeEvent
     *   }
     * })
     * 
    **/
    create<T extends UserParticipeEventCreateArgs>(
      args: SelectSubset<T, UserParticipeEventCreateArgs>
    ): CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>>

    /**
     * Create many UserParticipeEvents.
     *     @param {UserParticipeEventCreateManyArgs} args - Arguments to create many UserParticipeEvents.
     *     @example
     *     // Create many UserParticipeEvents
     *     const userParticipeEvent = await prisma.userParticipeEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserParticipeEventCreateManyArgs>(
      args?: SelectSubset<T, UserParticipeEventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserParticipeEvent.
     * @param {UserParticipeEventDeleteArgs} args - Arguments to delete one UserParticipeEvent.
     * @example
     * // Delete one UserParticipeEvent
     * const UserParticipeEvent = await prisma.userParticipeEvent.delete({
     *   where: {
     *     // ... filter to delete one UserParticipeEvent
     *   }
     * })
     * 
    **/
    delete<T extends UserParticipeEventDeleteArgs>(
      args: SelectSubset<T, UserParticipeEventDeleteArgs>
    ): CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>>

    /**
     * Update one UserParticipeEvent.
     * @param {UserParticipeEventUpdateArgs} args - Arguments to update one UserParticipeEvent.
     * @example
     * // Update one UserParticipeEvent
     * const userParticipeEvent = await prisma.userParticipeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserParticipeEventUpdateArgs>(
      args: SelectSubset<T, UserParticipeEventUpdateArgs>
    ): CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>>

    /**
     * Delete zero or more UserParticipeEvents.
     * @param {UserParticipeEventDeleteManyArgs} args - Arguments to filter UserParticipeEvents to delete.
     * @example
     * // Delete a few UserParticipeEvents
     * const { count } = await prisma.userParticipeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserParticipeEventDeleteManyArgs>(
      args?: SelectSubset<T, UserParticipeEventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserParticipeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserParticipeEvents
     * const userParticipeEvent = await prisma.userParticipeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserParticipeEventUpdateManyArgs>(
      args: SelectSubset<T, UserParticipeEventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserParticipeEvent.
     * @param {UserParticipeEventUpsertArgs} args - Arguments to update or create a UserParticipeEvent.
     * @example
     * // Update or create a UserParticipeEvent
     * const userParticipeEvent = await prisma.userParticipeEvent.upsert({
     *   create: {
     *     // ... data to create a UserParticipeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserParticipeEvent we want to update
     *   }
     * })
    **/
    upsert<T extends UserParticipeEventUpsertArgs>(
      args: SelectSubset<T, UserParticipeEventUpsertArgs>
    ): CheckSelect<T, Prisma__UserParticipeEventClient<UserParticipeEvent>, Prisma__UserParticipeEventClient<UserParticipeEventGetPayload<T>>>

    /**
     * Count the number of UserParticipeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventCountArgs} args - Arguments to filter UserParticipeEvents to count.
     * @example
     * // Count the number of UserParticipeEvents
     * const count = await prisma.userParticipeEvent.count({
     *   where: {
     *     // ... the filter for the UserParticipeEvents we want to count
     *   }
     * })
    **/
    count<T extends UserParticipeEventCountArgs>(
      args?: Subset<T, UserParticipeEventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserParticipeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserParticipeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserParticipeEventAggregateArgs>(args: Subset<T, UserParticipeEventAggregateArgs>): PrismaPromise<GetUserParticipeEventAggregateType<T>>

    /**
     * Group by UserParticipeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParticipeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserParticipeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserParticipeEventGroupByArgs['orderBy'] }
        : { orderBy?: UserParticipeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserParticipeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserParticipeEventGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserParticipeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserParticipeEventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tevent<T extends TeventFindManyArgs = {}>(args?: Subset<T, TeventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tevent>>, PrismaPromise<Array<TeventGetPayload<T>>>>;

    user<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserParticipeEvent findUnique
   */
  export type UserParticipeEventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * Throw an Error if a UserParticipeEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserParticipeEvent to fetch.
     * 
    **/
    where: UserParticipeEventWhereUniqueInput
  }


  /**
   * UserParticipeEvent findFirst
   */
  export type UserParticipeEventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * Throw an Error if a UserParticipeEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserParticipeEvent to fetch.
     * 
    **/
    where?: UserParticipeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParticipeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<UserParticipeEventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserParticipeEvents.
     * 
    **/
    cursor?: UserParticipeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParticipeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParticipeEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserParticipeEvents.
     * 
    **/
    distinct?: Enumerable<UserParticipeEventScalarFieldEnum>
  }


  /**
   * UserParticipeEvent findMany
   */
  export type UserParticipeEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * Filter, which UserParticipeEvents to fetch.
     * 
    **/
    where?: UserParticipeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParticipeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<UserParticipeEventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserParticipeEvents.
     * 
    **/
    cursor?: UserParticipeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParticipeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParticipeEvents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserParticipeEventScalarFieldEnum>
  }


  /**
   * UserParticipeEvent create
   */
  export type UserParticipeEventCreateArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * The data needed to create a UserParticipeEvent.
     * 
    **/
    data: XOR<UserParticipeEventCreateInput, UserParticipeEventUncheckedCreateInput>
  }


  /**
   * UserParticipeEvent createMany
   */
  export type UserParticipeEventCreateManyArgs = {
    data: Enumerable<UserParticipeEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserParticipeEvent update
   */
  export type UserParticipeEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * The data needed to update a UserParticipeEvent.
     * 
    **/
    data: XOR<UserParticipeEventUpdateInput, UserParticipeEventUncheckedUpdateInput>
    /**
     * Choose, which UserParticipeEvent to update.
     * 
    **/
    where: UserParticipeEventWhereUniqueInput
  }


  /**
   * UserParticipeEvent updateMany
   */
  export type UserParticipeEventUpdateManyArgs = {
    data: XOR<UserParticipeEventUpdateManyMutationInput, UserParticipeEventUncheckedUpdateManyInput>
    where?: UserParticipeEventWhereInput
  }


  /**
   * UserParticipeEvent upsert
   */
  export type UserParticipeEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * The filter to search for the UserParticipeEvent to update in case it exists.
     * 
    **/
    where: UserParticipeEventWhereUniqueInput
    /**
     * In case the UserParticipeEvent found by the `where` argument doesn't exist, create a new UserParticipeEvent with this data.
     * 
    **/
    create: XOR<UserParticipeEventCreateInput, UserParticipeEventUncheckedCreateInput>
    /**
     * In case the UserParticipeEvent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserParticipeEventUpdateInput, UserParticipeEventUncheckedUpdateInput>
  }


  /**
   * UserParticipeEvent delete
   */
  export type UserParticipeEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
    /**
     * Filter which UserParticipeEvent to delete.
     * 
    **/
    where: UserParticipeEventWhereUniqueInput
  }


  /**
   * UserParticipeEvent deleteMany
   */
  export type UserParticipeEventDeleteManyArgs = {
    where?: UserParticipeEventWhereInput
  }


  /**
   * UserParticipeEvent without action
   */
  export type UserParticipeEventArgs = {
    /**
     * Select specific fields to fetch from the UserParticipeEvent
     * 
    **/
    select?: UserParticipeEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserParticipeEventInclude | null
  }



  /**
   * Model Ereply
   */


  export type AggregateEreply = {
    _count: EreplyCountAggregateOutputType | null
    count: EreplyCountAggregateOutputType | null
    _avg: EreplyAvgAggregateOutputType | null
    avg: EreplyAvgAggregateOutputType | null
    _sum: EreplySumAggregateOutputType | null
    sum: EreplySumAggregateOutputType | null
    _min: EreplyMinAggregateOutputType | null
    min: EreplyMinAggregateOutputType | null
    _max: EreplyMaxAggregateOutputType | null
    max: EreplyMaxAggregateOutputType | null
  }

  export type EreplyAvgAggregateOutputType = {
    number: number | null
  }

  export type EreplySumAggregateOutputType = {
    number: number | null
  }

  export type EreplyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    teventId: string | null
    teamId: string | null
    userId: string | null
  }

  export type EreplyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    teventId: string | null
    teamId: string | null
    userId: string | null
  }

  export type EreplyCountAggregateOutputType = {
    id: number
    createdAt: number
    content: number
    number: number
    teventId: number
    teamId: number
    userId: number
    _all: number
  }


  export type EreplyAvgAggregateInputType = {
    number?: true
  }

  export type EreplySumAggregateInputType = {
    number?: true
  }

  export type EreplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    teventId?: true
    teamId?: true
    userId?: true
  }

  export type EreplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    teventId?: true
    teamId?: true
    userId?: true
  }

  export type EreplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    teventId?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type EreplyAggregateArgs = {
    /**
     * Filter which Ereply to aggregate.
     * 
    **/
    where?: EreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ereplies to fetch.
     * 
    **/
    orderBy?: Enumerable<EreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ereplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ereplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ereplies
    **/
    _count?: true | EreplyCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | EreplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EreplyAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: EreplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EreplySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: EreplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EreplyMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: EreplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EreplyMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: EreplyMaxAggregateInputType
  }

  export type GetEreplyAggregateType<T extends EreplyAggregateArgs> = {
        [P in keyof T & keyof AggregateEreply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEreply[P]>
      : GetScalarType<T[P], AggregateEreply[P]>
  }


    
    
  export type EreplyGroupByArgs = {
    where?: EreplyWhereInput
    orderBy?: Enumerable<EreplyOrderByInput>
    by: Array<EreplyScalarFieldEnum>
    having?: EreplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EreplyCountAggregateInputType | true
    _avg?: EreplyAvgAggregateInputType
    _sum?: EreplySumAggregateInputType
    _min?: EreplyMinAggregateInputType
    _max?: EreplyMaxAggregateInputType
  }


  export type EreplyGroupByOutputType = {
    id: string
    createdAt: Date
    content: string
    number: number
    teventId: string
    teamId: string
    userId: string
    _count: EreplyCountAggregateOutputType | null
    _avg: EreplyAvgAggregateOutputType | null
    _sum: EreplySumAggregateOutputType | null
    _min: EreplyMinAggregateOutputType | null
    _max: EreplyMaxAggregateOutputType | null
  }

  type GetEreplyGroupByPayload<T extends EreplyGroupByArgs> = Promise<
    Array<
      PickArray<EreplyGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EreplyGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EreplyGroupByOutputType[P]> 
            : GetScalarType<T[P], EreplyGroupByOutputType[P]>
        }
      > 
    >


  export type EreplySelect = {
    id?: boolean
    createdAt?: boolean
    content?: boolean
    number?: boolean
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    tevent?: boolean | TeventArgs
    teventId?: boolean
    teamId?: boolean
    userId?: boolean
  }

  export type EreplyInclude = {
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    tevent?: boolean | TeventArgs
  }

  export type EreplyGetPayload<
    S extends boolean | null | undefined | EreplyArgs,
    U = keyof S
      > = S extends true
        ? Ereply
    : S extends undefined
    ? never
    : S extends EreplyArgs | EreplyFindManyArgs
    ?'include' extends U
    ? Ereply  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'teamRef'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'tevent'
        ? TeventGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Ereply ?Ereply [P]
  : 
          P extends 'teamRef'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'tevent'
        ? TeventGetPayload<S['select'][P]> : never
  } 
    : Ereply
  : Ereply


  type EreplyCountArgs = Merge<
    Omit<EreplyFindManyArgs, 'select' | 'include'> & {
      select?: EreplyCountAggregateInputType | true
    }
  >

  export interface EreplyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ereply that matches the filter.
     * @param {EreplyFindUniqueArgs} args - Arguments to find a Ereply
     * @example
     * // Get one Ereply
     * const ereply = await prisma.ereply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EreplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EreplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ereply'> extends True ? CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>> : CheckSelect<T, Prisma__EreplyClient<Ereply | null >, Prisma__EreplyClient<EreplyGetPayload<T> | null >>

    /**
     * Find the first Ereply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyFindFirstArgs} args - Arguments to find a Ereply
     * @example
     * // Get one Ereply
     * const ereply = await prisma.ereply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EreplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EreplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ereply'> extends True ? CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>> : CheckSelect<T, Prisma__EreplyClient<Ereply | null >, Prisma__EreplyClient<EreplyGetPayload<T> | null >>

    /**
     * Find zero or more Ereplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ereplies
     * const ereplies = await prisma.ereply.findMany()
     * 
     * // Get first 10 Ereplies
     * const ereplies = await prisma.ereply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ereplyWithIdOnly = await prisma.ereply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EreplyFindManyArgs>(
      args?: SelectSubset<T, EreplyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Ereply>>, PrismaPromise<Array<EreplyGetPayload<T>>>>

    /**
     * Create a Ereply.
     * @param {EreplyCreateArgs} args - Arguments to create a Ereply.
     * @example
     * // Create one Ereply
     * const Ereply = await prisma.ereply.create({
     *   data: {
     *     // ... data to create a Ereply
     *   }
     * })
     * 
    **/
    create<T extends EreplyCreateArgs>(
      args: SelectSubset<T, EreplyCreateArgs>
    ): CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>>

    /**
     * Create many Ereplies.
     *     @param {EreplyCreateManyArgs} args - Arguments to create many Ereplies.
     *     @example
     *     // Create many Ereplies
     *     const ereply = await prisma.ereply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EreplyCreateManyArgs>(
      args?: SelectSubset<T, EreplyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ereply.
     * @param {EreplyDeleteArgs} args - Arguments to delete one Ereply.
     * @example
     * // Delete one Ereply
     * const Ereply = await prisma.ereply.delete({
     *   where: {
     *     // ... filter to delete one Ereply
     *   }
     * })
     * 
    **/
    delete<T extends EreplyDeleteArgs>(
      args: SelectSubset<T, EreplyDeleteArgs>
    ): CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>>

    /**
     * Update one Ereply.
     * @param {EreplyUpdateArgs} args - Arguments to update one Ereply.
     * @example
     * // Update one Ereply
     * const ereply = await prisma.ereply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EreplyUpdateArgs>(
      args: SelectSubset<T, EreplyUpdateArgs>
    ): CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>>

    /**
     * Delete zero or more Ereplies.
     * @param {EreplyDeleteManyArgs} args - Arguments to filter Ereplies to delete.
     * @example
     * // Delete a few Ereplies
     * const { count } = await prisma.ereply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EreplyDeleteManyArgs>(
      args?: SelectSubset<T, EreplyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ereplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ereplies
     * const ereply = await prisma.ereply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EreplyUpdateManyArgs>(
      args: SelectSubset<T, EreplyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ereply.
     * @param {EreplyUpsertArgs} args - Arguments to update or create a Ereply.
     * @example
     * // Update or create a Ereply
     * const ereply = await prisma.ereply.upsert({
     *   create: {
     *     // ... data to create a Ereply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ereply we want to update
     *   }
     * })
    **/
    upsert<T extends EreplyUpsertArgs>(
      args: SelectSubset<T, EreplyUpsertArgs>
    ): CheckSelect<T, Prisma__EreplyClient<Ereply>, Prisma__EreplyClient<EreplyGetPayload<T>>>

    /**
     * Count the number of Ereplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyCountArgs} args - Arguments to filter Ereplies to count.
     * @example
     * // Count the number of Ereplies
     * const count = await prisma.ereply.count({
     *   where: {
     *     // ... the filter for the Ereplies we want to count
     *   }
     * })
    **/
    count<T extends EreplyCountArgs>(
      args?: Subset<T, EreplyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EreplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ereply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EreplyAggregateArgs>(args: Subset<T, EreplyAggregateArgs>): PrismaPromise<GetEreplyAggregateType<T>>

    /**
     * Group by Ereply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EreplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EreplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EreplyGroupByArgs['orderBy'] }
        : { orderBy?: EreplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EreplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEreplyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ereply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EreplyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    teamRef<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    tevent<T extends TeventArgs = {}>(args?: Subset<T, TeventArgs>): CheckSelect<T, Prisma__TeventClient<Tevent | null >, Prisma__TeventClient<TeventGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Ereply findUnique
   */
  export type EreplyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * Throw an Error if a Ereply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Ereply to fetch.
     * 
    **/
    where: EreplyWhereUniqueInput
  }


  /**
   * Ereply findFirst
   */
  export type EreplyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * Throw an Error if a Ereply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Ereply to fetch.
     * 
    **/
    where?: EreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ereplies to fetch.
     * 
    **/
    orderBy?: Enumerable<EreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ereplies.
     * 
    **/
    cursor?: EreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ereplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ereplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ereplies.
     * 
    **/
    distinct?: Enumerable<EreplyScalarFieldEnum>
  }


  /**
   * Ereply findMany
   */
  export type EreplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * Filter, which Ereplies to fetch.
     * 
    **/
    where?: EreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ereplies to fetch.
     * 
    **/
    orderBy?: Enumerable<EreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ereplies.
     * 
    **/
    cursor?: EreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ereplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ereplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EreplyScalarFieldEnum>
  }


  /**
   * Ereply create
   */
  export type EreplyCreateArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * The data needed to create a Ereply.
     * 
    **/
    data: XOR<EreplyCreateInput, EreplyUncheckedCreateInput>
  }


  /**
   * Ereply createMany
   */
  export type EreplyCreateManyArgs = {
    data: Enumerable<EreplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ereply update
   */
  export type EreplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * The data needed to update a Ereply.
     * 
    **/
    data: XOR<EreplyUpdateInput, EreplyUncheckedUpdateInput>
    /**
     * Choose, which Ereply to update.
     * 
    **/
    where: EreplyWhereUniqueInput
  }


  /**
   * Ereply updateMany
   */
  export type EreplyUpdateManyArgs = {
    data: XOR<EreplyUpdateManyMutationInput, EreplyUncheckedUpdateManyInput>
    where?: EreplyWhereInput
  }


  /**
   * Ereply upsert
   */
  export type EreplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * The filter to search for the Ereply to update in case it exists.
     * 
    **/
    where: EreplyWhereUniqueInput
    /**
     * In case the Ereply found by the `where` argument doesn't exist, create a new Ereply with this data.
     * 
    **/
    create: XOR<EreplyCreateInput, EreplyUncheckedCreateInput>
    /**
     * In case the Ereply was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EreplyUpdateInput, EreplyUncheckedUpdateInput>
  }


  /**
   * Ereply delete
   */
  export type EreplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
    /**
     * Filter which Ereply to delete.
     * 
    **/
    where: EreplyWhereUniqueInput
  }


  /**
   * Ereply deleteMany
   */
  export type EreplyDeleteManyArgs = {
    where?: EreplyWhereInput
  }


  /**
   * Ereply without action
   */
  export type EreplyArgs = {
    /**
     * Select specific fields to fetch from the Ereply
     * 
    **/
    select?: EreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EreplyInclude | null
  }



  /**
   * Model Treply
   */


  export type AggregateTreply = {
    _count: TreplyCountAggregateOutputType | null
    count: TreplyCountAggregateOutputType | null
    _avg: TreplyAvgAggregateOutputType | null
    avg: TreplyAvgAggregateOutputType | null
    _sum: TreplySumAggregateOutputType | null
    sum: TreplySumAggregateOutputType | null
    _min: TreplyMinAggregateOutputType | null
    min: TreplyMinAggregateOutputType | null
    _max: TreplyMaxAggregateOutputType | null
    max: TreplyMaxAggregateOutputType | null
  }

  export type TreplyAvgAggregateOutputType = {
    number: number | null
  }

  export type TreplySumAggregateOutputType = {
    number: number | null
  }

  export type TreplyMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    tpostId: string | null
    teamId: string | null
    userId: string | null
  }

  export type TreplyMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    number: number | null
    tpostId: string | null
    teamId: string | null
    userId: string | null
  }

  export type TreplyCountAggregateOutputType = {
    id: number
    createdAt: number
    content: number
    number: number
    tpostId: number
    teamId: number
    userId: number
    _all: number
  }


  export type TreplyAvgAggregateInputType = {
    number?: true
  }

  export type TreplySumAggregateInputType = {
    number?: true
  }

  export type TreplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    tpostId?: true
    teamId?: true
    userId?: true
  }

  export type TreplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    tpostId?: true
    teamId?: true
    userId?: true
  }

  export type TreplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    number?: true
    tpostId?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type TreplyAggregateArgs = {
    /**
     * Filter which Treply to aggregate.
     * 
    **/
    where?: TreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treplies to fetch.
     * 
    **/
    orderBy?: Enumerable<TreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Treplies
    **/
    _count?: true | TreplyCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TreplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreplyAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TreplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreplySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TreplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreplyMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TreplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreplyMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TreplyMaxAggregateInputType
  }

  export type GetTreplyAggregateType<T extends TreplyAggregateArgs> = {
        [P in keyof T & keyof AggregateTreply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreply[P]>
      : GetScalarType<T[P], AggregateTreply[P]>
  }


    
    
  export type TreplyGroupByArgs = {
    where?: TreplyWhereInput
    orderBy?: Enumerable<TreplyOrderByInput>
    by: Array<TreplyScalarFieldEnum>
    having?: TreplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreplyCountAggregateInputType | true
    _avg?: TreplyAvgAggregateInputType
    _sum?: TreplySumAggregateInputType
    _min?: TreplyMinAggregateInputType
    _max?: TreplyMaxAggregateInputType
  }


  export type TreplyGroupByOutputType = {
    id: string
    createdAt: Date
    content: string
    number: number
    tpostId: string
    teamId: string
    userId: string
    _count: TreplyCountAggregateOutputType | null
    _avg: TreplyAvgAggregateOutputType | null
    _sum: TreplySumAggregateOutputType | null
    _min: TreplyMinAggregateOutputType | null
    _max: TreplyMaxAggregateOutputType | null
  }

  type GetTreplyGroupByPayload<T extends TreplyGroupByArgs> = Promise<
    Array<
      PickArray<TreplyGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TreplyGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TreplyGroupByOutputType[P]> 
            : GetScalarType<T[P], TreplyGroupByOutputType[P]>
        }
      > 
    >


  export type TreplySelect = {
    id?: boolean
    createdAt?: boolean
    content?: boolean
    number?: boolean
    tpost?: boolean | TpostArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
    tpostId?: boolean
    teamId?: boolean
    userId?: boolean
  }

  export type TreplyInclude = {
    tpost?: boolean | TpostArgs
    teamRef?: boolean | TeamArgs
    user?: boolean | UserArgs
  }

  export type TreplyGetPayload<
    S extends boolean | null | undefined | TreplyArgs,
    U = keyof S
      > = S extends true
        ? Treply
    : S extends undefined
    ? never
    : S extends TreplyArgs | TreplyFindManyArgs
    ?'include' extends U
    ? Treply  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tpost'
        ? TpostGetPayload<S['include'][P]> :
        P extends 'teamRef'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Treply ?Treply [P]
  : 
          P extends 'tpost'
        ? TpostGetPayload<S['select'][P]> :
        P extends 'teamRef'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Treply
  : Treply


  type TreplyCountArgs = Merge<
    Omit<TreplyFindManyArgs, 'select' | 'include'> & {
      select?: TreplyCountAggregateInputType | true
    }
  >

  export interface TreplyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Treply that matches the filter.
     * @param {TreplyFindUniqueArgs} args - Arguments to find a Treply
     * @example
     * // Get one Treply
     * const treply = await prisma.treply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TreplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TreplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Treply'> extends True ? CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>> : CheckSelect<T, Prisma__TreplyClient<Treply | null >, Prisma__TreplyClient<TreplyGetPayload<T> | null >>

    /**
     * Find the first Treply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyFindFirstArgs} args - Arguments to find a Treply
     * @example
     * // Get one Treply
     * const treply = await prisma.treply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TreplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TreplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Treply'> extends True ? CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>> : CheckSelect<T, Prisma__TreplyClient<Treply | null >, Prisma__TreplyClient<TreplyGetPayload<T> | null >>

    /**
     * Find zero or more Treplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treplies
     * const treplies = await prisma.treply.findMany()
     * 
     * // Get first 10 Treplies
     * const treplies = await prisma.treply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treplyWithIdOnly = await prisma.treply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TreplyFindManyArgs>(
      args?: SelectSubset<T, TreplyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Treply>>, PrismaPromise<Array<TreplyGetPayload<T>>>>

    /**
     * Create a Treply.
     * @param {TreplyCreateArgs} args - Arguments to create a Treply.
     * @example
     * // Create one Treply
     * const Treply = await prisma.treply.create({
     *   data: {
     *     // ... data to create a Treply
     *   }
     * })
     * 
    **/
    create<T extends TreplyCreateArgs>(
      args: SelectSubset<T, TreplyCreateArgs>
    ): CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>>

    /**
     * Create many Treplies.
     *     @param {TreplyCreateManyArgs} args - Arguments to create many Treplies.
     *     @example
     *     // Create many Treplies
     *     const treply = await prisma.treply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TreplyCreateManyArgs>(
      args?: SelectSubset<T, TreplyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Treply.
     * @param {TreplyDeleteArgs} args - Arguments to delete one Treply.
     * @example
     * // Delete one Treply
     * const Treply = await prisma.treply.delete({
     *   where: {
     *     // ... filter to delete one Treply
     *   }
     * })
     * 
    **/
    delete<T extends TreplyDeleteArgs>(
      args: SelectSubset<T, TreplyDeleteArgs>
    ): CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>>

    /**
     * Update one Treply.
     * @param {TreplyUpdateArgs} args - Arguments to update one Treply.
     * @example
     * // Update one Treply
     * const treply = await prisma.treply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TreplyUpdateArgs>(
      args: SelectSubset<T, TreplyUpdateArgs>
    ): CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>>

    /**
     * Delete zero or more Treplies.
     * @param {TreplyDeleteManyArgs} args - Arguments to filter Treplies to delete.
     * @example
     * // Delete a few Treplies
     * const { count } = await prisma.treply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TreplyDeleteManyArgs>(
      args?: SelectSubset<T, TreplyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treplies
     * const treply = await prisma.treply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TreplyUpdateManyArgs>(
      args: SelectSubset<T, TreplyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Treply.
     * @param {TreplyUpsertArgs} args - Arguments to update or create a Treply.
     * @example
     * // Update or create a Treply
     * const treply = await prisma.treply.upsert({
     *   create: {
     *     // ... data to create a Treply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treply we want to update
     *   }
     * })
    **/
    upsert<T extends TreplyUpsertArgs>(
      args: SelectSubset<T, TreplyUpsertArgs>
    ): CheckSelect<T, Prisma__TreplyClient<Treply>, Prisma__TreplyClient<TreplyGetPayload<T>>>

    /**
     * Count the number of Treplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyCountArgs} args - Arguments to filter Treplies to count.
     * @example
     * // Count the number of Treplies
     * const count = await prisma.treply.count({
     *   where: {
     *     // ... the filter for the Treplies we want to count
     *   }
     * })
    **/
    count<T extends TreplyCountArgs>(
      args?: Subset<T, TreplyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreplyAggregateArgs>(args: Subset<T, TreplyAggregateArgs>): PrismaPromise<GetTreplyAggregateType<T>>

    /**
     * Group by Treply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreplyGroupByArgs['orderBy'] }
        : { orderBy?: TreplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreplyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Treply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TreplyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tpost<T extends TpostArgs = {}>(args?: Subset<T, TpostArgs>): CheckSelect<T, Prisma__TpostClient<Tpost | null >, Prisma__TpostClient<TpostGetPayload<T> | null >>;

    teamRef<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Treply findUnique
   */
  export type TreplyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * Throw an Error if a Treply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Treply to fetch.
     * 
    **/
    where: TreplyWhereUniqueInput
  }


  /**
   * Treply findFirst
   */
  export type TreplyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * Throw an Error if a Treply can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Treply to fetch.
     * 
    **/
    where?: TreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treplies to fetch.
     * 
    **/
    orderBy?: Enumerable<TreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treplies.
     * 
    **/
    cursor?: TreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treplies.
     * 
    **/
    distinct?: Enumerable<TreplyScalarFieldEnum>
  }


  /**
   * Treply findMany
   */
  export type TreplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * Filter, which Treplies to fetch.
     * 
    **/
    where?: TreplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treplies to fetch.
     * 
    **/
    orderBy?: Enumerable<TreplyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Treplies.
     * 
    **/
    cursor?: TreplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TreplyScalarFieldEnum>
  }


  /**
   * Treply create
   */
  export type TreplyCreateArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * The data needed to create a Treply.
     * 
    **/
    data: XOR<TreplyCreateInput, TreplyUncheckedCreateInput>
  }


  /**
   * Treply createMany
   */
  export type TreplyCreateManyArgs = {
    data: Enumerable<TreplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Treply update
   */
  export type TreplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * The data needed to update a Treply.
     * 
    **/
    data: XOR<TreplyUpdateInput, TreplyUncheckedUpdateInput>
    /**
     * Choose, which Treply to update.
     * 
    **/
    where: TreplyWhereUniqueInput
  }


  /**
   * Treply updateMany
   */
  export type TreplyUpdateManyArgs = {
    data: XOR<TreplyUpdateManyMutationInput, TreplyUncheckedUpdateManyInput>
    where?: TreplyWhereInput
  }


  /**
   * Treply upsert
   */
  export type TreplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * The filter to search for the Treply to update in case it exists.
     * 
    **/
    where: TreplyWhereUniqueInput
    /**
     * In case the Treply found by the `where` argument doesn't exist, create a new Treply with this data.
     * 
    **/
    create: XOR<TreplyCreateInput, TreplyUncheckedCreateInput>
    /**
     * In case the Treply was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TreplyUpdateInput, TreplyUncheckedUpdateInput>
  }


  /**
   * Treply delete
   */
  export type TreplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
    /**
     * Filter which Treply to delete.
     * 
    **/
    where: TreplyWhereUniqueInput
  }


  /**
   * Treply deleteMany
   */
  export type TreplyDeleteManyArgs = {
    where?: TreplyWhereInput
  }


  /**
   * Treply without action
   */
  export type TreplyArgs = {
    /**
     * Select specific fields to fetch from the Treply
     * 
    **/
    select?: TreplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TreplyInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
    max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    sentAt: Date | null
    content: string | null
    htmlContent: string | null
    sentFromId: string | null
    sentInId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    sentAt: Date | null
    content: string | null
    htmlContent: string | null
    sentFromId: string | null
    sentInId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    sentAt: number
    content: number
    htmlContent: number
    sentFromId: number
    sentToId: number
    sentInId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentFromId?: true
    sentInId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentFromId?: true
    sentInId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentFromId?: true
    sentToId?: true
    sentInId?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }


    
    
  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    sentAt: Date
    content: string
    htmlContent: string | null
    sentFromId: string
    sentToId: string[]
    sentInId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Promise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MessageGroupByOutputType[P]> 
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      > 
    >


  export type MessageSelect = {
    id?: boolean
    sentAt?: boolean
    content?: boolean
    htmlContent?: boolean
    sentFrom?: boolean | UserArgs
    sentFromId?: boolean
    sentTo?: boolean | UserFindManyArgs
    sentToId?: boolean
    sentIn?: boolean | ChatArgs
    sentInId?: boolean
  }

  export type MessageInclude = {
    sentFrom?: boolean | UserArgs
    sentTo?: boolean | UserFindManyArgs
    sentIn?: boolean | ChatArgs
  }

  export type MessageGetPayload<
    S extends boolean | null | undefined | MessageArgs,
    U = keyof S
      > = S extends true
        ? Message
    : S extends undefined
    ? never
    : S extends MessageArgs | MessageFindManyArgs
    ?'include' extends U
    ? Message  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'sentFrom'
        ? UserGetPayload<S['include'][P]> :
        P extends 'sentTo'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'sentIn'
        ? ChatGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Message ?Message [P]
  : 
          P extends 'sentFrom'
        ? UserGetPayload<S['select'][P]> :
        P extends 'sentTo'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'sentIn'
        ? ChatGetPayload<S['select'][P]> : never
  } 
    : Message
  : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sentFrom<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    sentTo<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    sentIn<T extends ChatArgs = {}>(args?: Subset<T, ChatArgs>): CheckSelect<T, Prisma__ChatClient<Chat | null >, Prisma__ChatClient<ChatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
  }



  /**
   * Model SignalAdmin
   */


  export type AggregateSignalAdmin = {
    _count: SignalAdminCountAggregateOutputType | null
    count: SignalAdminCountAggregateOutputType | null
    _min: SignalAdminMinAggregateOutputType | null
    min: SignalAdminMinAggregateOutputType | null
    _max: SignalAdminMaxAggregateOutputType | null
    max: SignalAdminMaxAggregateOutputType | null
  }

  export type SignalAdminMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    isTreated: boolean | null
    chatId: string | null
    subject: string | null
    userId: string | null
  }

  export type SignalAdminMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    isTreated: boolean | null
    chatId: string | null
    subject: string | null
    userId: string | null
  }

  export type SignalAdminCountAggregateOutputType = {
    id: number
    createdAt: number
    content: number
    isTreated: number
    chatId: number
    subject: number
    userId: number
    _all: number
  }


  export type SignalAdminMinAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    isTreated?: true
    chatId?: true
    subject?: true
    userId?: true
  }

  export type SignalAdminMaxAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    isTreated?: true
    chatId?: true
    subject?: true
    userId?: true
  }

  export type SignalAdminCountAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    isTreated?: true
    chatId?: true
    subject?: true
    userId?: true
    _all?: true
  }

  export type SignalAdminAggregateArgs = {
    /**
     * Filter which SignalAdmin to aggregate.
     * 
    **/
    where?: SignalAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<SignalAdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SignalAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalAdmins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignalAdmins
    **/
    _count?: true | SignalAdminCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SignalAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalAdminMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SignalAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalAdminMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SignalAdminMaxAggregateInputType
  }

  export type GetSignalAdminAggregateType<T extends SignalAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSignalAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignalAdmin[P]>
      : GetScalarType<T[P], AggregateSignalAdmin[P]>
  }


    
    
  export type SignalAdminGroupByArgs = {
    where?: SignalAdminWhereInput
    orderBy?: Enumerable<SignalAdminOrderByInput>
    by: Array<SignalAdminScalarFieldEnum>
    having?: SignalAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalAdminCountAggregateInputType | true
    _min?: SignalAdminMinAggregateInputType
    _max?: SignalAdminMaxAggregateInputType
  }


  export type SignalAdminGroupByOutputType = {
    id: string
    createdAt: Date
    content: string
    isTreated: boolean
    chatId: string
    subject: string
    userId: string
    _count: SignalAdminCountAggregateOutputType | null
    _min: SignalAdminMinAggregateOutputType | null
    _max: SignalAdminMaxAggregateOutputType | null
  }

  type GetSignalAdminGroupByPayload<T extends SignalAdminGroupByArgs> = Promise<
    Array<
      PickArray<SignalAdminGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SignalAdminGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SignalAdminGroupByOutputType[P]> 
            : GetScalarType<T[P], SignalAdminGroupByOutputType[P]>
        }
      > 
    >


  export type SignalAdminSelect = {
    id?: boolean
    createdAt?: boolean
    content?: boolean
    isTreated?: boolean
    chatId?: boolean
    subject?: boolean
    userSending?: boolean | UserArgs
    userId?: boolean
  }

  export type SignalAdminInclude = {
    userSending?: boolean | UserArgs
  }

  export type SignalAdminGetPayload<
    S extends boolean | null | undefined | SignalAdminArgs,
    U = keyof S
      > = S extends true
        ? SignalAdmin
    : S extends undefined
    ? never
    : S extends SignalAdminArgs | SignalAdminFindManyArgs
    ?'include' extends U
    ? SignalAdmin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'userSending'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SignalAdmin ?SignalAdmin [P]
  : 
          P extends 'userSending'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : SignalAdmin
  : SignalAdmin


  type SignalAdminCountArgs = Merge<
    Omit<SignalAdminFindManyArgs, 'select' | 'include'> & {
      select?: SignalAdminCountAggregateInputType | true
    }
  >

  export interface SignalAdminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SignalAdmin that matches the filter.
     * @param {SignalAdminFindUniqueArgs} args - Arguments to find a SignalAdmin
     * @example
     * // Get one SignalAdmin
     * const signalAdmin = await prisma.signalAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SignalAdminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SignalAdminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SignalAdmin'> extends True ? CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>> : CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin | null >, Prisma__SignalAdminClient<SignalAdminGetPayload<T> | null >>

    /**
     * Find the first SignalAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminFindFirstArgs} args - Arguments to find a SignalAdmin
     * @example
     * // Get one SignalAdmin
     * const signalAdmin = await prisma.signalAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SignalAdminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SignalAdminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SignalAdmin'> extends True ? CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>> : CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin | null >, Prisma__SignalAdminClient<SignalAdminGetPayload<T> | null >>

    /**
     * Find zero or more SignalAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignalAdmins
     * const signalAdmins = await prisma.signalAdmin.findMany()
     * 
     * // Get first 10 SignalAdmins
     * const signalAdmins = await prisma.signalAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalAdminWithIdOnly = await prisma.signalAdmin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SignalAdminFindManyArgs>(
      args?: SelectSubset<T, SignalAdminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SignalAdmin>>, PrismaPromise<Array<SignalAdminGetPayload<T>>>>

    /**
     * Create a SignalAdmin.
     * @param {SignalAdminCreateArgs} args - Arguments to create a SignalAdmin.
     * @example
     * // Create one SignalAdmin
     * const SignalAdmin = await prisma.signalAdmin.create({
     *   data: {
     *     // ... data to create a SignalAdmin
     *   }
     * })
     * 
    **/
    create<T extends SignalAdminCreateArgs>(
      args: SelectSubset<T, SignalAdminCreateArgs>
    ): CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>>

    /**
     * Create many SignalAdmins.
     *     @param {SignalAdminCreateManyArgs} args - Arguments to create many SignalAdmins.
     *     @example
     *     // Create many SignalAdmins
     *     const signalAdmin = await prisma.signalAdmin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SignalAdminCreateManyArgs>(
      args?: SelectSubset<T, SignalAdminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SignalAdmin.
     * @param {SignalAdminDeleteArgs} args - Arguments to delete one SignalAdmin.
     * @example
     * // Delete one SignalAdmin
     * const SignalAdmin = await prisma.signalAdmin.delete({
     *   where: {
     *     // ... filter to delete one SignalAdmin
     *   }
     * })
     * 
    **/
    delete<T extends SignalAdminDeleteArgs>(
      args: SelectSubset<T, SignalAdminDeleteArgs>
    ): CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>>

    /**
     * Update one SignalAdmin.
     * @param {SignalAdminUpdateArgs} args - Arguments to update one SignalAdmin.
     * @example
     * // Update one SignalAdmin
     * const signalAdmin = await prisma.signalAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SignalAdminUpdateArgs>(
      args: SelectSubset<T, SignalAdminUpdateArgs>
    ): CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>>

    /**
     * Delete zero or more SignalAdmins.
     * @param {SignalAdminDeleteManyArgs} args - Arguments to filter SignalAdmins to delete.
     * @example
     * // Delete a few SignalAdmins
     * const { count } = await prisma.signalAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SignalAdminDeleteManyArgs>(
      args?: SelectSubset<T, SignalAdminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignalAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignalAdmins
     * const signalAdmin = await prisma.signalAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SignalAdminUpdateManyArgs>(
      args: SelectSubset<T, SignalAdminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SignalAdmin.
     * @param {SignalAdminUpsertArgs} args - Arguments to update or create a SignalAdmin.
     * @example
     * // Update or create a SignalAdmin
     * const signalAdmin = await prisma.signalAdmin.upsert({
     *   create: {
     *     // ... data to create a SignalAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignalAdmin we want to update
     *   }
     * })
    **/
    upsert<T extends SignalAdminUpsertArgs>(
      args: SelectSubset<T, SignalAdminUpsertArgs>
    ): CheckSelect<T, Prisma__SignalAdminClient<SignalAdmin>, Prisma__SignalAdminClient<SignalAdminGetPayload<T>>>

    /**
     * Count the number of SignalAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminCountArgs} args - Arguments to filter SignalAdmins to count.
     * @example
     * // Count the number of SignalAdmins
     * const count = await prisma.signalAdmin.count({
     *   where: {
     *     // ... the filter for the SignalAdmins we want to count
     *   }
     * })
    **/
    count<T extends SignalAdminCountArgs>(
      args?: Subset<T, SignalAdminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignalAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalAdminAggregateArgs>(args: Subset<T, SignalAdminAggregateArgs>): PrismaPromise<GetSignalAdminAggregateType<T>>

    /**
     * Group by SignalAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalAdminGroupByArgs['orderBy'] }
        : { orderBy?: SignalAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalAdminGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignalAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SignalAdminClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    userSending<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SignalAdmin findUnique
   */
  export type SignalAdminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * Throw an Error if a SignalAdmin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SignalAdmin to fetch.
     * 
    **/
    where: SignalAdminWhereUniqueInput
  }


  /**
   * SignalAdmin findFirst
   */
  export type SignalAdminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * Throw an Error if a SignalAdmin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SignalAdmin to fetch.
     * 
    **/
    where?: SignalAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<SignalAdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignalAdmins.
     * 
    **/
    cursor?: SignalAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalAdmins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignalAdmins.
     * 
    **/
    distinct?: Enumerable<SignalAdminScalarFieldEnum>
  }


  /**
   * SignalAdmin findMany
   */
  export type SignalAdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * Filter, which SignalAdmins to fetch.
     * 
    **/
    where?: SignalAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignalAdmins to fetch.
     * 
    **/
    orderBy?: Enumerable<SignalAdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignalAdmins.
     * 
    **/
    cursor?: SignalAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignalAdmins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignalAdmins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SignalAdminScalarFieldEnum>
  }


  /**
   * SignalAdmin create
   */
  export type SignalAdminCreateArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * The data needed to create a SignalAdmin.
     * 
    **/
    data: XOR<SignalAdminCreateInput, SignalAdminUncheckedCreateInput>
  }


  /**
   * SignalAdmin createMany
   */
  export type SignalAdminCreateManyArgs = {
    data: Enumerable<SignalAdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SignalAdmin update
   */
  export type SignalAdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * The data needed to update a SignalAdmin.
     * 
    **/
    data: XOR<SignalAdminUpdateInput, SignalAdminUncheckedUpdateInput>
    /**
     * Choose, which SignalAdmin to update.
     * 
    **/
    where: SignalAdminWhereUniqueInput
  }


  /**
   * SignalAdmin updateMany
   */
  export type SignalAdminUpdateManyArgs = {
    data: XOR<SignalAdminUpdateManyMutationInput, SignalAdminUncheckedUpdateManyInput>
    where?: SignalAdminWhereInput
  }


  /**
   * SignalAdmin upsert
   */
  export type SignalAdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * The filter to search for the SignalAdmin to update in case it exists.
     * 
    **/
    where: SignalAdminWhereUniqueInput
    /**
     * In case the SignalAdmin found by the `where` argument doesn't exist, create a new SignalAdmin with this data.
     * 
    **/
    create: XOR<SignalAdminCreateInput, SignalAdminUncheckedCreateInput>
    /**
     * In case the SignalAdmin was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SignalAdminUpdateInput, SignalAdminUncheckedUpdateInput>
  }


  /**
   * SignalAdmin delete
   */
  export type SignalAdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
    /**
     * Filter which SignalAdmin to delete.
     * 
    **/
    where: SignalAdminWhereUniqueInput
  }


  /**
   * SignalAdmin deleteMany
   */
  export type SignalAdminDeleteManyArgs = {
    where?: SignalAdminWhereInput
  }


  /**
   * SignalAdmin without action
   */
  export type SignalAdminArgs = {
    /**
     * Select specific fields to fetch from the SignalAdmin
     * 
    **/
    select?: SignalAdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SignalAdminInclude | null
  }



  /**
   * Model Chat
   */


  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
    max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    subject: string | null
    private: boolean | null
    IsDeletedByAdmin: boolean | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    private: boolean | null
    IsDeletedByAdmin: boolean | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    subject: number
    private: number
    IsDeletedByAdmin: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    subject?: true
    private?: true
    IsDeletedByAdmin?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    subject?: true
    private?: true
    IsDeletedByAdmin?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    subject?: true
    private?: true
    IsDeletedByAdmin?: true
    _all?: true
  }

  export type ChatAggregateArgs = {
    /**
     * Filter which Chat to aggregate.
     * 
    **/
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     * 
    **/
    orderBy?: Enumerable<ChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }


    
    
  export type ChatGroupByArgs = {
    where?: ChatWhereInput
    orderBy?: Enumerable<ChatOrderByInput>
    by: Array<ChatScalarFieldEnum>
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }


  export type ChatGroupByOutputType = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin: boolean
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Promise<
    Array<
      PickArray<ChatGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ChatGroupByOutputType[P]> 
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      > 
    >


  export type ChatSelect = {
    id?: boolean
    subject?: boolean
    private?: boolean
    adminMessages?: boolean | AdminMessageFindManyArgs
    messages?: boolean | MessageFindManyArgs
    participatingUsers?: boolean | UserFindManyArgs
    IsDeletedByAdmin?: boolean
  }

  export type ChatInclude = {
    adminMessages?: boolean | AdminMessageFindManyArgs
    messages?: boolean | MessageFindManyArgs
    participatingUsers?: boolean | UserFindManyArgs
  }

  export type ChatGetPayload<
    S extends boolean | null | undefined | ChatArgs,
    U = keyof S
      > = S extends true
        ? Chat
    : S extends undefined
    ? never
    : S extends ChatArgs | ChatFindManyArgs
    ?'include' extends U
    ? Chat  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'adminMessages'
        ? Array < AdminMessageGetPayload<S['include'][P]>>  :
        P extends 'messages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'participatingUsers'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Chat ?Chat [P]
  : 
          P extends 'adminMessages'
        ? Array < AdminMessageGetPayload<S['select'][P]>>  :
        P extends 'messages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'participatingUsers'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : Chat
  : Chat


  type ChatCountArgs = Merge<
    Omit<ChatFindManyArgs, 'select' | 'include'> & {
      select?: ChatCountAggregateInputType | true
    }
  >

  export interface ChatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chat'> extends True ? CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>> : CheckSelect<T, Prisma__ChatClient<Chat | null >, Prisma__ChatClient<ChatGetPayload<T> | null >>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chat'> extends True ? CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>> : CheckSelect<T, Prisma__ChatClient<Chat | null >, Prisma__ChatClient<ChatGetPayload<T> | null >>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatFindManyArgs>(
      args?: SelectSubset<T, ChatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Chat>>, PrismaPromise<Array<ChatGetPayload<T>>>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
    **/
    create<T extends ChatCreateArgs>(
      args: SelectSubset<T, ChatCreateArgs>
    ): CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>>

    /**
     * Create many Chats.
     *     @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     *     @example
     *     // Create many Chats
     *     const chat = await prisma.chat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatCreateManyArgs>(
      args?: SelectSubset<T, ChatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
    **/
    delete<T extends ChatDeleteArgs>(
      args: SelectSubset<T, ChatDeleteArgs>
    ): CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatUpdateArgs>(
      args: SelectSubset<T, ChatUpdateArgs>
    ): CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatDeleteManyArgs>(
      args?: SelectSubset<T, ChatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatUpdateManyArgs>(
      args: SelectSubset<T, ChatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
    **/
    upsert<T extends ChatUpsertArgs>(
      args: SelectSubset<T, ChatUpsertArgs>
    ): CheckSelect<T, Prisma__ChatClient<Chat>, Prisma__ChatClient<ChatGetPayload<T>>>

    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    adminMessages<T extends AdminMessageFindManyArgs = {}>(args?: Subset<T, AdminMessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdminMessage>>, PrismaPromise<Array<AdminMessageGetPayload<T>>>>;

    messages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    participatingUsers<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * Throw an Error if a Chat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Chat to fetch.
     * 
    **/
    where: ChatWhereUniqueInput
  }


  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * Throw an Error if a Chat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Chat to fetch.
     * 
    **/
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     * 
    **/
    orderBy?: Enumerable<ChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     * 
    **/
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     * 
    **/
    distinct?: Enumerable<ChatScalarFieldEnum>
  }


  /**
   * Chat findMany
   */
  export type ChatFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * Filter, which Chats to fetch.
     * 
    **/
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     * 
    **/
    orderBy?: Enumerable<ChatOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     * 
    **/
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChatScalarFieldEnum>
  }


  /**
   * Chat create
   */
  export type ChatCreateArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * The data needed to create a Chat.
     * 
    **/
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }


  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs = {
    data: Enumerable<ChatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chat update
   */
  export type ChatUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * The data needed to update a Chat.
     * 
    **/
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     * 
    **/
    where: ChatWhereUniqueInput
  }


  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs = {
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    where?: ChatWhereInput
  }


  /**
   * Chat upsert
   */
  export type ChatUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * The filter to search for the Chat to update in case it exists.
     * 
    **/
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     * 
    **/
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }


  /**
   * Chat delete
   */
  export type ChatDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
    /**
     * Filter which Chat to delete.
     * 
    **/
    where: ChatWhereUniqueInput
  }


  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs = {
    where?: ChatWhereInput
  }


  /**
   * Chat without action
   */
  export type ChatArgs = {
    /**
     * Select specific fields to fetch from the Chat
     * 
    **/
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChatInclude | null
  }



  /**
   * Model AdminMessage
   */


  export type AggregateAdminMessage = {
    _count: AdminMessageCountAggregateOutputType | null
    count: AdminMessageCountAggregateOutputType | null
    _min: AdminMessageMinAggregateOutputType | null
    min: AdminMessageMinAggregateOutputType | null
    _max: AdminMessageMaxAggregateOutputType | null
    max: AdminMessageMaxAggregateOutputType | null
  }

  export type AdminMessageMinAggregateOutputType = {
    id: string | null
    sentAt: Date | null
    content: string | null
    htmlContent: string | null
    sentInId: string | null
  }

  export type AdminMessageMaxAggregateOutputType = {
    id: string | null
    sentAt: Date | null
    content: string | null
    htmlContent: string | null
    sentInId: string | null
  }

  export type AdminMessageCountAggregateOutputType = {
    id: number
    sentAt: number
    content: number
    htmlContent: number
    sentInId: number
    _all: number
  }


  export type AdminMessageMinAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentInId?: true
  }

  export type AdminMessageMaxAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentInId?: true
  }

  export type AdminMessageCountAggregateInputType = {
    id?: true
    sentAt?: true
    content?: true
    htmlContent?: true
    sentInId?: true
    _all?: true
  }

  export type AdminMessageAggregateArgs = {
    /**
     * Filter which AdminMessage to aggregate.
     * 
    **/
    where?: AdminMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminMessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdminMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminMessages
    **/
    _count?: true | AdminMessageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AdminMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMessageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AdminMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMessageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AdminMessageMaxAggregateInputType
  }

  export type GetAdminMessageAggregateType<T extends AdminMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminMessage[P]>
      : GetScalarType<T[P], AggregateAdminMessage[P]>
  }


    
    
  export type AdminMessageGroupByArgs = {
    where?: AdminMessageWhereInput
    orderBy?: Enumerable<AdminMessageOrderByInput>
    by: Array<AdminMessageScalarFieldEnum>
    having?: AdminMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminMessageCountAggregateInputType | true
    _min?: AdminMessageMinAggregateInputType
    _max?: AdminMessageMaxAggregateInputType
  }


  export type AdminMessageGroupByOutputType = {
    id: string
    sentAt: Date
    content: string
    htmlContent: string | null
    sentInId: string
    _count: AdminMessageCountAggregateOutputType | null
    _min: AdminMessageMinAggregateOutputType | null
    _max: AdminMessageMaxAggregateOutputType | null
  }

  type GetAdminMessageGroupByPayload<T extends AdminMessageGroupByArgs> = Promise<
    Array<
      PickArray<AdminMessageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AdminMessageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AdminMessageGroupByOutputType[P]> 
            : GetScalarType<T[P], AdminMessageGroupByOutputType[P]>
        }
      > 
    >


  export type AdminMessageSelect = {
    id?: boolean
    sentAt?: boolean
    content?: boolean
    htmlContent?: boolean
    sentIn?: boolean | ChatArgs
    sentInId?: boolean
    wasReadBy?: boolean | UserFindManyArgs
  }

  export type AdminMessageInclude = {
    sentIn?: boolean | ChatArgs
    wasReadBy?: boolean | UserFindManyArgs
  }

  export type AdminMessageGetPayload<
    S extends boolean | null | undefined | AdminMessageArgs,
    U = keyof S
      > = S extends true
        ? AdminMessage
    : S extends undefined
    ? never
    : S extends AdminMessageArgs | AdminMessageFindManyArgs
    ?'include' extends U
    ? AdminMessage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'sentIn'
        ? ChatGetPayload<S['include'][P]> :
        P extends 'wasReadBy'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AdminMessage ?AdminMessage [P]
  : 
          P extends 'sentIn'
        ? ChatGetPayload<S['select'][P]> :
        P extends 'wasReadBy'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : AdminMessage
  : AdminMessage


  type AdminMessageCountArgs = Merge<
    Omit<AdminMessageFindManyArgs, 'select' | 'include'> & {
      select?: AdminMessageCountAggregateInputType | true
    }
  >

  export interface AdminMessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AdminMessage that matches the filter.
     * @param {AdminMessageFindUniqueArgs} args - Arguments to find a AdminMessage
     * @example
     * // Get one AdminMessage
     * const adminMessage = await prisma.adminMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AdminMessage'> extends True ? CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>> : CheckSelect<T, Prisma__AdminMessageClient<AdminMessage | null >, Prisma__AdminMessageClient<AdminMessageGetPayload<T> | null >>

    /**
     * Find the first AdminMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageFindFirstArgs} args - Arguments to find a AdminMessage
     * @example
     * // Get one AdminMessage
     * const adminMessage = await prisma.adminMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AdminMessage'> extends True ? CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>> : CheckSelect<T, Prisma__AdminMessageClient<AdminMessage | null >, Prisma__AdminMessageClient<AdminMessageGetPayload<T> | null >>

    /**
     * Find zero or more AdminMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminMessages
     * const adminMessages = await prisma.adminMessage.findMany()
     * 
     * // Get first 10 AdminMessages
     * const adminMessages = await prisma.adminMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminMessageWithIdOnly = await prisma.adminMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminMessageFindManyArgs>(
      args?: SelectSubset<T, AdminMessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AdminMessage>>, PrismaPromise<Array<AdminMessageGetPayload<T>>>>

    /**
     * Create a AdminMessage.
     * @param {AdminMessageCreateArgs} args - Arguments to create a AdminMessage.
     * @example
     * // Create one AdminMessage
     * const AdminMessage = await prisma.adminMessage.create({
     *   data: {
     *     // ... data to create a AdminMessage
     *   }
     * })
     * 
    **/
    create<T extends AdminMessageCreateArgs>(
      args: SelectSubset<T, AdminMessageCreateArgs>
    ): CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>>

    /**
     * Create many AdminMessages.
     *     @param {AdminMessageCreateManyArgs} args - Arguments to create many AdminMessages.
     *     @example
     *     // Create many AdminMessages
     *     const adminMessage = await prisma.adminMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminMessageCreateManyArgs>(
      args?: SelectSubset<T, AdminMessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AdminMessage.
     * @param {AdminMessageDeleteArgs} args - Arguments to delete one AdminMessage.
     * @example
     * // Delete one AdminMessage
     * const AdminMessage = await prisma.adminMessage.delete({
     *   where: {
     *     // ... filter to delete one AdminMessage
     *   }
     * })
     * 
    **/
    delete<T extends AdminMessageDeleteArgs>(
      args: SelectSubset<T, AdminMessageDeleteArgs>
    ): CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>>

    /**
     * Update one AdminMessage.
     * @param {AdminMessageUpdateArgs} args - Arguments to update one AdminMessage.
     * @example
     * // Update one AdminMessage
     * const adminMessage = await prisma.adminMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminMessageUpdateArgs>(
      args: SelectSubset<T, AdminMessageUpdateArgs>
    ): CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>>

    /**
     * Delete zero or more AdminMessages.
     * @param {AdminMessageDeleteManyArgs} args - Arguments to filter AdminMessages to delete.
     * @example
     * // Delete a few AdminMessages
     * const { count } = await prisma.adminMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminMessageDeleteManyArgs>(
      args?: SelectSubset<T, AdminMessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminMessages
     * const adminMessage = await prisma.adminMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminMessageUpdateManyArgs>(
      args: SelectSubset<T, AdminMessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminMessage.
     * @param {AdminMessageUpsertArgs} args - Arguments to update or create a AdminMessage.
     * @example
     * // Update or create a AdminMessage
     * const adminMessage = await prisma.adminMessage.upsert({
     *   create: {
     *     // ... data to create a AdminMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminMessage we want to update
     *   }
     * })
    **/
    upsert<T extends AdminMessageUpsertArgs>(
      args: SelectSubset<T, AdminMessageUpsertArgs>
    ): CheckSelect<T, Prisma__AdminMessageClient<AdminMessage>, Prisma__AdminMessageClient<AdminMessageGetPayload<T>>>

    /**
     * Count the number of AdminMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageCountArgs} args - Arguments to filter AdminMessages to count.
     * @example
     * // Count the number of AdminMessages
     * const count = await prisma.adminMessage.count({
     *   where: {
     *     // ... the filter for the AdminMessages we want to count
     *   }
     * })
    **/
    count<T extends AdminMessageCountArgs>(
      args?: Subset<T, AdminMessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminMessageAggregateArgs>(args: Subset<T, AdminMessageAggregateArgs>): PrismaPromise<GetAdminMessageAggregateType<T>>

    /**
     * Group by AdminMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminMessageGroupByArgs['orderBy'] }
        : { orderBy?: AdminMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminMessageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminMessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sentIn<T extends ChatArgs = {}>(args?: Subset<T, ChatArgs>): CheckSelect<T, Prisma__ChatClient<Chat | null >, Prisma__ChatClient<ChatGetPayload<T> | null >>;

    wasReadBy<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AdminMessage findUnique
   */
  export type AdminMessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * Throw an Error if a AdminMessage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdminMessage to fetch.
     * 
    **/
    where: AdminMessageWhereUniqueInput
  }


  /**
   * AdminMessage findFirst
   */
  export type AdminMessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * Throw an Error if a AdminMessage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdminMessage to fetch.
     * 
    **/
    where?: AdminMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminMessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminMessages.
     * 
    **/
    cursor?: AdminMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminMessages.
     * 
    **/
    distinct?: Enumerable<AdminMessageScalarFieldEnum>
  }


  /**
   * AdminMessage findMany
   */
  export type AdminMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * Filter, which AdminMessages to fetch.
     * 
    **/
    where?: AdminMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminMessageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminMessages.
     * 
    **/
    cursor?: AdminMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminMessages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdminMessageScalarFieldEnum>
  }


  /**
   * AdminMessage create
   */
  export type AdminMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * The data needed to create a AdminMessage.
     * 
    **/
    data: XOR<AdminMessageCreateInput, AdminMessageUncheckedCreateInput>
  }


  /**
   * AdminMessage createMany
   */
  export type AdminMessageCreateManyArgs = {
    data: Enumerable<AdminMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AdminMessage update
   */
  export type AdminMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * The data needed to update a AdminMessage.
     * 
    **/
    data: XOR<AdminMessageUpdateInput, AdminMessageUncheckedUpdateInput>
    /**
     * Choose, which AdminMessage to update.
     * 
    **/
    where: AdminMessageWhereUniqueInput
  }


  /**
   * AdminMessage updateMany
   */
  export type AdminMessageUpdateManyArgs = {
    data: XOR<AdminMessageUpdateManyMutationInput, AdminMessageUncheckedUpdateManyInput>
    where?: AdminMessageWhereInput
  }


  /**
   * AdminMessage upsert
   */
  export type AdminMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * The filter to search for the AdminMessage to update in case it exists.
     * 
    **/
    where: AdminMessageWhereUniqueInput
    /**
     * In case the AdminMessage found by the `where` argument doesn't exist, create a new AdminMessage with this data.
     * 
    **/
    create: XOR<AdminMessageCreateInput, AdminMessageUncheckedCreateInput>
    /**
     * In case the AdminMessage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdminMessageUpdateInput, AdminMessageUncheckedUpdateInput>
  }


  /**
   * AdminMessage delete
   */
  export type AdminMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
    /**
     * Filter which AdminMessage to delete.
     * 
    **/
    where: AdminMessageWhereUniqueInput
  }


  /**
   * AdminMessage deleteMany
   */
  export type AdminMessageDeleteManyArgs = {
    where?: AdminMessageWhereInput
  }


  /**
   * AdminMessage without action
   */
  export type AdminMessageArgs = {
    /**
     * Select specific fields to fetch from the AdminMessage
     * 
    **/
    select?: AdminMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminMessageInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    email: 'email',
    hashedPassword: 'hashedPassword',
    userDescription: 'userDescription',
    lien: 'lien',
    getNotifications: 'getNotifications',
    isActive: 'isActive',
    emailIsVerified: 'emailIsVerified',
    bio: 'bio',
    role: 'role',
    avatar: 'avatar',
    isPublic: 'isPublic',
    userLat: 'userLat',
    userLon: 'userLon',
    ip: 'ip'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    handle: 'handle',
    hashedSessionToken: 'hashedSessionToken',
    antiCSRFToken: 'antiCSRFToken',
    publicData: 'publicData',
    privateData: 'privateData',
    name: 'name',
    userId: 'userId',
    emailIsVerified: 'emailIsVerified'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const BannedIpScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    ip: 'ip'
  };

  export type BannedIpScalarFieldEnum = (typeof BannedIpScalarFieldEnum)[keyof typeof BannedIpScalarFieldEnum]


  export const MainPageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    usesEditor: 'usesEditor',
    maincontent: 'maincontent'
  };

  export type MainPageScalarFieldEnum = (typeof MainPageScalarFieldEnum)[keyof typeof MainPageScalarFieldEnum]


  export const ApostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    userId: 'userId'
  };

  export type ApostScalarFieldEnum = (typeof ApostScalarFieldEnum)[keyof typeof ApostScalarFieldEnum]


  export const AreplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    content: 'content',
    number: 'number',
    userId: 'userId',
    apostId: 'apostId'
  };

  export type AreplyScalarFieldEnum = (typeof AreplyScalarFieldEnum)[keyof typeof AreplyScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subject: 'subject',
    content: 'content',
    orderSubject: 'orderSubject'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hashedToken: 'hashedToken',
    type: 'type',
    expiresAt: 'expiresAt',
    sentTo: 'sentTo',
    userId: 'userId'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const TokenMailVerificationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hashedToken: 'hashedToken',
    type: 'type',
    expiresAt: 'expiresAt',
    sentTo: 'sentTo',
    hashedPassword: 'hashedPassword',
    name: 'name'
  };

  export type TokenMailVerificationScalarFieldEnum = (typeof TokenMailVerificationScalarFieldEnum)[keyof typeof TokenMailVerificationScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    asset_id: 'asset_id',
    url: 'url'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    corpus: 'corpus',
    anneeCreation: 'anneeCreation',
    secteur: 'secteur',
    typeOrg: 'typeOrg',
    taille: 'taille',
    teamLatitude: 'teamLatitude',
    teamLongitude: 'teamLongitude',
    image: 'image',
    imageCover: 'imageCover',
    TeamMastersID: 'TeamMastersID',
    TeamMemberId: 'TeamMemberId',
    public: 'public',
    findIndex: 'findIndex',
    publishDemand: 'publishDemand'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TagScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    isPublic: 'isPublic',
    catSpecific: 'catSpecific'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TeamFollowerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId',
    followerId: 'followerId'
  };

  export type TeamFollowerScalarFieldEnum = (typeof TeamFollowerScalarFieldEnum)[keyof typeof TeamFollowerScalarFieldEnum]


  export const TpostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    number: 'number',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type TpostScalarFieldEnum = (typeof TpostScalarFieldEnum)[keyof typeof TpostScalarFieldEnum]


  export const TeventScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subject: 'subject',
    startAt: 'startAt',
    endsAt: 'endsAt',
    content: 'content',
    maxParticipants: 'maxParticipants',
    teamId: 'teamId',
    userId: 'userId',
    eventLat: 'eventLat',
    eventLon: 'eventLon',
    locationDescription: 'locationDescription',
    visioPres: 'visioPres',
    linkVisio: 'linkVisio',
    visioCode: 'visioCode',
    infoPostscritum: 'infoPostscritum',
    isCancel: 'isCancel',
    visible: 'visible',
    postScriptWriterId: 'postScriptWriterId',
    recallEmailSent: 'recallEmailSent'
  };

  export type TeventScalarFieldEnum = (typeof TeventScalarFieldEnum)[keyof typeof TeventScalarFieldEnum]


  export const UserParticipeEventScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teventId: 'teventId',
    participantId: 'participantId'
  };

  export type UserParticipeEventScalarFieldEnum = (typeof UserParticipeEventScalarFieldEnum)[keyof typeof UserParticipeEventScalarFieldEnum]


  export const EreplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    content: 'content',
    number: 'number',
    teventId: 'teventId',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type EreplyScalarFieldEnum = (typeof EreplyScalarFieldEnum)[keyof typeof EreplyScalarFieldEnum]


  export const TreplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    content: 'content',
    number: 'number',
    tpostId: 'tpostId',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type TreplyScalarFieldEnum = (typeof TreplyScalarFieldEnum)[keyof typeof TreplyScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    sentAt: 'sentAt',
    content: 'content',
    htmlContent: 'htmlContent',
    sentFromId: 'sentFromId',
    sentToId: 'sentToId',
    sentInId: 'sentInId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SignalAdminScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    content: 'content',
    isTreated: 'isTreated',
    chatId: 'chatId',
    subject: 'subject',
    userId: 'userId'
  };

  export type SignalAdminScalarFieldEnum = (typeof SignalAdminScalarFieldEnum)[keyof typeof SignalAdminScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    private: 'private',
    IsDeletedByAdmin: 'IsDeletedByAdmin'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const AdminMessageScalarFieldEnum: {
    id: 'id',
    sentAt: 'sentAt',
    content: 'content',
    htmlContent: 'htmlContent',
    sentInId: 'sentInId'
  };

  export type AdminMessageScalarFieldEnum = (typeof AdminMessageScalarFieldEnum)[keyof typeof AdminMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    email?: StringFilter | string
    hashedPassword?: StringFilter | string
    userDescription?: StringFilter | string
    lien?: StringFilter | string
    getNotifications?: BoolFilter | boolean
    isActive?: BoolFilter | boolean
    emailIsVerified?: BoolFilter | boolean
    bio?: StringFilter | string
    role?: StringFilter | string
    avatar?: StringFilter | string
    tokens?: TokenListRelationFilter
    sessions?: SessionListRelationFilter
    teams?: TeamListRelationFilter
    tposts?: TpostListRelationFilter
    tevents?: TeventListRelationFilter
    treplies?: TreplyListRelationFilter
    aposts?: ApostListRelationFilter
    following?: TeamFollowerListRelationFilter
    ereplies?: EreplyListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    participatesIn?: ChatListRelationFilter
    images?: ImageListRelationFilter
    hasRead?: AdminMessageListRelationFilter
    isPublic?: BoolFilter | boolean
    userLat?: FloatFilter | number
    userLon?: FloatFilter | number
    invitedInEvent?: TeventListRelationFilter
    UserPartInEvents?: UserParticipeEventListRelationFilter
    ip?: StringNullableListFilter
    Areply?: AreplyListRelationFilter
    signalsToAdmin?: SignalAdminListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    hashedPassword?: SortOrder
    userDescription?: SortOrder
    lien?: SortOrder
    getNotifications?: SortOrder
    isActive?: SortOrder
    emailIsVerified?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    isPublic?: SortOrder
    userLat?: SortOrder
    userLon?: SortOrder
    ip?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    name?: string
    email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    hashedPassword?: StringWithAggregatesFilter | string
    userDescription?: StringWithAggregatesFilter | string
    lien?: StringWithAggregatesFilter | string
    getNotifications?: BoolWithAggregatesFilter | boolean
    isActive?: BoolWithAggregatesFilter | boolean
    emailIsVerified?: BoolWithAggregatesFilter | boolean
    bio?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    avatar?: StringWithAggregatesFilter | string
    isPublic?: BoolWithAggregatesFilter | boolean
    userLat?: FloatWithAggregatesFilter | number
    userLon?: FloatWithAggregatesFilter | number
    ip?: StringNullableListFilter
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    handle?: StringFilter | string
    hashedSessionToken?: StringNullableFilter | string | null
    antiCSRFToken?: StringNullableFilter | string | null
    publicData?: StringNullableFilter | string | null
    privateData?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    emailIsVerified?: BoolNullableFilter | boolean | null
  }

  export type SessionOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    handle?: SortOrder
    hashedSessionToken?: SortOrder
    antiCSRFToken?: SortOrder
    publicData?: SortOrder
    privateData?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    emailIsVerified?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: number
    handle?: string
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    handle?: StringWithAggregatesFilter | string
    hashedSessionToken?: StringNullableWithAggregatesFilter | string | null
    antiCSRFToken?: StringNullableWithAggregatesFilter | string | null
    publicData?: StringNullableWithAggregatesFilter | string | null
    privateData?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    emailIsVerified?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type BannedIpWhereInput = {
    AND?: Enumerable<BannedIpWhereInput>
    OR?: Enumerable<BannedIpWhereInput>
    NOT?: Enumerable<BannedIpWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    ip?: StringFilter | string
  }

  export type BannedIpOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ip?: SortOrder
  }

  export type BannedIpWhereUniqueInput = {
    id?: string
  }

  export type BannedIpScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BannedIpScalarWhereWithAggregatesInput>
    OR?: Enumerable<BannedIpScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BannedIpScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    ip?: StringWithAggregatesFilter | string
  }

  export type MainPageWhereInput = {
    AND?: Enumerable<MainPageWhereInput>
    OR?: Enumerable<MainPageWhereInput>
    NOT?: Enumerable<MainPageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usesEditor?: BoolFilter | boolean
    maincontent?: StringFilter | string
  }

  export type MainPageOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usesEditor?: SortOrder
    maincontent?: SortOrder
  }

  export type MainPageWhereUniqueInput = {
    id?: number
  }

  export type MainPageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MainPageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MainPageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MainPageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    usesEditor?: BoolWithAggregatesFilter | boolean
    maincontent?: StringWithAggregatesFilter | string
  }

  export type ApostWhereInput = {
    AND?: Enumerable<ApostWhereInput>
    OR?: Enumerable<ApostWhereInput>
    NOT?: Enumerable<ApostWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    areplys?: AreplyListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
  }

  export type ApostOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    userId?: SortOrder
  }

  export type ApostWhereUniqueInput = {
    id?: string
  }

  export type ApostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ApostScalarWhereWithAggregatesInput>
    OR?: Enumerable<ApostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ApostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type AreplyWhereInput = {
    AND?: Enumerable<AreplyWhereInput>
    OR?: Enumerable<AreplyWhereInput>
    NOT?: Enumerable<AreplyWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    apost?: XOR<ApostRelationFilter, ApostWhereInput>
    apostId?: StringFilter | string
  }

  export type AreplyOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    apostId?: SortOrder
  }

  export type AreplyWhereUniqueInput = {
    id?: string
  }

  export type AreplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AreplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<AreplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AreplyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    apostId?: StringWithAggregatesFilter | string
  }

  export type FaqWhereInput = {
    AND?: Enumerable<FaqWhereInput>
    OR?: Enumerable<FaqWhereInput>
    NOT?: Enumerable<FaqWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subject?: StringFilter | string
    content?: StringFilter | string
    orderSubject?: IntFilter | number
  }

  export type FaqOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    orderSubject?: SortOrder
  }

  export type FaqWhereUniqueInput = {
    id?: string
  }

  export type FaqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FaqScalarWhereWithAggregatesInput>
    OR?: Enumerable<FaqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FaqScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    subject?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    orderSubject?: IntWithAggregatesFilter | number
  }

  export type TokenWhereInput = {
    AND?: Enumerable<TokenWhereInput>
    OR?: Enumerable<TokenWhereInput>
    NOT?: Enumerable<TokenWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hashedToken?: StringFilter | string
    type?: StringFilter | string
    expiresAt?: DateTimeFilter | Date | string
    sentTo?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
  }

  export type TokenOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hashedToken?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    sentTo?: SortOrder
    userId?: SortOrder
  }

  export type TokenWhereUniqueInput = {
    id?: number
    hashedToken_type?: TokenHashedTokenTypeCompoundUniqueInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<TokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TokenScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    hashedToken?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    expiresAt?: DateTimeWithAggregatesFilter | Date | string
    sentTo?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type TokenMailVerificationWhereInput = {
    AND?: Enumerable<TokenMailVerificationWhereInput>
    OR?: Enumerable<TokenMailVerificationWhereInput>
    NOT?: Enumerable<TokenMailVerificationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hashedToken?: StringFilter | string
    type?: StringFilter | string
    expiresAt?: DateTimeFilter | Date | string
    sentTo?: StringFilter | string
    hashedPassword?: StringFilter | string
    name?: StringFilter | string
  }

  export type TokenMailVerificationOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hashedToken?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    sentTo?: SortOrder
    hashedPassword?: SortOrder
    name?: SortOrder
  }

  export type TokenMailVerificationWhereUniqueInput = {
    id?: number
    hashedToken_type?: TokenMailVerificationHashedTokenTypeCompoundUniqueInput
  }

  export type TokenMailVerificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokenMailVerificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<TokenMailVerificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TokenMailVerificationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    hashedToken?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    expiresAt?: DateTimeWithAggregatesFilter | Date | string
    sentTo?: StringWithAggregatesFilter | string
    hashedPassword?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    asset_id?: StringFilter | string
    url?: StringFilter | string
  }

  export type ImageOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    asset_id?: SortOrder
    url?: SortOrder
  }

  export type ImageWhereUniqueInput = {
    id?: string
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    asset_id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type TeamWhereInput = {
    AND?: Enumerable<TeamWhereInput>
    OR?: Enumerable<TeamWhereInput>
    NOT?: Enumerable<TeamWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    description?: StringFilter | string
    corpus?: StringFilter | string
    anneeCreation?: IntFilter | number
    secteur?: StringFilter | string
    typeOrg?: StringFilter | string
    taille?: IntFilter | number
    teamLatitude?: FloatFilter | number
    teamLongitude?: FloatFilter | number
    image?: StringFilter | string
    imageCover?: StringFilter | string
    TeamMastersID?: StringNullableListFilter
    TeamMemberId?: StringNullableListFilter
    users?: UserListRelationFilter
    public?: BoolFilter | boolean
    tposts?: TpostListRelationFilter
    findIndex?: IntFilter | number
    tevents?: TeventListRelationFilter
    treplies?: TreplyListRelationFilter
    ereplies?: EreplyListRelationFilter
    tags?: TagListRelationFilter
    teamFollowers?: TeamFollowerListRelationFilter
    publishDemand?: BoolFilter | boolean
  }

  export type TeamOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    corpus?: SortOrder
    anneeCreation?: SortOrder
    secteur?: SortOrder
    typeOrg?: SortOrder
    taille?: SortOrder
    teamLatitude?: SortOrder
    teamLongitude?: SortOrder
    image?: SortOrder
    imageCover?: SortOrder
    TeamMastersID?: SortOrder
    TeamMemberId?: SortOrder
    public?: SortOrder
    findIndex?: SortOrder
    publishDemand?: SortOrder
  }

  export type TeamWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    corpus?: StringWithAggregatesFilter | string
    anneeCreation?: IntWithAggregatesFilter | number
    secteur?: StringWithAggregatesFilter | string
    typeOrg?: StringWithAggregatesFilter | string
    taille?: IntWithAggregatesFilter | number
    teamLatitude?: FloatWithAggregatesFilter | number
    teamLongitude?: FloatWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    imageCover?: StringWithAggregatesFilter | string
    TeamMastersID?: StringNullableListFilter
    TeamMemberId?: StringNullableListFilter
    public?: BoolWithAggregatesFilter | boolean
    findIndex?: IntWithAggregatesFilter | number
    publishDemand?: BoolWithAggregatesFilter | boolean
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    id?: StringFilter | string
    teams?: TeamListRelationFilter
    isPublic?: BoolFilter | boolean
    catSpecific?: StringFilter | string
  }

  export type TagOrderByInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    isPublic?: SortOrder
    catSpecific?: SortOrder
  }

  export type TagWhereUniqueInput = {
    id?: string
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    id?: StringWithAggregatesFilter | string
    isPublic?: BoolWithAggregatesFilter | boolean
    catSpecific?: StringWithAggregatesFilter | string
  }

  export type TeamFollowerWhereInput = {
    AND?: Enumerable<TeamFollowerWhereInput>
    OR?: Enumerable<TeamFollowerWhereInput>
    NOT?: Enumerable<TeamFollowerWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    team?: TeamListRelationFilter
    teamId?: StringFilter | string
    user?: UserListRelationFilter
    followerId?: StringFilter | string
  }

  export type TeamFollowerOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    followerId?: SortOrder
  }

  export type TeamFollowerWhereUniqueInput = {
    id?: string
  }

  export type TeamFollowerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamFollowerScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamFollowerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamFollowerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    teamId?: StringWithAggregatesFilter | string
    followerId?: StringWithAggregatesFilter | string
  }

  export type TpostWhereInput = {
    AND?: Enumerable<TpostWhereInput>
    OR?: Enumerable<TpostWhereInput>
    NOT?: Enumerable<TpostWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    treplys?: TreplyListRelationFilter
    teamRef?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type TpostOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    number?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TpostWhereUniqueInput = {
    id?: string
  }

  export type TpostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TpostScalarWhereWithAggregatesInput>
    OR?: Enumerable<TpostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TpostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type TeventWhereInput = {
    AND?: Enumerable<TeventWhereInput>
    OR?: Enumerable<TeventWhereInput>
    NOT?: Enumerable<TeventWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subject?: StringFilter | string
    startAt?: DateTimeFilter | Date | string
    endsAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    maxParticipants?: IntFilter | number
    ereplys?: EreplyListRelationFilter
    teamRef?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    teamId?: StringFilter | string
    userId?: StringFilter | string
    invitedUsers?: UserListRelationFilter
    eventLat?: FloatFilter | number
    eventLon?: FloatFilter | number
    locationDescription?: StringNullableFilter | string | null
    visioPres?: BoolFilter | boolean
    linkVisio?: StringNullableFilter | string | null
    visioCode?: StringNullableFilter | string | null
    infoPostscritum?: StringNullableFilter | string | null
    isCancel?: BoolFilter | boolean
    usersParticipeEvent?: UserParticipeEventListRelationFilter
    visible?: BoolFilter | boolean
    postScriptWriterId?: StringNullableFilter | string | null
    recallEmailSent?: BoolFilter | boolean
  }

  export type TeventOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SortOrder
    startAt?: SortOrder
    endsAt?: SortOrder
    content?: SortOrder
    maxParticipants?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    eventLat?: SortOrder
    eventLon?: SortOrder
    locationDescription?: SortOrder
    visioPres?: SortOrder
    linkVisio?: SortOrder
    visioCode?: SortOrder
    infoPostscritum?: SortOrder
    isCancel?: SortOrder
    visible?: SortOrder
    postScriptWriterId?: SortOrder
    recallEmailSent?: SortOrder
  }

  export type TeventWhereUniqueInput = {
    id?: string
  }

  export type TeventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeventScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    subject?: StringWithAggregatesFilter | string
    startAt?: DateTimeWithAggregatesFilter | Date | string
    endsAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    maxParticipants?: IntWithAggregatesFilter | number
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    eventLat?: FloatWithAggregatesFilter | number
    eventLon?: FloatWithAggregatesFilter | number
    locationDescription?: StringNullableWithAggregatesFilter | string | null
    visioPres?: BoolWithAggregatesFilter | boolean
    linkVisio?: StringNullableWithAggregatesFilter | string | null
    visioCode?: StringNullableWithAggregatesFilter | string | null
    infoPostscritum?: StringNullableWithAggregatesFilter | string | null
    isCancel?: BoolWithAggregatesFilter | boolean
    visible?: BoolWithAggregatesFilter | boolean
    postScriptWriterId?: StringNullableWithAggregatesFilter | string | null
    recallEmailSent?: BoolWithAggregatesFilter | boolean
  }

  export type UserParticipeEventWhereInput = {
    AND?: Enumerable<UserParticipeEventWhereInput>
    OR?: Enumerable<UserParticipeEventWhereInput>
    NOT?: Enumerable<UserParticipeEventWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    tevent?: TeventListRelationFilter
    teventId?: StringFilter | string
    user?: UserListRelationFilter
    participantId?: StringFilter | string
  }

  export type UserParticipeEventOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teventId?: SortOrder
    participantId?: SortOrder
  }

  export type UserParticipeEventWhereUniqueInput = {
    id?: string
  }

  export type UserParticipeEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserParticipeEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserParticipeEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserParticipeEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    teventId?: StringWithAggregatesFilter | string
    participantId?: StringWithAggregatesFilter | string
  }

  export type EreplyWhereInput = {
    AND?: Enumerable<EreplyWhereInput>
    OR?: Enumerable<EreplyWhereInput>
    NOT?: Enumerable<EreplyWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    teamRef?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    tevent?: XOR<TeventRelationFilter, TeventWhereInput>
    teventId?: StringFilter | string
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type EreplyOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    number?: SortOrder
    teventId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type EreplyWhereUniqueInput = {
    id?: string
  }

  export type EreplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EreplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<EreplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EreplyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    teventId?: StringWithAggregatesFilter | string
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type TreplyWhereInput = {
    AND?: Enumerable<TreplyWhereInput>
    OR?: Enumerable<TreplyWhereInput>
    NOT?: Enumerable<TreplyWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    tpost?: XOR<TpostRelationFilter, TpostWhereInput>
    teamRef?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    tpostId?: StringFilter | string
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type TreplyOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    number?: SortOrder
    tpostId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TreplyWhereUniqueInput = {
    id?: string
  }

  export type TreplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TreplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<TreplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TreplyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    tpostId?: StringWithAggregatesFilter | string
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: StringFilter | string
    sentAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    htmlContent?: StringNullableFilter | string | null
    sentFrom?: XOR<UserRelationFilter, UserWhereInput>
    sentFromId?: StringFilter | string
    sentTo?: UserListRelationFilter
    sentToId?: StringNullableListFilter
    sentIn?: XOR<ChatRelationFilter, ChatWhereInput>
    sentInId?: StringFilter | string
  }

  export type MessageOrderByInput = {
    id?: SortOrder
    sentAt?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    sentFromId?: SortOrder
    sentToId?: SortOrder
    sentInId?: SortOrder
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sentAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    htmlContent?: StringNullableWithAggregatesFilter | string | null
    sentFromId?: StringWithAggregatesFilter | string
    sentToId?: StringNullableListFilter
    sentInId?: StringWithAggregatesFilter | string
  }

  export type SignalAdminWhereInput = {
    AND?: Enumerable<SignalAdminWhereInput>
    OR?: Enumerable<SignalAdminWhereInput>
    NOT?: Enumerable<SignalAdminWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    isTreated?: BoolFilter | boolean
    chatId?: StringFilter | string
    subject?: StringFilter | string
    userSending?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
  }

  export type SignalAdminOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    isTreated?: SortOrder
    chatId?: SortOrder
    subject?: SortOrder
    userId?: SortOrder
  }

  export type SignalAdminWhereUniqueInput = {
    id?: string
    chatId?: string
  }

  export type SignalAdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SignalAdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<SignalAdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SignalAdminScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    isTreated?: BoolWithAggregatesFilter | boolean
    chatId?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type ChatWhereInput = {
    AND?: Enumerable<ChatWhereInput>
    OR?: Enumerable<ChatWhereInput>
    NOT?: Enumerable<ChatWhereInput>
    id?: StringFilter | string
    subject?: StringFilter | string
    private?: BoolFilter | boolean
    adminMessages?: AdminMessageListRelationFilter
    messages?: MessageListRelationFilter
    participatingUsers?: UserListRelationFilter
    IsDeletedByAdmin?: BoolFilter | boolean
  }

  export type ChatOrderByInput = {
    id?: SortOrder
    subject?: SortOrder
    private?: SortOrder
    IsDeletedByAdmin?: SortOrder
  }

  export type ChatWhereUniqueInput = {
    id?: string
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    private?: BoolWithAggregatesFilter | boolean
    IsDeletedByAdmin?: BoolWithAggregatesFilter | boolean
  }

  export type AdminMessageWhereInput = {
    AND?: Enumerable<AdminMessageWhereInput>
    OR?: Enumerable<AdminMessageWhereInput>
    NOT?: Enumerable<AdminMessageWhereInput>
    id?: StringFilter | string
    sentAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    htmlContent?: StringNullableFilter | string | null
    sentIn?: XOR<ChatRelationFilter, ChatWhereInput>
    sentInId?: StringFilter | string
    wasReadBy?: UserListRelationFilter
  }

  export type AdminMessageOrderByInput = {
    id?: SortOrder
    sentAt?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    sentInId?: SortOrder
  }

  export type AdminMessageWhereUniqueInput = {
    id?: string
  }

  export type AdminMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sentAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    htmlContent?: StringNullableWithAggregatesFilter | string | null
    sentInId?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateManyipInput | Enumerable<string>
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type SessionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    emailIsVerified?: boolean | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    userId: string
    emailIsVerified?: boolean | null
  }

  export type SessionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutSessionsInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    userId: string
    emailIsVerified?: boolean | null
  }

  export type SessionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BannedIpCreateInput = {
    id?: string
    createdAt?: Date | string
    ip: string
  }

  export type BannedIpUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    ip: string
  }

  export type BannedIpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type BannedIpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type BannedIpCreateManyInput = {
    id?: string
    createdAt?: Date | string
    ip: string
  }

  export type BannedIpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type BannedIpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type MainPageCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    usesEditor?: boolean
    maincontent?: string
  }

  export type MainPageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usesEditor?: boolean
    maincontent?: string
  }

  export type MainPageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usesEditor?: BoolFieldUpdateOperationsInput | boolean
    maincontent?: StringFieldUpdateOperationsInput | string
  }

  export type MainPageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usesEditor?: BoolFieldUpdateOperationsInput | boolean
    maincontent?: StringFieldUpdateOperationsInput | string
  }

  export type MainPageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usesEditor?: boolean
    maincontent?: string
  }

  export type MainPageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usesEditor?: BoolFieldUpdateOperationsInput | boolean
    maincontent?: StringFieldUpdateOperationsInput | string
  }

  export type MainPageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usesEditor?: BoolFieldUpdateOperationsInput | boolean
    maincontent?: StringFieldUpdateOperationsInput | string
  }

  export type ApostCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    areplys?: AreplyCreateNestedManyWithoutApostInput
    user: UserCreateNestedOneWithoutApostsInput
  }

  export type ApostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    userId: string
    areplys?: AreplyUncheckedCreateNestedManyWithoutApostInput
  }

  export type ApostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    areplys?: AreplyUpdateManyWithoutApostInput
    user?: UserUpdateOneRequiredWithoutApostsInput
  }

  export type ApostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areplys?: AreplyUncheckedUpdateManyWithoutApostInput
  }

  export type ApostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    userId: string
  }

  export type ApostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ApostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    user: UserCreateNestedOneWithoutAreplyInput
    apost: ApostCreateNestedOneWithoutAreplysInput
  }

  export type AreplyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    userId: string
    apostId: string
  }

  export type AreplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAreplyInput
    apost?: ApostUpdateOneRequiredWithoutAreplysInput
  }

  export type AreplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    apostId?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    userId: string
    apostId: string
  }

  export type AreplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type AreplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    apostId?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    content: string
    orderSubject: number
  }

  export type FaqUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    content: string
    orderSubject: number
  }

  export type FaqUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderSubject?: IntFieldUpdateOperationsInput | number
  }

  export type FaqUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderSubject?: IntFieldUpdateOperationsInput | number
  }

  export type FaqCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    content: string
    orderSubject: number
  }

  export type FaqUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderSubject?: IntFieldUpdateOperationsInput | number
  }

  export type FaqUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderSubject?: IntFieldUpdateOperationsInput | number
  }

  export type TokenCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    userId: string
  }

  export type TokenUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTokensInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    userId: string
  }

  export type TokenUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenMailVerificationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    hashedPassword: string
    name: string
  }

  export type TokenMailVerificationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    hashedPassword: string
    name: string
  }

  export type TokenMailVerificationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TokenMailVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TokenMailVerificationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
    hashedPassword: string
    name: string
  }

  export type TokenMailVerificationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TokenMailVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    id?: string
    createdAt?: Date | string
    asset_id: string
    url: string
    user: UserCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    asset_id: string
    url: string
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutImagesInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    asset_id: string
    url: string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type TeamCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateManyTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateManyTeamMemberIdInput | Enumerable<string>
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
  }

  export type TagCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id: string
    isPublic?: boolean
    catSpecific?: string
    teams?: TeamCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id: string
    isPublic?: boolean
    catSpecific?: string
  }

  export type TagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
    teams?: TeamUpdateManyWithoutTagsInput
  }

  export type TagUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id: string
    isPublic?: boolean
    catSpecific?: string
  }

  export type TagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
    team?: TeamCreateNestedManyWithoutTeamFollowersInput
    user?: UserCreateNestedManyWithoutFollowingInput
  }

  export type TeamFollowerUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
  }

  export type TeamFollowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateManyWithoutTeamFollowersInput
    user?: UserUpdateManyWithoutFollowingInput
  }

  export type TeamFollowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
  }

  export type TeamFollowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TpostCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    treplys?: TreplyCreateNestedManyWithoutTpostInput
    teamRef: TeamCreateNestedOneWithoutTpostsInput
    user: UserCreateNestedOneWithoutTpostsInput
  }

  export type TpostUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
    treplys?: TreplyUncheckedCreateNestedManyWithoutTpostInput
  }

  export type TpostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    treplys?: TreplyUpdateManyWithoutTpostInput
    teamRef?: TeamUpdateOneRequiredWithoutTpostsInput
    user?: UserUpdateOneRequiredWithoutTpostsInput
  }

  export type TpostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    treplys?: TreplyUncheckedUpdateManyWithoutTpostInput
  }

  export type TpostCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type TpostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type TpostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TeventCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyCreateNestedManyWithoutTeventInput
    teamRef: TeamCreateNestedOneWithoutTeventsInput
    user: UserCreateNestedOneWithoutTeventsInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventCreateNestedManyWithoutTeventInput
  }

  export type TeventUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyUncheckedCreateNestedManyWithoutTeventInput
  }

  export type TeventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUpdateManyWithoutTeventInput
    teamRef?: TeamUpdateOneRequiredWithoutTeventsInput
    user?: UserUpdateOneRequiredWithoutTeventsInput
    invitedUsers?: UserUpdateManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUncheckedUpdateManyWithoutTeventInput
  }

  export type TeventCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
  }

  export type TeventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserParticipeEventCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
    tevent?: TeventCreateNestedManyWithoutUsersParticipeEventInput
    user?: UserCreateNestedManyWithoutUserPartInEventsInput
  }

  export type UserParticipeEventUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
  }

  export type UserParticipeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    tevent?: TeventUpdateManyWithoutUsersParticipeEventInput
    user?: UserUpdateManyWithoutUserPartInEventsInput
  }

  export type UserParticipeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserParticipeEventCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
  }

  export type UserParticipeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserParticipeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamRef: TeamCreateNestedOneWithoutErepliesInput
    user: UserCreateNestedOneWithoutErepliesInput
    tevent: TeventCreateNestedOneWithoutEreplysInput
  }

  export type EreplyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    teamId: string
    userId: string
  }

  export type EreplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamRef?: TeamUpdateOneRequiredWithoutErepliesInput
    user?: UserUpdateOneRequiredWithoutErepliesInput
    tevent?: TeventUpdateOneRequiredWithoutEreplysInput
  }

  export type EreplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teventId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    teamId: string
    userId: string
  }

  export type EreplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type EreplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teventId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TreplyCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpost: TpostCreateNestedOneWithoutTreplysInput
    teamRef: TeamCreateNestedOneWithoutTrepliesInput
    user: UserCreateNestedOneWithoutTrepliesInput
  }

  export type TreplyUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    teamId: string
    userId: string
  }

  export type TreplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpost?: TpostUpdateOneRequiredWithoutTreplysInput
    teamRef?: TeamUpdateOneRequiredWithoutTrepliesInput
    user?: UserUpdateOneRequiredWithoutTrepliesInput
  }

  export type TreplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpostId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TreplyCreateManyInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    teamId: string
    userId: string
  }

  export type TreplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type TreplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpostId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
    sentFrom: UserCreateNestedOneWithoutSentMessagesInput
    sentTo?: UserCreateNestedManyWithoutReceivedMessagesInput
    sentIn: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentFromId: string
    sentInId: string
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
    sentFrom?: UserUpdateOneRequiredWithoutSentMessagesInput
    sentTo?: UserUpdateManyWithoutReceivedMessagesInput
    sentIn?: ChatUpdateOneRequiredWithoutMessagesInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageCreateManyInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentFromId: string
    sentInId: string
    sentToId?: MessageCreateManysentToIdInput | Enumerable<string>
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type SignalAdminCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
    userSending: UserCreateNestedOneWithoutSignalsToAdminInput
  }

  export type SignalAdminUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
    userId: string
  }

  export type SignalAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    userSending?: UserUpdateOneRequiredWithoutSignalsToAdminInput
  }

  export type SignalAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalAdminCreateManyInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
    userId: string
  }

  export type SignalAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SignalAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageCreateNestedManyWithoutSentInInput
    messages?: MessageCreateNestedManyWithoutSentInInput
    participatingUsers?: UserCreateNestedManyWithoutParticipatesInInput
  }

  export type ChatUncheckedCreateInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageUncheckedCreateNestedManyWithoutSentInInput
    messages?: MessageUncheckedCreateNestedManyWithoutSentInInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUpdateManyWithoutSentInInput
    messages?: MessageUpdateManyWithoutSentInInput
    participatingUsers?: UserUpdateManyWithoutParticipatesInInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUncheckedUpdateManyWithoutSentInInput
    messages?: MessageUncheckedUpdateManyWithoutSentInInput
  }

  export type ChatCreateManyInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminMessageCreateInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentIn: ChatCreateNestedOneWithoutAdminMessagesInput
    wasReadBy?: UserCreateNestedManyWithoutHasReadInput
  }

  export type AdminMessageUncheckedCreateInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentInId: string
  }

  export type AdminMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentIn?: ChatUpdateOneRequiredWithoutAdminMessagesInput
    wasReadBy?: UserUpdateManyWithoutHasReadInput
  }

  export type AdminMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminMessageCreateManyInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentInId: string
  }

  export type AdminMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TpostListRelationFilter = {
    every?: TpostWhereInput
    some?: TpostWhereInput
    none?: TpostWhereInput
  }

  export type TeventListRelationFilter = {
    every?: TeventWhereInput
    some?: TeventWhereInput
    none?: TeventWhereInput
  }

  export type TreplyListRelationFilter = {
    every?: TreplyWhereInput
    some?: TreplyWhereInput
    none?: TreplyWhereInput
  }

  export type ApostListRelationFilter = {
    every?: ApostWhereInput
    some?: ApostWhereInput
    none?: ApostWhereInput
  }

  export type TeamFollowerListRelationFilter = {
    every?: TeamFollowerWhereInput
    some?: TeamFollowerWhereInput
    none?: TeamFollowerWhereInput
  }

  export type EreplyListRelationFilter = {
    every?: EreplyWhereInput
    some?: EreplyWhereInput
    none?: EreplyWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type AdminMessageListRelationFilter = {
    every?: AdminMessageWhereInput
    some?: AdminMessageWhereInput
    none?: AdminMessageWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type UserParticipeEventListRelationFilter = {
    every?: UserParticipeEventWhereInput
    some?: UserParticipeEventWhereInput
    none?: UserParticipeEventWhereInput
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type AreplyListRelationFilter = {
    every?: AreplyWhereInput
    some?: AreplyWhereInput
    none?: AreplyWhereInput
  }

  export type SignalAdminListRelationFilter = {
    every?: SignalAdminWhereInput
    some?: SignalAdminWhereInput
    none?: SignalAdminWhereInput
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type ApostRelationFilter = {
    is?: ApostWhereInput
    isNot?: ApostWhereInput
  }

  export type TokenHashedTokenTypeCompoundUniqueInput = {
    hashedToken: string
    type: string
  }

  export type TokenMailVerificationHashedTokenTypeCompoundUniqueInput = {
    hashedToken: string
    type: string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeventRelationFilter = {
    is?: TeventWhereInput
    isNot?: TeventWhereInput
  }

  export type TpostRelationFilter = {
    is?: TpostWhereInput
    isNot?: TpostWhereInput
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type UserCreateipInput = {
    set: Enumerable<string>
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type TeamCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutUsersInput>, Enumerable<TeamUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type TpostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TpostCreateWithoutUserInput>, Enumerable<TpostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutUserInput>
    createMany?: TpostCreateManyUserInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
  }

  export type TeventCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUserInput>, Enumerable<TeventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUserInput>
    createMany?: TeventCreateManyUserInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type TreplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutUserInput>, Enumerable<TreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutUserInput>
    createMany?: TreplyCreateManyUserInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type ApostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ApostCreateWithoutUserInput>, Enumerable<ApostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ApostCreateOrConnectWithoutUserInput>
    createMany?: ApostCreateManyUserInputEnvelope
    connect?: Enumerable<ApostWhereUniqueInput>
  }

  export type TeamFollowerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamFollowerCreateWithoutUserInput>, Enumerable<TeamFollowerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamFollowerCreateOrConnectWithoutUserInput>
    connect?: Enumerable<TeamFollowerWhereUniqueInput>
  }

  export type EreplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutUserInput>, Enumerable<EreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutUserInput>
    createMany?: EreplyCreateManyUserInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutSentFromInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentFromInput>, Enumerable<MessageUncheckedCreateWithoutSentFromInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentFromInput>
    createMany?: MessageCreateManySentFromInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutSentToInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentToInput>, Enumerable<MessageUncheckedCreateWithoutSentToInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentToInput>
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ChatCreateNestedManyWithoutParticipatingUsersInput = {
    create?: XOR<Enumerable<ChatCreateWithoutParticipatingUsersInput>, Enumerable<ChatUncheckedCreateWithoutParticipatingUsersInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutParticipatingUsersInput>
    connect?: Enumerable<ChatWhereUniqueInput>
  }

  export type ImageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type AdminMessageCreateNestedManyWithoutWasReadByInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutWasReadByInput>, Enumerable<AdminMessageUncheckedCreateWithoutWasReadByInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutWasReadByInput>
    connect?: Enumerable<AdminMessageWhereUniqueInput>
  }

  export type TeventCreateNestedManyWithoutInvitedUsersInput = {
    create?: XOR<Enumerable<TeventCreateWithoutInvitedUsersInput>, Enumerable<TeventUncheckedCreateWithoutInvitedUsersInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutInvitedUsersInput>
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type UserParticipeEventCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserParticipeEventCreateWithoutUserInput>, Enumerable<UserParticipeEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserParticipeEventCreateOrConnectWithoutUserInput>
    connect?: Enumerable<UserParticipeEventWhereUniqueInput>
  }

  export type AreplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutUserInput>, Enumerable<AreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutUserInput>
    createMany?: AreplyCreateManyUserInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
  }

  export type SignalAdminCreateNestedManyWithoutUserSendingInput = {
    create?: XOR<Enumerable<SignalAdminCreateWithoutUserSendingInput>, Enumerable<SignalAdminUncheckedCreateWithoutUserSendingInput>>
    connectOrCreate?: Enumerable<SignalAdminCreateOrConnectWithoutUserSendingInput>
    createMany?: SignalAdminCreateManyUserSendingInputEnvelope
    connect?: Enumerable<SignalAdminWhereUniqueInput>
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type TpostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TpostCreateWithoutUserInput>, Enumerable<TpostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutUserInput>
    createMany?: TpostCreateManyUserInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
  }

  export type TeventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUserInput>, Enumerable<TeventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUserInput>
    createMany?: TeventCreateManyUserInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type TreplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutUserInput>, Enumerable<TreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutUserInput>
    createMany?: TreplyCreateManyUserInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type ApostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ApostCreateWithoutUserInput>, Enumerable<ApostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ApostCreateOrConnectWithoutUserInput>
    createMany?: ApostCreateManyUserInputEnvelope
    connect?: Enumerable<ApostWhereUniqueInput>
  }

  export type EreplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutUserInput>, Enumerable<EreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutUserInput>
    createMany?: EreplyCreateManyUserInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutSentFromInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentFromInput>, Enumerable<MessageUncheckedCreateWithoutSentFromInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentFromInput>
    createMany?: MessageCreateManySentFromInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ImageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type AreplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutUserInput>, Enumerable<AreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutUserInput>
    createMany?: AreplyCreateManyUserInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
  }

  export type SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput = {
    create?: XOR<Enumerable<SignalAdminCreateWithoutUserSendingInput>, Enumerable<SignalAdminUncheckedCreateWithoutUserSendingInput>>
    connectOrCreate?: Enumerable<SignalAdminCreateOrConnectWithoutUserSendingInput>
    createMany?: SignalAdminCreateManyUserSendingInputEnvelope
    connect?: Enumerable<SignalAdminWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateipInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TokenUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type TeamUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutUsersInput>, Enumerable<TeamUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type TpostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TpostCreateWithoutUserInput>, Enumerable<TpostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TpostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TpostCreateManyUserInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
    set?: Enumerable<TpostWhereUniqueInput>
    disconnect?: Enumerable<TpostWhereUniqueInput>
    delete?: Enumerable<TpostWhereUniqueInput>
    update?: Enumerable<TpostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TpostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TpostScalarWhereInput>
  }

  export type TeventUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUserInput>, Enumerable<TeventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeventCreateManyUserInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type TreplyUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutUserInput>, Enumerable<TreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TreplyCreateManyUserInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type ApostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ApostCreateWithoutUserInput>, Enumerable<ApostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ApostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ApostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ApostCreateManyUserInputEnvelope
    connect?: Enumerable<ApostWhereUniqueInput>
    set?: Enumerable<ApostWhereUniqueInput>
    disconnect?: Enumerable<ApostWhereUniqueInput>
    delete?: Enumerable<ApostWhereUniqueInput>
    update?: Enumerable<ApostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ApostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ApostScalarWhereInput>
  }

  export type TeamFollowerUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamFollowerCreateWithoutUserInput>, Enumerable<TeamFollowerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamFollowerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeamFollowerUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<TeamFollowerWhereUniqueInput>
    set?: Enumerable<TeamFollowerWhereUniqueInput>
    disconnect?: Enumerable<TeamFollowerWhereUniqueInput>
    delete?: Enumerable<TeamFollowerWhereUniqueInput>
    update?: Enumerable<TeamFollowerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamFollowerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamFollowerScalarWhereInput>
  }

  export type EreplyUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutUserInput>, Enumerable<EreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EreplyCreateManyUserInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type MessageUpdateManyWithoutSentFromInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentFromInput>, Enumerable<MessageUncheckedCreateWithoutSentFromInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentFromInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSentFromInput>
    createMany?: MessageCreateManySentFromInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSentFromInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSentFromInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type MessageUpdateManyWithoutSentToInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentToInput>, Enumerable<MessageUncheckedCreateWithoutSentToInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentToInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSentToInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSentToInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSentToInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ChatUpdateManyWithoutParticipatingUsersInput = {
    create?: XOR<Enumerable<ChatCreateWithoutParticipatingUsersInput>, Enumerable<ChatUncheckedCreateWithoutParticipatingUsersInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutParticipatingUsersInput>
    upsert?: Enumerable<ChatUpsertWithWhereUniqueWithoutParticipatingUsersInput>
    connect?: Enumerable<ChatWhereUniqueInput>
    set?: Enumerable<ChatWhereUniqueInput>
    disconnect?: Enumerable<ChatWhereUniqueInput>
    delete?: Enumerable<ChatWhereUniqueInput>
    update?: Enumerable<ChatUpdateWithWhereUniqueWithoutParticipatingUsersInput>
    updateMany?: Enumerable<ChatUpdateManyWithWhereWithoutParticipatingUsersInput>
    deleteMany?: Enumerable<ChatScalarWhereInput>
  }

  export type ImageUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type AdminMessageUpdateManyWithoutWasReadByInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutWasReadByInput>, Enumerable<AdminMessageUncheckedCreateWithoutWasReadByInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutWasReadByInput>
    upsert?: Enumerable<AdminMessageUpsertWithWhereUniqueWithoutWasReadByInput>
    connect?: Enumerable<AdminMessageWhereUniqueInput>
    set?: Enumerable<AdminMessageWhereUniqueInput>
    disconnect?: Enumerable<AdminMessageWhereUniqueInput>
    delete?: Enumerable<AdminMessageWhereUniqueInput>
    update?: Enumerable<AdminMessageUpdateWithWhereUniqueWithoutWasReadByInput>
    updateMany?: Enumerable<AdminMessageUpdateManyWithWhereWithoutWasReadByInput>
    deleteMany?: Enumerable<AdminMessageScalarWhereInput>
  }

  export type TeventUpdateManyWithoutInvitedUsersInput = {
    create?: XOR<Enumerable<TeventCreateWithoutInvitedUsersInput>, Enumerable<TeventUncheckedCreateWithoutInvitedUsersInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutInvitedUsersInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutInvitedUsersInput>
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutInvitedUsersInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutInvitedUsersInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type UserParticipeEventUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserParticipeEventCreateWithoutUserInput>, Enumerable<UserParticipeEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserParticipeEventCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserParticipeEventUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<UserParticipeEventWhereUniqueInput>
    set?: Enumerable<UserParticipeEventWhereUniqueInput>
    disconnect?: Enumerable<UserParticipeEventWhereUniqueInput>
    delete?: Enumerable<UserParticipeEventWhereUniqueInput>
    update?: Enumerable<UserParticipeEventUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserParticipeEventUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserParticipeEventScalarWhereInput>
  }

  export type AreplyUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutUserInput>, Enumerable<AreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AreplyCreateManyUserInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
    set?: Enumerable<AreplyWhereUniqueInput>
    disconnect?: Enumerable<AreplyWhereUniqueInput>
    delete?: Enumerable<AreplyWhereUniqueInput>
    update?: Enumerable<AreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AreplyScalarWhereInput>
  }

  export type SignalAdminUpdateManyWithoutUserSendingInput = {
    create?: XOR<Enumerable<SignalAdminCreateWithoutUserSendingInput>, Enumerable<SignalAdminUncheckedCreateWithoutUserSendingInput>>
    connectOrCreate?: Enumerable<SignalAdminCreateOrConnectWithoutUserSendingInput>
    upsert?: Enumerable<SignalAdminUpsertWithWhereUniqueWithoutUserSendingInput>
    createMany?: SignalAdminCreateManyUserSendingInputEnvelope
    connect?: Enumerable<SignalAdminWhereUniqueInput>
    set?: Enumerable<SignalAdminWhereUniqueInput>
    disconnect?: Enumerable<SignalAdminWhereUniqueInput>
    delete?: Enumerable<SignalAdminWhereUniqueInput>
    update?: Enumerable<SignalAdminUpdateWithWhereUniqueWithoutUserSendingInput>
    updateMany?: Enumerable<SignalAdminUpdateManyWithWhereWithoutUserSendingInput>
    deleteMany?: Enumerable<SignalAdminScalarWhereInput>
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type TpostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TpostCreateWithoutUserInput>, Enumerable<TpostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TpostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TpostCreateManyUserInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
    set?: Enumerable<TpostWhereUniqueInput>
    disconnect?: Enumerable<TpostWhereUniqueInput>
    delete?: Enumerable<TpostWhereUniqueInput>
    update?: Enumerable<TpostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TpostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TpostScalarWhereInput>
  }

  export type TeventUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUserInput>, Enumerable<TeventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeventCreateManyUserInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type TreplyUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutUserInput>, Enumerable<TreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TreplyCreateManyUserInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type ApostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ApostCreateWithoutUserInput>, Enumerable<ApostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ApostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ApostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ApostCreateManyUserInputEnvelope
    connect?: Enumerable<ApostWhereUniqueInput>
    set?: Enumerable<ApostWhereUniqueInput>
    disconnect?: Enumerable<ApostWhereUniqueInput>
    delete?: Enumerable<ApostWhereUniqueInput>
    update?: Enumerable<ApostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ApostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ApostScalarWhereInput>
  }

  export type EreplyUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutUserInput>, Enumerable<EreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EreplyCreateManyUserInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutSentFromInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentFromInput>, Enumerable<MessageUncheckedCreateWithoutSentFromInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentFromInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSentFromInput>
    createMany?: MessageCreateManySentFromInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSentFromInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSentFromInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ImageUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type AreplyUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutUserInput>, Enumerable<AreplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AreplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AreplyCreateManyUserInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
    set?: Enumerable<AreplyWhereUniqueInput>
    disconnect?: Enumerable<AreplyWhereUniqueInput>
    delete?: Enumerable<AreplyWhereUniqueInput>
    update?: Enumerable<AreplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AreplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AreplyScalarWhereInput>
  }

  export type SignalAdminUncheckedUpdateManyWithoutUserSendingInput = {
    create?: XOR<Enumerable<SignalAdminCreateWithoutUserSendingInput>, Enumerable<SignalAdminUncheckedCreateWithoutUserSendingInput>>
    connectOrCreate?: Enumerable<SignalAdminCreateOrConnectWithoutUserSendingInput>
    upsert?: Enumerable<SignalAdminUpsertWithWhereUniqueWithoutUserSendingInput>
    createMany?: SignalAdminCreateManyUserSendingInputEnvelope
    connect?: Enumerable<SignalAdminWhereUniqueInput>
    set?: Enumerable<SignalAdminWhereUniqueInput>
    disconnect?: Enumerable<SignalAdminWhereUniqueInput>
    delete?: Enumerable<SignalAdminWhereUniqueInput>
    update?: Enumerable<SignalAdminUpdateWithWhereUniqueWithoutUserSendingInput>
    updateMany?: Enumerable<SignalAdminUpdateManyWithWhereWithoutUserSendingInput>
    deleteMany?: Enumerable<SignalAdminScalarWhereInput>
  }

  export type UserCreateManyipInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AreplyCreateNestedManyWithoutApostInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutApostInput>, Enumerable<AreplyUncheckedCreateWithoutApostInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutApostInput>
    createMany?: AreplyCreateManyApostInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutApostsInput = {
    create?: XOR<UserCreateWithoutApostsInput, UserUncheckedCreateWithoutApostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApostsInput
    connect?: UserWhereUniqueInput
  }

  export type AreplyUncheckedCreateNestedManyWithoutApostInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutApostInput>, Enumerable<AreplyUncheckedCreateWithoutApostInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutApostInput>
    createMany?: AreplyCreateManyApostInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
  }

  export type AreplyUpdateManyWithoutApostInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutApostInput>, Enumerable<AreplyUncheckedCreateWithoutApostInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutApostInput>
    upsert?: Enumerable<AreplyUpsertWithWhereUniqueWithoutApostInput>
    createMany?: AreplyCreateManyApostInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
    set?: Enumerable<AreplyWhereUniqueInput>
    disconnect?: Enumerable<AreplyWhereUniqueInput>
    delete?: Enumerable<AreplyWhereUniqueInput>
    update?: Enumerable<AreplyUpdateWithWhereUniqueWithoutApostInput>
    updateMany?: Enumerable<AreplyUpdateManyWithWhereWithoutApostInput>
    deleteMany?: Enumerable<AreplyScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutApostsInput = {
    create?: XOR<UserCreateWithoutApostsInput, UserUncheckedCreateWithoutApostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApostsInput
    upsert?: UserUpsertWithoutApostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutApostsInput, UserUncheckedUpdateWithoutApostsInput>
  }

  export type AreplyUncheckedUpdateManyWithoutApostInput = {
    create?: XOR<Enumerable<AreplyCreateWithoutApostInput>, Enumerable<AreplyUncheckedCreateWithoutApostInput>>
    connectOrCreate?: Enumerable<AreplyCreateOrConnectWithoutApostInput>
    upsert?: Enumerable<AreplyUpsertWithWhereUniqueWithoutApostInput>
    createMany?: AreplyCreateManyApostInputEnvelope
    connect?: Enumerable<AreplyWhereUniqueInput>
    set?: Enumerable<AreplyWhereUniqueInput>
    disconnect?: Enumerable<AreplyWhereUniqueInput>
    delete?: Enumerable<AreplyWhereUniqueInput>
    update?: Enumerable<AreplyUpdateWithWhereUniqueWithoutApostInput>
    updateMany?: Enumerable<AreplyUpdateManyWithWhereWithoutApostInput>
    deleteMany?: Enumerable<AreplyScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAreplyInput = {
    create?: XOR<UserCreateWithoutAreplyInput, UserUncheckedCreateWithoutAreplyInput>
    connectOrCreate?: UserCreateOrConnectWithoutAreplyInput
    connect?: UserWhereUniqueInput
  }

  export type ApostCreateNestedOneWithoutAreplysInput = {
    create?: XOR<ApostCreateWithoutAreplysInput, ApostUncheckedCreateWithoutAreplysInput>
    connectOrCreate?: ApostCreateOrConnectWithoutAreplysInput
    connect?: ApostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAreplyInput = {
    create?: XOR<UserCreateWithoutAreplyInput, UserUncheckedCreateWithoutAreplyInput>
    connectOrCreate?: UserCreateOrConnectWithoutAreplyInput
    upsert?: UserUpsertWithoutAreplyInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAreplyInput, UserUncheckedUpdateWithoutAreplyInput>
  }

  export type ApostUpdateOneRequiredWithoutAreplysInput = {
    create?: XOR<ApostCreateWithoutAreplysInput, ApostUncheckedCreateWithoutAreplysInput>
    connectOrCreate?: ApostCreateOrConnectWithoutAreplysInput
    upsert?: ApostUpsertWithoutAreplysInput
    connect?: ApostWhereUniqueInput
    update?: XOR<ApostUpdateWithoutAreplysInput, ApostUncheckedUpdateWithoutAreplysInput>
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutImagesInput = {
    create?: XOR<UserCreateWithoutImagesInput, UserUncheckedCreateWithoutImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutImagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImagesInput = {
    create?: XOR<UserCreateWithoutImagesInput, UserUncheckedCreateWithoutImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutImagesInput
    upsert?: UserUpsertWithoutImagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutImagesInput, UserUncheckedUpdateWithoutImagesInput>
  }

  export type TeamCreateTeamMastersIDInput = {
    set: Enumerable<string>
  }

  export type TeamCreateTeamMemberIdInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<UserCreateWithoutTeamsInput>, Enumerable<UserUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTeamsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TpostCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TpostCreateWithoutTeamRefInput>, Enumerable<TpostUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutTeamRefInput>
    createMany?: TpostCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
  }

  export type TeventCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TeventCreateWithoutTeamRefInput>, Enumerable<TeventUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutTeamRefInput>
    createMany?: TeventCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type TreplyCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTeamRefInput>, Enumerable<TreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTeamRefInput>
    createMany?: TreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type EreplyCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeamRefInput>, Enumerable<EreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeamRefInput>
    createMany?: EreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type TagCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TagCreateWithoutTeamsInput>, Enumerable<TagUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutTeamsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type TeamFollowerCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamFollowerCreateWithoutTeamInput>, Enumerable<TeamFollowerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamFollowerCreateOrConnectWithoutTeamInput>
    connect?: Enumerable<TeamFollowerWhereUniqueInput>
  }

  export type TpostUncheckedCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TpostCreateWithoutTeamRefInput>, Enumerable<TpostUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutTeamRefInput>
    createMany?: TpostCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
  }

  export type TeventUncheckedCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TeventCreateWithoutTeamRefInput>, Enumerable<TeventUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutTeamRefInput>
    createMany?: TeventCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type TreplyUncheckedCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTeamRefInput>, Enumerable<TreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTeamRefInput>
    createMany?: TreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type EreplyUncheckedCreateNestedManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeamRefInput>, Enumerable<EreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeamRefInput>
    createMany?: EreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type TeamUpdateTeamMastersIDInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TeamUpdateTeamMemberIdInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateManyWithoutTeamsInput = {
    create?: XOR<Enumerable<UserCreateWithoutTeamsInput>, Enumerable<UserUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTeamsInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TpostUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TpostCreateWithoutTeamRefInput>, Enumerable<TpostUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TpostUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TpostCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
    set?: Enumerable<TpostWhereUniqueInput>
    disconnect?: Enumerable<TpostWhereUniqueInput>
    delete?: Enumerable<TpostWhereUniqueInput>
    update?: Enumerable<TpostUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TpostUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TpostScalarWhereInput>
  }

  export type TeventUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TeventCreateWithoutTeamRefInput>, Enumerable<TeventUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TeventCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type TreplyUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTeamRefInput>, Enumerable<TreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type EreplyUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeamRefInput>, Enumerable<EreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: EreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type TagUpdateManyWithoutTeamsInput = {
    create?: XOR<Enumerable<TagCreateWithoutTeamsInput>, Enumerable<TagUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutTeamsInput>
    connect?: Enumerable<TagWhereUniqueInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type TeamFollowerUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamFollowerCreateWithoutTeamInput>, Enumerable<TeamFollowerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamFollowerCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<TeamFollowerUpsertWithWhereUniqueWithoutTeamInput>
    connect?: Enumerable<TeamFollowerWhereUniqueInput>
    set?: Enumerable<TeamFollowerWhereUniqueInput>
    disconnect?: Enumerable<TeamFollowerWhereUniqueInput>
    delete?: Enumerable<TeamFollowerWhereUniqueInput>
    update?: Enumerable<TeamFollowerUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamFollowerUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamFollowerScalarWhereInput>
  }

  export type TpostUncheckedUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TpostCreateWithoutTeamRefInput>, Enumerable<TpostUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TpostCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TpostUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TpostCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TpostWhereUniqueInput>
    set?: Enumerable<TpostWhereUniqueInput>
    disconnect?: Enumerable<TpostWhereUniqueInput>
    delete?: Enumerable<TpostWhereUniqueInput>
    update?: Enumerable<TpostUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TpostUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TpostScalarWhereInput>
  }

  export type TeventUncheckedUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TeventCreateWithoutTeamRefInput>, Enumerable<TeventUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TeventCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type TreplyUncheckedUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTeamRefInput>, Enumerable<TreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: TreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type EreplyUncheckedUpdateManyWithoutTeamRefInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeamRefInput>, Enumerable<EreplyUncheckedCreateWithoutTeamRefInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeamRefInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutTeamRefInput>
    createMany?: EreplyCreateManyTeamRefInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutTeamRefInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutTeamRefInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type TeamCreateManyTeamMastersIDInput = {
    set: Enumerable<string>
  }

  export type TeamCreateManyTeamMemberIdInput = {
    set: Enumerable<string>
  }

  export type TeamCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<TeamCreateWithoutTagsInput>, Enumerable<TeamUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type TeamUpdateManyWithoutTagsInput = {
    create?: XOR<Enumerable<TeamCreateWithoutTagsInput>, Enumerable<TeamUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutTagsInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type TeamCreateNestedManyWithoutTeamFollowersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutTeamFollowersInput>, Enumerable<TeamUncheckedCreateWithoutTeamFollowersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutTeamFollowersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutFollowingInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TeamUpdateManyWithoutTeamFollowersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutTeamFollowersInput>, Enumerable<TeamUncheckedCreateWithoutTeamFollowersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutTeamFollowersInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutTeamFollowersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutTeamFollowersInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutTeamFollowersInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type UserUpdateManyWithoutFollowingInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFollowingInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFollowingInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFollowingInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TreplyCreateNestedManyWithoutTpostInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTpostInput>, Enumerable<TreplyUncheckedCreateWithoutTpostInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTpostInput>
    createMany?: TreplyCreateManyTpostInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type TeamCreateNestedOneWithoutTpostsInput = {
    create?: XOR<TeamCreateWithoutTpostsInput, TeamUncheckedCreateWithoutTpostsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTpostsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTpostsInput = {
    create?: XOR<UserCreateWithoutTpostsInput, UserUncheckedCreateWithoutTpostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTpostsInput
    connect?: UserWhereUniqueInput
  }

  export type TreplyUncheckedCreateNestedManyWithoutTpostInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTpostInput>, Enumerable<TreplyUncheckedCreateWithoutTpostInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTpostInput>
    createMany?: TreplyCreateManyTpostInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
  }

  export type TreplyUpdateManyWithoutTpostInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTpostInput>, Enumerable<TreplyUncheckedCreateWithoutTpostInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTpostInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutTpostInput>
    createMany?: TreplyCreateManyTpostInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutTpostInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutTpostInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type TeamUpdateOneRequiredWithoutTpostsInput = {
    create?: XOR<TeamCreateWithoutTpostsInput, TeamUncheckedCreateWithoutTpostsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTpostsInput
    upsert?: TeamUpsertWithoutTpostsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutTpostsInput, TeamUncheckedUpdateWithoutTpostsInput>
  }

  export type UserUpdateOneRequiredWithoutTpostsInput = {
    create?: XOR<UserCreateWithoutTpostsInput, UserUncheckedCreateWithoutTpostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTpostsInput
    upsert?: UserUpsertWithoutTpostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTpostsInput, UserUncheckedUpdateWithoutTpostsInput>
  }

  export type TreplyUncheckedUpdateManyWithoutTpostInput = {
    create?: XOR<Enumerable<TreplyCreateWithoutTpostInput>, Enumerable<TreplyUncheckedCreateWithoutTpostInput>>
    connectOrCreate?: Enumerable<TreplyCreateOrConnectWithoutTpostInput>
    upsert?: Enumerable<TreplyUpsertWithWhereUniqueWithoutTpostInput>
    createMany?: TreplyCreateManyTpostInputEnvelope
    connect?: Enumerable<TreplyWhereUniqueInput>
    set?: Enumerable<TreplyWhereUniqueInput>
    disconnect?: Enumerable<TreplyWhereUniqueInput>
    delete?: Enumerable<TreplyWhereUniqueInput>
    update?: Enumerable<TreplyUpdateWithWhereUniqueWithoutTpostInput>
    updateMany?: Enumerable<TreplyUpdateManyWithWhereWithoutTpostInput>
    deleteMany?: Enumerable<TreplyScalarWhereInput>
  }

  export type EreplyCreateNestedManyWithoutTeventInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeventInput>, Enumerable<EreplyUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeventInput>
    createMany?: EreplyCreateManyTeventInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type TeamCreateNestedOneWithoutTeventsInput = {
    create?: XOR<TeamCreateWithoutTeventsInput, TeamUncheckedCreateWithoutTeventsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeventsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeventsInput = {
    create?: XOR<UserCreateWithoutTeventsInput, UserUncheckedCreateWithoutTeventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutInvitedInEventInput = {
    create?: XOR<Enumerable<UserCreateWithoutInvitedInEventInput>, Enumerable<UserUncheckedCreateWithoutInvitedInEventInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutInvitedInEventInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserParticipeEventCreateNestedManyWithoutTeventInput = {
    create?: XOR<Enumerable<UserParticipeEventCreateWithoutTeventInput>, Enumerable<UserParticipeEventUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<UserParticipeEventCreateOrConnectWithoutTeventInput>
    connect?: Enumerable<UserParticipeEventWhereUniqueInput>
  }

  export type EreplyUncheckedCreateNestedManyWithoutTeventInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeventInput>, Enumerable<EreplyUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeventInput>
    createMany?: EreplyCreateManyTeventInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
  }

  export type EreplyUpdateManyWithoutTeventInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeventInput>, Enumerable<EreplyUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeventInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutTeventInput>
    createMany?: EreplyCreateManyTeventInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutTeventInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutTeventInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type TeamUpdateOneRequiredWithoutTeventsInput = {
    create?: XOR<TeamCreateWithoutTeventsInput, TeamUncheckedCreateWithoutTeventsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeventsInput
    upsert?: TeamUpsertWithoutTeventsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutTeventsInput, TeamUncheckedUpdateWithoutTeventsInput>
  }

  export type UserUpdateOneRequiredWithoutTeventsInput = {
    create?: XOR<UserCreateWithoutTeventsInput, UserUncheckedCreateWithoutTeventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeventsInput
    upsert?: UserUpsertWithoutTeventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTeventsInput, UserUncheckedUpdateWithoutTeventsInput>
  }

  export type UserUpdateManyWithoutInvitedInEventInput = {
    create?: XOR<Enumerable<UserCreateWithoutInvitedInEventInput>, Enumerable<UserUncheckedCreateWithoutInvitedInEventInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutInvitedInEventInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutInvitedInEventInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutInvitedInEventInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutInvitedInEventInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserParticipeEventUpdateManyWithoutTeventInput = {
    create?: XOR<Enumerable<UserParticipeEventCreateWithoutTeventInput>, Enumerable<UserParticipeEventUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<UserParticipeEventCreateOrConnectWithoutTeventInput>
    upsert?: Enumerable<UserParticipeEventUpsertWithWhereUniqueWithoutTeventInput>
    connect?: Enumerable<UserParticipeEventWhereUniqueInput>
    set?: Enumerable<UserParticipeEventWhereUniqueInput>
    disconnect?: Enumerable<UserParticipeEventWhereUniqueInput>
    delete?: Enumerable<UserParticipeEventWhereUniqueInput>
    update?: Enumerable<UserParticipeEventUpdateWithWhereUniqueWithoutTeventInput>
    updateMany?: Enumerable<UserParticipeEventUpdateManyWithWhereWithoutTeventInput>
    deleteMany?: Enumerable<UserParticipeEventScalarWhereInput>
  }

  export type EreplyUncheckedUpdateManyWithoutTeventInput = {
    create?: XOR<Enumerable<EreplyCreateWithoutTeventInput>, Enumerable<EreplyUncheckedCreateWithoutTeventInput>>
    connectOrCreate?: Enumerable<EreplyCreateOrConnectWithoutTeventInput>
    upsert?: Enumerable<EreplyUpsertWithWhereUniqueWithoutTeventInput>
    createMany?: EreplyCreateManyTeventInputEnvelope
    connect?: Enumerable<EreplyWhereUniqueInput>
    set?: Enumerable<EreplyWhereUniqueInput>
    disconnect?: Enumerable<EreplyWhereUniqueInput>
    delete?: Enumerable<EreplyWhereUniqueInput>
    update?: Enumerable<EreplyUpdateWithWhereUniqueWithoutTeventInput>
    updateMany?: Enumerable<EreplyUpdateManyWithWhereWithoutTeventInput>
    deleteMany?: Enumerable<EreplyScalarWhereInput>
  }

  export type TeventCreateNestedManyWithoutUsersParticipeEventInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUsersParticipeEventInput>, Enumerable<TeventUncheckedCreateWithoutUsersParticipeEventInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUsersParticipeEventInput>
    connect?: Enumerable<TeventWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutUserPartInEventsInput = {
    create?: XOR<Enumerable<UserCreateWithoutUserPartInEventsInput>, Enumerable<UserUncheckedCreateWithoutUserPartInEventsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserPartInEventsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TeventUpdateManyWithoutUsersParticipeEventInput = {
    create?: XOR<Enumerable<TeventCreateWithoutUsersParticipeEventInput>, Enumerable<TeventUncheckedCreateWithoutUsersParticipeEventInput>>
    connectOrCreate?: Enumerable<TeventCreateOrConnectWithoutUsersParticipeEventInput>
    upsert?: Enumerable<TeventUpsertWithWhereUniqueWithoutUsersParticipeEventInput>
    connect?: Enumerable<TeventWhereUniqueInput>
    set?: Enumerable<TeventWhereUniqueInput>
    disconnect?: Enumerable<TeventWhereUniqueInput>
    delete?: Enumerable<TeventWhereUniqueInput>
    update?: Enumerable<TeventUpdateWithWhereUniqueWithoutUsersParticipeEventInput>
    updateMany?: Enumerable<TeventUpdateManyWithWhereWithoutUsersParticipeEventInput>
    deleteMany?: Enumerable<TeventScalarWhereInput>
  }

  export type UserUpdateManyWithoutUserPartInEventsInput = {
    create?: XOR<Enumerable<UserCreateWithoutUserPartInEventsInput>, Enumerable<UserUncheckedCreateWithoutUserPartInEventsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutUserPartInEventsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutUserPartInEventsInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutUserPartInEventsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutUserPartInEventsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TeamCreateNestedOneWithoutErepliesInput = {
    create?: XOR<TeamCreateWithoutErepliesInput, TeamUncheckedCreateWithoutErepliesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutErepliesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutErepliesInput = {
    create?: XOR<UserCreateWithoutErepliesInput, UserUncheckedCreateWithoutErepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutErepliesInput
    connect?: UserWhereUniqueInput
  }

  export type TeventCreateNestedOneWithoutEreplysInput = {
    create?: XOR<TeventCreateWithoutEreplysInput, TeventUncheckedCreateWithoutEreplysInput>
    connectOrCreate?: TeventCreateOrConnectWithoutEreplysInput
    connect?: TeventWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutErepliesInput = {
    create?: XOR<TeamCreateWithoutErepliesInput, TeamUncheckedCreateWithoutErepliesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutErepliesInput
    upsert?: TeamUpsertWithoutErepliesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutErepliesInput, TeamUncheckedUpdateWithoutErepliesInput>
  }

  export type UserUpdateOneRequiredWithoutErepliesInput = {
    create?: XOR<UserCreateWithoutErepliesInput, UserUncheckedCreateWithoutErepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutErepliesInput
    upsert?: UserUpsertWithoutErepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutErepliesInput, UserUncheckedUpdateWithoutErepliesInput>
  }

  export type TeventUpdateOneRequiredWithoutEreplysInput = {
    create?: XOR<TeventCreateWithoutEreplysInput, TeventUncheckedCreateWithoutEreplysInput>
    connectOrCreate?: TeventCreateOrConnectWithoutEreplysInput
    upsert?: TeventUpsertWithoutEreplysInput
    connect?: TeventWhereUniqueInput
    update?: XOR<TeventUpdateWithoutEreplysInput, TeventUncheckedUpdateWithoutEreplysInput>
  }

  export type TpostCreateNestedOneWithoutTreplysInput = {
    create?: XOR<TpostCreateWithoutTreplysInput, TpostUncheckedCreateWithoutTreplysInput>
    connectOrCreate?: TpostCreateOrConnectWithoutTreplysInput
    connect?: TpostWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTrepliesInput = {
    create?: XOR<TeamCreateWithoutTrepliesInput, TeamUncheckedCreateWithoutTrepliesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTrepliesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrepliesInput = {
    create?: XOR<UserCreateWithoutTrepliesInput, UserUncheckedCreateWithoutTrepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrepliesInput
    connect?: UserWhereUniqueInput
  }

  export type TpostUpdateOneRequiredWithoutTreplysInput = {
    create?: XOR<TpostCreateWithoutTreplysInput, TpostUncheckedCreateWithoutTreplysInput>
    connectOrCreate?: TpostCreateOrConnectWithoutTreplysInput
    upsert?: TpostUpsertWithoutTreplysInput
    connect?: TpostWhereUniqueInput
    update?: XOR<TpostUpdateWithoutTreplysInput, TpostUncheckedUpdateWithoutTreplysInput>
  }

  export type TeamUpdateOneRequiredWithoutTrepliesInput = {
    create?: XOR<TeamCreateWithoutTrepliesInput, TeamUncheckedCreateWithoutTrepliesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTrepliesInput
    upsert?: TeamUpsertWithoutTrepliesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutTrepliesInput, TeamUncheckedUpdateWithoutTrepliesInput>
  }

  export type UserUpdateOneRequiredWithoutTrepliesInput = {
    create?: XOR<UserCreateWithoutTrepliesInput, UserUncheckedCreateWithoutTrepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrepliesInput
    upsert?: UserUpsertWithoutTrepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTrepliesInput, UserUncheckedUpdateWithoutTrepliesInput>
  }

  export type MessageCreatesentToIdInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReceivedMessagesInput = {
    create?: XOR<Enumerable<UserCreateWithoutReceivedMessagesInput>, Enumerable<UserUncheckedCreateWithoutReceivedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReceivedMessagesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type MessageUpdatesentToIdInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateManyWithoutReceivedMessagesInput = {
    create?: XOR<Enumerable<UserCreateWithoutReceivedMessagesInput>, Enumerable<UserUncheckedCreateWithoutReceivedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReceivedMessagesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutReceivedMessagesInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutReceivedMessagesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutReceivedMessagesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ChatUpdateOneRequiredWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageCreateManysentToIdInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutSignalsToAdminInput = {
    create?: XOR<UserCreateWithoutSignalsToAdminInput, UserUncheckedCreateWithoutSignalsToAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalsToAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSignalsToAdminInput = {
    create?: XOR<UserCreateWithoutSignalsToAdminInput, UserUncheckedCreateWithoutSignalsToAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalsToAdminInput
    upsert?: UserUpsertWithoutSignalsToAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSignalsToAdminInput, UserUncheckedUpdateWithoutSignalsToAdminInput>
  }

  export type AdminMessageCreateNestedManyWithoutSentInInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutSentInInput>, Enumerable<AdminMessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutSentInInput>
    createMany?: AdminMessageCreateManySentInInputEnvelope
    connect?: Enumerable<AdminMessageWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutSentInInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentInInput>, Enumerable<MessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentInInput>
    createMany?: MessageCreateManySentInInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutParticipatesInInput = {
    create?: XOR<Enumerable<UserCreateWithoutParticipatesInInput>, Enumerable<UserUncheckedCreateWithoutParticipatesInInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutParticipatesInInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type AdminMessageUncheckedCreateNestedManyWithoutSentInInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutSentInInput>, Enumerable<AdminMessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutSentInInput>
    createMany?: AdminMessageCreateManySentInInputEnvelope
    connect?: Enumerable<AdminMessageWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutSentInInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentInInput>, Enumerable<MessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentInInput>
    createMany?: MessageCreateManySentInInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type AdminMessageUpdateManyWithoutSentInInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutSentInInput>, Enumerable<AdminMessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutSentInInput>
    upsert?: Enumerable<AdminMessageUpsertWithWhereUniqueWithoutSentInInput>
    createMany?: AdminMessageCreateManySentInInputEnvelope
    connect?: Enumerable<AdminMessageWhereUniqueInput>
    set?: Enumerable<AdminMessageWhereUniqueInput>
    disconnect?: Enumerable<AdminMessageWhereUniqueInput>
    delete?: Enumerable<AdminMessageWhereUniqueInput>
    update?: Enumerable<AdminMessageUpdateWithWhereUniqueWithoutSentInInput>
    updateMany?: Enumerable<AdminMessageUpdateManyWithWhereWithoutSentInInput>
    deleteMany?: Enumerable<AdminMessageScalarWhereInput>
  }

  export type MessageUpdateManyWithoutSentInInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentInInput>, Enumerable<MessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentInInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSentInInput>
    createMany?: MessageCreateManySentInInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSentInInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSentInInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type UserUpdateManyWithoutParticipatesInInput = {
    create?: XOR<Enumerable<UserCreateWithoutParticipatesInInput>, Enumerable<UserUncheckedCreateWithoutParticipatesInInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutParticipatesInInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutParticipatesInInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutParticipatesInInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutParticipatesInInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type AdminMessageUncheckedUpdateManyWithoutSentInInput = {
    create?: XOR<Enumerable<AdminMessageCreateWithoutSentInInput>, Enumerable<AdminMessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<AdminMessageCreateOrConnectWithoutSentInInput>
    upsert?: Enumerable<AdminMessageUpsertWithWhereUniqueWithoutSentInInput>
    createMany?: AdminMessageCreateManySentInInputEnvelope
    connect?: Enumerable<AdminMessageWhereUniqueInput>
    set?: Enumerable<AdminMessageWhereUniqueInput>
    disconnect?: Enumerable<AdminMessageWhereUniqueInput>
    delete?: Enumerable<AdminMessageWhereUniqueInput>
    update?: Enumerable<AdminMessageUpdateWithWhereUniqueWithoutSentInInput>
    updateMany?: Enumerable<AdminMessageUpdateManyWithWhereWithoutSentInInput>
    deleteMany?: Enumerable<AdminMessageScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutSentInInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSentInInput>, Enumerable<MessageUncheckedCreateWithoutSentInInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSentInInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSentInInput>
    createMany?: MessageCreateManySentInInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSentInInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSentInInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ChatCreateNestedOneWithoutAdminMessagesInput = {
    create?: XOR<ChatCreateWithoutAdminMessagesInput, ChatUncheckedCreateWithoutAdminMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutAdminMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutHasReadInput = {
    create?: XOR<Enumerable<UserCreateWithoutHasReadInput>, Enumerable<UserUncheckedCreateWithoutHasReadInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutHasReadInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ChatUpdateOneRequiredWithoutAdminMessagesInput = {
    create?: XOR<ChatCreateWithoutAdminMessagesInput, ChatUncheckedCreateWithoutAdminMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutAdminMessagesInput
    upsert?: ChatUpsertWithoutAdminMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<ChatUpdateWithoutAdminMessagesInput, ChatUncheckedUpdateWithoutAdminMessagesInput>
  }

  export type UserUpdateManyWithoutHasReadInput = {
    create?: XOR<Enumerable<UserCreateWithoutHasReadInput>, Enumerable<UserUncheckedCreateWithoutHasReadInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutHasReadInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutHasReadInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutHasReadInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutHasReadInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type TokenCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: Enumerable<TokenCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    emailIsVerified?: boolean | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    emailIsVerified?: boolean | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutUsersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type TpostCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    treplys?: TreplyCreateNestedManyWithoutTpostInput
    teamRef: TeamCreateNestedOneWithoutTpostsInput
  }

  export type TpostUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamId: string
    treplys?: TreplyUncheckedCreateNestedManyWithoutTpostInput
  }

  export type TpostCreateOrConnectWithoutUserInput = {
    where: TpostWhereUniqueInput
    create: XOR<TpostCreateWithoutUserInput, TpostUncheckedCreateWithoutUserInput>
  }

  export type TpostCreateManyUserInputEnvelope = {
    data: Enumerable<TpostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TeventCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyCreateNestedManyWithoutTeventInput
    teamRef: TeamCreateNestedOneWithoutTeventsInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventCreateNestedManyWithoutTeventInput
  }

  export type TeventUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyUncheckedCreateNestedManyWithoutTeventInput
  }

  export type TeventCreateOrConnectWithoutUserInput = {
    where: TeventWhereUniqueInput
    create: XOR<TeventCreateWithoutUserInput, TeventUncheckedCreateWithoutUserInput>
  }

  export type TeventCreateManyUserInputEnvelope = {
    data: Enumerable<TeventCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TreplyCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpost: TpostCreateNestedOneWithoutTreplysInput
    teamRef: TeamCreateNestedOneWithoutTrepliesInput
  }

  export type TreplyUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    teamId: string
  }

  export type TreplyCreateOrConnectWithoutUserInput = {
    where: TreplyWhereUniqueInput
    create: XOR<TreplyCreateWithoutUserInput, TreplyUncheckedCreateWithoutUserInput>
  }

  export type TreplyCreateManyUserInputEnvelope = {
    data: Enumerable<TreplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ApostCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    areplys?: AreplyCreateNestedManyWithoutApostInput
  }

  export type ApostUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    areplys?: AreplyUncheckedCreateNestedManyWithoutApostInput
  }

  export type ApostCreateOrConnectWithoutUserInput = {
    where: ApostWhereUniqueInput
    create: XOR<ApostCreateWithoutUserInput, ApostUncheckedCreateWithoutUserInput>
  }

  export type ApostCreateManyUserInputEnvelope = {
    data: Enumerable<ApostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TeamFollowerCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
    team?: TeamCreateNestedManyWithoutTeamFollowersInput
  }

  export type TeamFollowerUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
  }

  export type TeamFollowerCreateOrConnectWithoutUserInput = {
    where: TeamFollowerWhereUniqueInput
    create: XOR<TeamFollowerCreateWithoutUserInput, TeamFollowerUncheckedCreateWithoutUserInput>
  }

  export type EreplyCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamRef: TeamCreateNestedOneWithoutErepliesInput
    tevent: TeventCreateNestedOneWithoutEreplysInput
  }

  export type EreplyUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    teamId: string
  }

  export type EreplyCreateOrConnectWithoutUserInput = {
    where: EreplyWhereUniqueInput
    create: XOR<EreplyCreateWithoutUserInput, EreplyUncheckedCreateWithoutUserInput>
  }

  export type EreplyCreateManyUserInputEnvelope = {
    data: Enumerable<EreplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSentFromInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
    sentTo?: UserCreateNestedManyWithoutReceivedMessagesInput
    sentIn: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSentFromInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentInId: string
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
  }

  export type MessageCreateOrConnectWithoutSentFromInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSentFromInput, MessageUncheckedCreateWithoutSentFromInput>
  }

  export type MessageCreateManySentFromInputEnvelope = {
    data: Enumerable<MessageCreateManySentFromInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSentToInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
    sentFrom: UserCreateNestedOneWithoutSentMessagesInput
    sentIn: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSentToInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentFromId: string
    sentInId: string
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
  }

  export type MessageCreateOrConnectWithoutSentToInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSentToInput, MessageUncheckedCreateWithoutSentToInput>
  }

  export type ChatCreateWithoutParticipatingUsersInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageCreateNestedManyWithoutSentInInput
    messages?: MessageCreateNestedManyWithoutSentInInput
  }

  export type ChatUncheckedCreateWithoutParticipatingUsersInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageUncheckedCreateNestedManyWithoutSentInInput
    messages?: MessageUncheckedCreateNestedManyWithoutSentInInput
  }

  export type ChatCreateOrConnectWithoutParticipatingUsersInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutParticipatingUsersInput, ChatUncheckedCreateWithoutParticipatingUsersInput>
  }

  export type ImageCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    asset_id: string
    url: string
  }

  export type ImageUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    asset_id: string
    url: string
  }

  export type ImageCreateOrConnectWithoutUserInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
  }

  export type ImageCreateManyUserInputEnvelope = {
    data: Enumerable<ImageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AdminMessageCreateWithoutWasReadByInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentIn: ChatCreateNestedOneWithoutAdminMessagesInput
  }

  export type AdminMessageUncheckedCreateWithoutWasReadByInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentInId: string
  }

  export type AdminMessageCreateOrConnectWithoutWasReadByInput = {
    where: AdminMessageWhereUniqueInput
    create: XOR<AdminMessageCreateWithoutWasReadByInput, AdminMessageUncheckedCreateWithoutWasReadByInput>
  }

  export type TeventCreateWithoutInvitedUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyCreateNestedManyWithoutTeventInput
    teamRef: TeamCreateNestedOneWithoutTeventsInput
    user: UserCreateNestedOneWithoutTeventsInput
    usersParticipeEvent?: UserParticipeEventCreateNestedManyWithoutTeventInput
  }

  export type TeventUncheckedCreateWithoutInvitedUsersInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyUncheckedCreateNestedManyWithoutTeventInput
  }

  export type TeventCreateOrConnectWithoutInvitedUsersInput = {
    where: TeventWhereUniqueInput
    create: XOR<TeventCreateWithoutInvitedUsersInput, TeventUncheckedCreateWithoutInvitedUsersInput>
  }

  export type UserParticipeEventCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
    tevent?: TeventCreateNestedManyWithoutUsersParticipeEventInput
  }

  export type UserParticipeEventUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
  }

  export type UserParticipeEventCreateOrConnectWithoutUserInput = {
    where: UserParticipeEventWhereUniqueInput
    create: XOR<UserParticipeEventCreateWithoutUserInput, UserParticipeEventUncheckedCreateWithoutUserInput>
  }

  export type AreplyCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    apost: ApostCreateNestedOneWithoutAreplysInput
  }

  export type AreplyUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    apostId: string
  }

  export type AreplyCreateOrConnectWithoutUserInput = {
    where: AreplyWhereUniqueInput
    create: XOR<AreplyCreateWithoutUserInput, AreplyUncheckedCreateWithoutUserInput>
  }

  export type AreplyCreateManyUserInputEnvelope = {
    data: Enumerable<AreplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SignalAdminCreateWithoutUserSendingInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
  }

  export type SignalAdminUncheckedCreateWithoutUserSendingInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
  }

  export type SignalAdminCreateOrConnectWithoutUserSendingInput = {
    where: SignalAdminWhereUniqueInput
    create: XOR<SignalAdminCreateWithoutUserSendingInput, SignalAdminUncheckedCreateWithoutUserSendingInput>
  }

  export type SignalAdminCreateManyUserSendingInputEnvelope = {
    data: Enumerable<SignalAdminCreateManyUserSendingInput>
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutTokensInput>
  }

  export type TokenScalarWhereInput = {
    AND?: Enumerable<TokenScalarWhereInput>
    OR?: Enumerable<TokenScalarWhereInput>
    NOT?: Enumerable<TokenScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hashedToken?: StringFilter | string
    type?: StringFilter | string
    expiresAt?: DateTimeFilter | Date | string
    sentTo?: StringFilter | string
    userId?: StringFilter | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    expiresAt?: DateTimeNullableFilter | Date | string | null
    handle?: StringFilter | string
    hashedSessionToken?: StringNullableFilter | string | null
    antiCSRFToken?: StringNullableFilter | string | null
    publicData?: StringNullableFilter | string | null
    privateData?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    userId?: StringFilter | string
    emailIsVerified?: BoolNullableFilter | boolean | null
  }

  export type TeamUpsertWithWhereUniqueWithoutUsersInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutUsersInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateManyWithWhereWithoutUsersInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamsInput>
  }

  export type TeamScalarWhereInput = {
    AND?: Enumerable<TeamScalarWhereInput>
    OR?: Enumerable<TeamScalarWhereInput>
    NOT?: Enumerable<TeamScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    description?: StringFilter | string
    corpus?: StringFilter | string
    anneeCreation?: IntFilter | number
    secteur?: StringFilter | string
    typeOrg?: StringFilter | string
    taille?: IntFilter | number
    teamLatitude?: FloatFilter | number
    teamLongitude?: FloatFilter | number
    image?: StringFilter | string
    imageCover?: StringFilter | string
    TeamMastersID?: StringNullableListFilter
    TeamMemberId?: StringNullableListFilter
    public?: BoolFilter | boolean
    findIndex?: IntFilter | number
    publishDemand?: BoolFilter | boolean
  }

  export type TpostUpsertWithWhereUniqueWithoutUserInput = {
    where: TpostWhereUniqueInput
    update: XOR<TpostUpdateWithoutUserInput, TpostUncheckedUpdateWithoutUserInput>
    create: XOR<TpostCreateWithoutUserInput, TpostUncheckedCreateWithoutUserInput>
  }

  export type TpostUpdateWithWhereUniqueWithoutUserInput = {
    where: TpostWhereUniqueInput
    data: XOR<TpostUpdateWithoutUserInput, TpostUncheckedUpdateWithoutUserInput>
  }

  export type TpostUpdateManyWithWhereWithoutUserInput = {
    where: TpostScalarWhereInput
    data: XOR<TpostUpdateManyMutationInput, TpostUncheckedUpdateManyWithoutTpostsInput>
  }

  export type TpostScalarWhereInput = {
    AND?: Enumerable<TpostScalarWhereInput>
    OR?: Enumerable<TpostScalarWhereInput>
    NOT?: Enumerable<TpostScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type TeventUpsertWithWhereUniqueWithoutUserInput = {
    where: TeventWhereUniqueInput
    update: XOR<TeventUpdateWithoutUserInput, TeventUncheckedUpdateWithoutUserInput>
    create: XOR<TeventCreateWithoutUserInput, TeventUncheckedCreateWithoutUserInput>
  }

  export type TeventUpdateWithWhereUniqueWithoutUserInput = {
    where: TeventWhereUniqueInput
    data: XOR<TeventUpdateWithoutUserInput, TeventUncheckedUpdateWithoutUserInput>
  }

  export type TeventUpdateManyWithWhereWithoutUserInput = {
    where: TeventScalarWhereInput
    data: XOR<TeventUpdateManyMutationInput, TeventUncheckedUpdateManyWithoutTeventsInput>
  }

  export type TeventScalarWhereInput = {
    AND?: Enumerable<TeventScalarWhereInput>
    OR?: Enumerable<TeventScalarWhereInput>
    NOT?: Enumerable<TeventScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subject?: StringFilter | string
    startAt?: DateTimeFilter | Date | string
    endsAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    maxParticipants?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
    eventLat?: FloatFilter | number
    eventLon?: FloatFilter | number
    locationDescription?: StringNullableFilter | string | null
    visioPres?: BoolFilter | boolean
    linkVisio?: StringNullableFilter | string | null
    visioCode?: StringNullableFilter | string | null
    infoPostscritum?: StringNullableFilter | string | null
    isCancel?: BoolFilter | boolean
    visible?: BoolFilter | boolean
    postScriptWriterId?: StringNullableFilter | string | null
    recallEmailSent?: BoolFilter | boolean
  }

  export type TreplyUpsertWithWhereUniqueWithoutUserInput = {
    where: TreplyWhereUniqueInput
    update: XOR<TreplyUpdateWithoutUserInput, TreplyUncheckedUpdateWithoutUserInput>
    create: XOR<TreplyCreateWithoutUserInput, TreplyUncheckedCreateWithoutUserInput>
  }

  export type TreplyUpdateWithWhereUniqueWithoutUserInput = {
    where: TreplyWhereUniqueInput
    data: XOR<TreplyUpdateWithoutUserInput, TreplyUncheckedUpdateWithoutUserInput>
  }

  export type TreplyUpdateManyWithWhereWithoutUserInput = {
    where: TreplyScalarWhereInput
    data: XOR<TreplyUpdateManyMutationInput, TreplyUncheckedUpdateManyWithoutTrepliesInput>
  }

  export type TreplyScalarWhereInput = {
    AND?: Enumerable<TreplyScalarWhereInput>
    OR?: Enumerable<TreplyScalarWhereInput>
    NOT?: Enumerable<TreplyScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    tpostId?: StringFilter | string
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type ApostUpsertWithWhereUniqueWithoutUserInput = {
    where: ApostWhereUniqueInput
    update: XOR<ApostUpdateWithoutUserInput, ApostUncheckedUpdateWithoutUserInput>
    create: XOR<ApostCreateWithoutUserInput, ApostUncheckedCreateWithoutUserInput>
  }

  export type ApostUpdateWithWhereUniqueWithoutUserInput = {
    where: ApostWhereUniqueInput
    data: XOR<ApostUpdateWithoutUserInput, ApostUncheckedUpdateWithoutUserInput>
  }

  export type ApostUpdateManyWithWhereWithoutUserInput = {
    where: ApostScalarWhereInput
    data: XOR<ApostUpdateManyMutationInput, ApostUncheckedUpdateManyWithoutApostsInput>
  }

  export type ApostScalarWhereInput = {
    AND?: Enumerable<ApostScalarWhereInput>
    OR?: Enumerable<ApostScalarWhereInput>
    NOT?: Enumerable<ApostScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    userId?: StringFilter | string
  }

  export type TeamFollowerUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamFollowerWhereUniqueInput
    update: XOR<TeamFollowerUpdateWithoutUserInput, TeamFollowerUncheckedUpdateWithoutUserInput>
    create: XOR<TeamFollowerCreateWithoutUserInput, TeamFollowerUncheckedCreateWithoutUserInput>
  }

  export type TeamFollowerUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamFollowerWhereUniqueInput
    data: XOR<TeamFollowerUpdateWithoutUserInput, TeamFollowerUncheckedUpdateWithoutUserInput>
  }

  export type TeamFollowerUpdateManyWithWhereWithoutUserInput = {
    where: TeamFollowerScalarWhereInput
    data: XOR<TeamFollowerUpdateManyMutationInput, TeamFollowerUncheckedUpdateManyWithoutFollowingInput>
  }

  export type TeamFollowerScalarWhereInput = {
    AND?: Enumerable<TeamFollowerScalarWhereInput>
    OR?: Enumerable<TeamFollowerScalarWhereInput>
    NOT?: Enumerable<TeamFollowerScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    teamId?: StringFilter | string
    followerId?: StringFilter | string
  }

  export type EreplyUpsertWithWhereUniqueWithoutUserInput = {
    where: EreplyWhereUniqueInput
    update: XOR<EreplyUpdateWithoutUserInput, EreplyUncheckedUpdateWithoutUserInput>
    create: XOR<EreplyCreateWithoutUserInput, EreplyUncheckedCreateWithoutUserInput>
  }

  export type EreplyUpdateWithWhereUniqueWithoutUserInput = {
    where: EreplyWhereUniqueInput
    data: XOR<EreplyUpdateWithoutUserInput, EreplyUncheckedUpdateWithoutUserInput>
  }

  export type EreplyUpdateManyWithWhereWithoutUserInput = {
    where: EreplyScalarWhereInput
    data: XOR<EreplyUpdateManyMutationInput, EreplyUncheckedUpdateManyWithoutErepliesInput>
  }

  export type EreplyScalarWhereInput = {
    AND?: Enumerable<EreplyScalarWhereInput>
    OR?: Enumerable<EreplyScalarWhereInput>
    NOT?: Enumerable<EreplyScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    teventId?: StringFilter | string
    teamId?: StringFilter | string
    userId?: StringFilter | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSentFromInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSentFromInput, MessageUncheckedUpdateWithoutSentFromInput>
    create: XOR<MessageCreateWithoutSentFromInput, MessageUncheckedCreateWithoutSentFromInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSentFromInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSentFromInput, MessageUncheckedUpdateWithoutSentFromInput>
  }

  export type MessageUpdateManyWithWhereWithoutSentFromInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSentMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: StringFilter | string
    sentAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    htmlContent?: StringNullableFilter | string | null
    sentFromId?: StringFilter | string
    sentToId?: StringNullableListFilter
    sentInId?: StringFilter | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSentToInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSentToInput, MessageUncheckedUpdateWithoutSentToInput>
    create: XOR<MessageCreateWithoutSentToInput, MessageUncheckedCreateWithoutSentToInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSentToInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSentToInput, MessageUncheckedUpdateWithoutSentToInput>
  }

  export type MessageUpdateManyWithWhereWithoutSentToInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceivedMessagesInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutParticipatingUsersInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutParticipatingUsersInput, ChatUncheckedUpdateWithoutParticipatingUsersInput>
    create: XOR<ChatCreateWithoutParticipatingUsersInput, ChatUncheckedCreateWithoutParticipatingUsersInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutParticipatingUsersInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutParticipatingUsersInput, ChatUncheckedUpdateWithoutParticipatingUsersInput>
  }

  export type ChatUpdateManyWithWhereWithoutParticipatingUsersInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutParticipatesInInput>
  }

  export type ChatScalarWhereInput = {
    AND?: Enumerable<ChatScalarWhereInput>
    OR?: Enumerable<ChatScalarWhereInput>
    NOT?: Enumerable<ChatScalarWhereInput>
    id?: StringFilter | string
    subject?: StringFilter | string
    private?: BoolFilter | boolean
    IsDeletedByAdmin?: BoolFilter | boolean
  }

  export type ImageUpsertWithWhereUniqueWithoutUserInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutUserInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
  }

  export type ImageUpdateManyWithWhereWithoutUserInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutImagesInput>
  }

  export type ImageScalarWhereInput = {
    AND?: Enumerable<ImageScalarWhereInput>
    OR?: Enumerable<ImageScalarWhereInput>
    NOT?: Enumerable<ImageScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    asset_id?: StringFilter | string
    url?: StringFilter | string
  }

  export type AdminMessageUpsertWithWhereUniqueWithoutWasReadByInput = {
    where: AdminMessageWhereUniqueInput
    update: XOR<AdminMessageUpdateWithoutWasReadByInput, AdminMessageUncheckedUpdateWithoutWasReadByInput>
    create: XOR<AdminMessageCreateWithoutWasReadByInput, AdminMessageUncheckedCreateWithoutWasReadByInput>
  }

  export type AdminMessageUpdateWithWhereUniqueWithoutWasReadByInput = {
    where: AdminMessageWhereUniqueInput
    data: XOR<AdminMessageUpdateWithoutWasReadByInput, AdminMessageUncheckedUpdateWithoutWasReadByInput>
  }

  export type AdminMessageUpdateManyWithWhereWithoutWasReadByInput = {
    where: AdminMessageScalarWhereInput
    data: XOR<AdminMessageUpdateManyMutationInput, AdminMessageUncheckedUpdateManyWithoutHasReadInput>
  }

  export type AdminMessageScalarWhereInput = {
    AND?: Enumerable<AdminMessageScalarWhereInput>
    OR?: Enumerable<AdminMessageScalarWhereInput>
    NOT?: Enumerable<AdminMessageScalarWhereInput>
    id?: StringFilter | string
    sentAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    htmlContent?: StringNullableFilter | string | null
    sentInId?: StringFilter | string
  }

  export type TeventUpsertWithWhereUniqueWithoutInvitedUsersInput = {
    where: TeventWhereUniqueInput
    update: XOR<TeventUpdateWithoutInvitedUsersInput, TeventUncheckedUpdateWithoutInvitedUsersInput>
    create: XOR<TeventCreateWithoutInvitedUsersInput, TeventUncheckedCreateWithoutInvitedUsersInput>
  }

  export type TeventUpdateWithWhereUniqueWithoutInvitedUsersInput = {
    where: TeventWhereUniqueInput
    data: XOR<TeventUpdateWithoutInvitedUsersInput, TeventUncheckedUpdateWithoutInvitedUsersInput>
  }

  export type TeventUpdateManyWithWhereWithoutInvitedUsersInput = {
    where: TeventScalarWhereInput
    data: XOR<TeventUpdateManyMutationInput, TeventUncheckedUpdateManyWithoutInvitedInEventInput>
  }

  export type UserParticipeEventUpsertWithWhereUniqueWithoutUserInput = {
    where: UserParticipeEventWhereUniqueInput
    update: XOR<UserParticipeEventUpdateWithoutUserInput, UserParticipeEventUncheckedUpdateWithoutUserInput>
    create: XOR<UserParticipeEventCreateWithoutUserInput, UserParticipeEventUncheckedCreateWithoutUserInput>
  }

  export type UserParticipeEventUpdateWithWhereUniqueWithoutUserInput = {
    where: UserParticipeEventWhereUniqueInput
    data: XOR<UserParticipeEventUpdateWithoutUserInput, UserParticipeEventUncheckedUpdateWithoutUserInput>
  }

  export type UserParticipeEventUpdateManyWithWhereWithoutUserInput = {
    where: UserParticipeEventScalarWhereInput
    data: XOR<UserParticipeEventUpdateManyMutationInput, UserParticipeEventUncheckedUpdateManyWithoutUserPartInEventsInput>
  }

  export type UserParticipeEventScalarWhereInput = {
    AND?: Enumerable<UserParticipeEventScalarWhereInput>
    OR?: Enumerable<UserParticipeEventScalarWhereInput>
    NOT?: Enumerable<UserParticipeEventScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    teventId?: StringFilter | string
    participantId?: StringFilter | string
  }

  export type AreplyUpsertWithWhereUniqueWithoutUserInput = {
    where: AreplyWhereUniqueInput
    update: XOR<AreplyUpdateWithoutUserInput, AreplyUncheckedUpdateWithoutUserInput>
    create: XOR<AreplyCreateWithoutUserInput, AreplyUncheckedCreateWithoutUserInput>
  }

  export type AreplyUpdateWithWhereUniqueWithoutUserInput = {
    where: AreplyWhereUniqueInput
    data: XOR<AreplyUpdateWithoutUserInput, AreplyUncheckedUpdateWithoutUserInput>
  }

  export type AreplyUpdateManyWithWhereWithoutUserInput = {
    where: AreplyScalarWhereInput
    data: XOR<AreplyUpdateManyMutationInput, AreplyUncheckedUpdateManyWithoutAreplyInput>
  }

  export type AreplyScalarWhereInput = {
    AND?: Enumerable<AreplyScalarWhereInput>
    OR?: Enumerable<AreplyScalarWhereInput>
    NOT?: Enumerable<AreplyScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    number?: IntFilter | number
    userId?: StringFilter | string
    apostId?: StringFilter | string
  }

  export type SignalAdminUpsertWithWhereUniqueWithoutUserSendingInput = {
    where: SignalAdminWhereUniqueInput
    update: XOR<SignalAdminUpdateWithoutUserSendingInput, SignalAdminUncheckedUpdateWithoutUserSendingInput>
    create: XOR<SignalAdminCreateWithoutUserSendingInput, SignalAdminUncheckedCreateWithoutUserSendingInput>
  }

  export type SignalAdminUpdateWithWhereUniqueWithoutUserSendingInput = {
    where: SignalAdminWhereUniqueInput
    data: XOR<SignalAdminUpdateWithoutUserSendingInput, SignalAdminUncheckedUpdateWithoutUserSendingInput>
  }

  export type SignalAdminUpdateManyWithWhereWithoutUserSendingInput = {
    where: SignalAdminScalarWhereInput
    data: XOR<SignalAdminUpdateManyMutationInput, SignalAdminUncheckedUpdateManyWithoutSignalsToAdminInput>
  }

  export type SignalAdminScalarWhereInput = {
    AND?: Enumerable<SignalAdminScalarWhereInput>
    OR?: Enumerable<SignalAdminScalarWhereInput>
    NOT?: Enumerable<SignalAdminScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    isTreated?: BoolFilter | boolean
    chatId?: StringFilter | string
    subject?: StringFilter | string
    userId?: StringFilter | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type AreplyCreateWithoutApostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    user: UserCreateNestedOneWithoutAreplyInput
  }

  export type AreplyUncheckedCreateWithoutApostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    userId: string
  }

  export type AreplyCreateOrConnectWithoutApostInput = {
    where: AreplyWhereUniqueInput
    create: XOR<AreplyCreateWithoutApostInput, AreplyUncheckedCreateWithoutApostInput>
  }

  export type AreplyCreateManyApostInputEnvelope = {
    data: Enumerable<AreplyCreateManyApostInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutApostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutApostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutApostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApostsInput, UserUncheckedCreateWithoutApostsInput>
  }

  export type AreplyUpsertWithWhereUniqueWithoutApostInput = {
    where: AreplyWhereUniqueInput
    update: XOR<AreplyUpdateWithoutApostInput, AreplyUncheckedUpdateWithoutApostInput>
    create: XOR<AreplyCreateWithoutApostInput, AreplyUncheckedCreateWithoutApostInput>
  }

  export type AreplyUpdateWithWhereUniqueWithoutApostInput = {
    where: AreplyWhereUniqueInput
    data: XOR<AreplyUpdateWithoutApostInput, AreplyUncheckedUpdateWithoutApostInput>
  }

  export type AreplyUpdateManyWithWhereWithoutApostInput = {
    where: AreplyScalarWhereInput
    data: XOR<AreplyUpdateManyMutationInput, AreplyUncheckedUpdateManyWithoutAreplysInput>
  }

  export type UserUpsertWithoutApostsInput = {
    update: XOR<UserUpdateWithoutApostsInput, UserUncheckedUpdateWithoutApostsInput>
    create: XOR<UserCreateWithoutApostsInput, UserUncheckedCreateWithoutApostsInput>
  }

  export type UserUpdateWithoutApostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutApostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserCreateWithoutAreplyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutAreplyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutAreplyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAreplyInput, UserUncheckedCreateWithoutAreplyInput>
  }

  export type ApostCreateWithoutAreplysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    user: UserCreateNestedOneWithoutApostsInput
  }

  export type ApostUncheckedCreateWithoutAreplysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    userId: string
  }

  export type ApostCreateOrConnectWithoutAreplysInput = {
    where: ApostWhereUniqueInput
    create: XOR<ApostCreateWithoutAreplysInput, ApostUncheckedCreateWithoutAreplysInput>
  }

  export type UserUpsertWithoutAreplyInput = {
    update: XOR<UserUpdateWithoutAreplyInput, UserUncheckedUpdateWithoutAreplyInput>
    create: XOR<UserCreateWithoutAreplyInput, UserUncheckedCreateWithoutAreplyInput>
  }

  export type UserUpdateWithoutAreplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutAreplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type ApostUpsertWithoutAreplysInput = {
    update: XOR<ApostUpdateWithoutAreplysInput, ApostUncheckedUpdateWithoutAreplysInput>
    create: XOR<ApostCreateWithoutAreplysInput, ApostUncheckedCreateWithoutAreplysInput>
  }

  export type ApostUpdateWithoutAreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutApostsInput
  }

  export type ApostUncheckedUpdateWithoutAreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserCreateWithoutImagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutImagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutImagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImagesInput, UserUncheckedCreateWithoutImagesInput>
  }

  export type UserUpsertWithoutImagesInput = {
    update: XOR<UserUpdateWithoutImagesInput, UserUncheckedUpdateWithoutImagesInput>
    create: XOR<UserCreateWithoutImagesInput, UserUncheckedCreateWithoutImagesInput>
  }

  export type UserUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type TpostCreateWithoutTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    treplys?: TreplyCreateNestedManyWithoutTpostInput
    user: UserCreateNestedOneWithoutTpostsInput
  }

  export type TpostUncheckedCreateWithoutTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    userId: string
    treplys?: TreplyUncheckedCreateNestedManyWithoutTpostInput
  }

  export type TpostCreateOrConnectWithoutTeamRefInput = {
    where: TpostWhereUniqueInput
    create: XOR<TpostCreateWithoutTeamRefInput, TpostUncheckedCreateWithoutTeamRefInput>
  }

  export type TpostCreateManyTeamRefInputEnvelope = {
    data: Enumerable<TpostCreateManyTeamRefInput>
    skipDuplicates?: boolean
  }

  export type TeventCreateWithoutTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyCreateNestedManyWithoutTeventInput
    user: UserCreateNestedOneWithoutTeventsInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventCreateNestedManyWithoutTeventInput
  }

  export type TeventUncheckedCreateWithoutTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyUncheckedCreateNestedManyWithoutTeventInput
  }

  export type TeventCreateOrConnectWithoutTeamRefInput = {
    where: TeventWhereUniqueInput
    create: XOR<TeventCreateWithoutTeamRefInput, TeventUncheckedCreateWithoutTeamRefInput>
  }

  export type TeventCreateManyTeamRefInputEnvelope = {
    data: Enumerable<TeventCreateManyTeamRefInput>
    skipDuplicates?: boolean
  }

  export type TreplyCreateWithoutTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpost: TpostCreateNestedOneWithoutTreplysInput
    user: UserCreateNestedOneWithoutTrepliesInput
  }

  export type TreplyUncheckedCreateWithoutTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    userId: string
  }

  export type TreplyCreateOrConnectWithoutTeamRefInput = {
    where: TreplyWhereUniqueInput
    create: XOR<TreplyCreateWithoutTeamRefInput, TreplyUncheckedCreateWithoutTeamRefInput>
  }

  export type TreplyCreateManyTeamRefInputEnvelope = {
    data: Enumerable<TreplyCreateManyTeamRefInput>
    skipDuplicates?: boolean
  }

  export type EreplyCreateWithoutTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    user: UserCreateNestedOneWithoutErepliesInput
    tevent: TeventCreateNestedOneWithoutEreplysInput
  }

  export type EreplyUncheckedCreateWithoutTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    userId: string
  }

  export type EreplyCreateOrConnectWithoutTeamRefInput = {
    where: EreplyWhereUniqueInput
    create: XOR<EreplyCreateWithoutTeamRefInput, EreplyUncheckedCreateWithoutTeamRefInput>
  }

  export type EreplyCreateManyTeamRefInputEnvelope = {
    data: Enumerable<EreplyCreateManyTeamRefInput>
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutTeamsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id: string
    isPublic?: boolean
    catSpecific?: string
  }

  export type TagUncheckedCreateWithoutTeamsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id: string
    isPublic?: boolean
    catSpecific?: string
  }

  export type TagCreateOrConnectWithoutTeamsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTeamsInput, TagUncheckedCreateWithoutTeamsInput>
  }

  export type TeamFollowerCreateWithoutTeamInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
    user?: UserCreateNestedManyWithoutFollowingInput
  }

  export type TeamFollowerUncheckedCreateWithoutTeamInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    followerId: string
  }

  export type TeamFollowerCreateOrConnectWithoutTeamInput = {
    where: TeamFollowerWhereUniqueInput
    create: XOR<TeamFollowerCreateWithoutTeamInput, TeamFollowerUncheckedCreateWithoutTeamInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTeamsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    email?: StringFilter | string
    hashedPassword?: StringFilter | string
    userDescription?: StringFilter | string
    lien?: StringFilter | string
    getNotifications?: BoolFilter | boolean
    isActive?: BoolFilter | boolean
    emailIsVerified?: BoolFilter | boolean
    bio?: StringFilter | string
    role?: StringFilter | string
    avatar?: StringFilter | string
    isPublic?: BoolFilter | boolean
    userLat?: FloatFilter | number
    userLon?: FloatFilter | number
    ip?: StringNullableListFilter
  }

  export type TpostUpsertWithWhereUniqueWithoutTeamRefInput = {
    where: TpostWhereUniqueInput
    update: XOR<TpostUpdateWithoutTeamRefInput, TpostUncheckedUpdateWithoutTeamRefInput>
    create: XOR<TpostCreateWithoutTeamRefInput, TpostUncheckedCreateWithoutTeamRefInput>
  }

  export type TpostUpdateWithWhereUniqueWithoutTeamRefInput = {
    where: TpostWhereUniqueInput
    data: XOR<TpostUpdateWithoutTeamRefInput, TpostUncheckedUpdateWithoutTeamRefInput>
  }

  export type TpostUpdateManyWithWhereWithoutTeamRefInput = {
    where: TpostScalarWhereInput
    data: XOR<TpostUpdateManyMutationInput, TpostUncheckedUpdateManyWithoutTpostsInput>
  }

  export type TeventUpsertWithWhereUniqueWithoutTeamRefInput = {
    where: TeventWhereUniqueInput
    update: XOR<TeventUpdateWithoutTeamRefInput, TeventUncheckedUpdateWithoutTeamRefInput>
    create: XOR<TeventCreateWithoutTeamRefInput, TeventUncheckedCreateWithoutTeamRefInput>
  }

  export type TeventUpdateWithWhereUniqueWithoutTeamRefInput = {
    where: TeventWhereUniqueInput
    data: XOR<TeventUpdateWithoutTeamRefInput, TeventUncheckedUpdateWithoutTeamRefInput>
  }

  export type TeventUpdateManyWithWhereWithoutTeamRefInput = {
    where: TeventScalarWhereInput
    data: XOR<TeventUpdateManyMutationInput, TeventUncheckedUpdateManyWithoutTeventsInput>
  }

  export type TreplyUpsertWithWhereUniqueWithoutTeamRefInput = {
    where: TreplyWhereUniqueInput
    update: XOR<TreplyUpdateWithoutTeamRefInput, TreplyUncheckedUpdateWithoutTeamRefInput>
    create: XOR<TreplyCreateWithoutTeamRefInput, TreplyUncheckedCreateWithoutTeamRefInput>
  }

  export type TreplyUpdateWithWhereUniqueWithoutTeamRefInput = {
    where: TreplyWhereUniqueInput
    data: XOR<TreplyUpdateWithoutTeamRefInput, TreplyUncheckedUpdateWithoutTeamRefInput>
  }

  export type TreplyUpdateManyWithWhereWithoutTeamRefInput = {
    where: TreplyScalarWhereInput
    data: XOR<TreplyUpdateManyMutationInput, TreplyUncheckedUpdateManyWithoutTrepliesInput>
  }

  export type EreplyUpsertWithWhereUniqueWithoutTeamRefInput = {
    where: EreplyWhereUniqueInput
    update: XOR<EreplyUpdateWithoutTeamRefInput, EreplyUncheckedUpdateWithoutTeamRefInput>
    create: XOR<EreplyCreateWithoutTeamRefInput, EreplyUncheckedCreateWithoutTeamRefInput>
  }

  export type EreplyUpdateWithWhereUniqueWithoutTeamRefInput = {
    where: EreplyWhereUniqueInput
    data: XOR<EreplyUpdateWithoutTeamRefInput, EreplyUncheckedUpdateWithoutTeamRefInput>
  }

  export type EreplyUpdateManyWithWhereWithoutTeamRefInput = {
    where: EreplyScalarWhereInput
    data: XOR<EreplyUpdateManyMutationInput, EreplyUncheckedUpdateManyWithoutErepliesInput>
  }

  export type TagUpsertWithWhereUniqueWithoutTeamsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTeamsInput, TagUncheckedUpdateWithoutTeamsInput>
    create: XOR<TagCreateWithoutTeamsInput, TagUncheckedCreateWithoutTeamsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTeamsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTeamsInput, TagUncheckedUpdateWithoutTeamsInput>
  }

  export type TagUpdateManyWithWhereWithoutTeamsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type TagScalarWhereInput = {
    AND?: Enumerable<TagScalarWhereInput>
    OR?: Enumerable<TagScalarWhereInput>
    NOT?: Enumerable<TagScalarWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    id?: StringFilter | string
    isPublic?: BoolFilter | boolean
    catSpecific?: StringFilter | string
  }

  export type TeamFollowerUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamFollowerWhereUniqueInput
    update: XOR<TeamFollowerUpdateWithoutTeamInput, TeamFollowerUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamFollowerCreateWithoutTeamInput, TeamFollowerUncheckedCreateWithoutTeamInput>
  }

  export type TeamFollowerUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamFollowerWhereUniqueInput
    data: XOR<TeamFollowerUpdateWithoutTeamInput, TeamFollowerUncheckedUpdateWithoutTeamInput>
  }

  export type TeamFollowerUpdateManyWithWhereWithoutTeamInput = {
    where: TeamFollowerScalarWhereInput
    data: XOR<TeamFollowerUpdateManyMutationInput, TeamFollowerUncheckedUpdateManyWithoutTeamFollowersInput>
  }

  export type TeamCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutTagsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTagsInput, TeamUncheckedCreateWithoutTagsInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutTagsInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutTagsInput, TeamUncheckedUpdateWithoutTagsInput>
    create: XOR<TeamCreateWithoutTagsInput, TeamUncheckedCreateWithoutTagsInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutTagsInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutTagsInput, TeamUncheckedUpdateWithoutTagsInput>
  }

  export type TeamUpdateManyWithWhereWithoutTagsInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamsInput>
  }

  export type TeamCreateWithoutTeamFollowersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutTeamFollowersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutTeamFollowersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamFollowersInput, TeamUncheckedCreateWithoutTeamFollowersInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutTeamFollowersInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutTeamFollowersInput, TeamUncheckedUpdateWithoutTeamFollowersInput>
    create: XOR<TeamCreateWithoutTeamFollowersInput, TeamUncheckedCreateWithoutTeamFollowersInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutTeamFollowersInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutTeamFollowersInput, TeamUncheckedUpdateWithoutTeamFollowersInput>
  }

  export type TeamUpdateManyWithWhereWithoutTeamFollowersInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserUpsertWithWhereUniqueWithoutFollowingInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFollowingInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateManyWithWhereWithoutFollowingInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type TreplyCreateWithoutTpostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamRef: TeamCreateNestedOneWithoutTrepliesInput
    user: UserCreateNestedOneWithoutTrepliesInput
  }

  export type TreplyUncheckedCreateWithoutTpostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type TreplyCreateOrConnectWithoutTpostInput = {
    where: TreplyWhereUniqueInput
    create: XOR<TreplyCreateWithoutTpostInput, TreplyUncheckedCreateWithoutTpostInput>
  }

  export type TreplyCreateManyTpostInputEnvelope = {
    data: Enumerable<TreplyCreateManyTpostInput>
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutTpostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTpostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutTpostsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTpostsInput, TeamUncheckedCreateWithoutTpostsInput>
  }

  export type UserCreateWithoutTpostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutTpostsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutTpostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTpostsInput, UserUncheckedCreateWithoutTpostsInput>
  }

  export type TreplyUpsertWithWhereUniqueWithoutTpostInput = {
    where: TreplyWhereUniqueInput
    update: XOR<TreplyUpdateWithoutTpostInput, TreplyUncheckedUpdateWithoutTpostInput>
    create: XOR<TreplyCreateWithoutTpostInput, TreplyUncheckedCreateWithoutTpostInput>
  }

  export type TreplyUpdateWithWhereUniqueWithoutTpostInput = {
    where: TreplyWhereUniqueInput
    data: XOR<TreplyUpdateWithoutTpostInput, TreplyUncheckedUpdateWithoutTpostInput>
  }

  export type TreplyUpdateManyWithWhereWithoutTpostInput = {
    where: TreplyScalarWhereInput
    data: XOR<TreplyUpdateManyMutationInput, TreplyUncheckedUpdateManyWithoutTreplysInput>
  }

  export type TeamUpsertWithoutTpostsInput = {
    update: XOR<TeamUpdateWithoutTpostsInput, TeamUncheckedUpdateWithoutTpostsInput>
    create: XOR<TeamCreateWithoutTpostsInput, TeamUncheckedCreateWithoutTpostsInput>
  }

  export type TeamUpdateWithoutTpostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTpostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type UserUpsertWithoutTpostsInput = {
    update: XOR<UserUpdateWithoutTpostsInput, UserUncheckedUpdateWithoutTpostsInput>
    create: XOR<UserCreateWithoutTpostsInput, UserUncheckedCreateWithoutTpostsInput>
  }

  export type UserUpdateWithoutTpostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutTpostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type EreplyCreateWithoutTeventInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamRef: TeamCreateNestedOneWithoutErepliesInput
    user: UserCreateNestedOneWithoutErepliesInput
  }

  export type EreplyUncheckedCreateWithoutTeventInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type EreplyCreateOrConnectWithoutTeventInput = {
    where: EreplyWhereUniqueInput
    create: XOR<EreplyCreateWithoutTeventInput, EreplyUncheckedCreateWithoutTeventInput>
  }

  export type EreplyCreateManyTeventInputEnvelope = {
    data: Enumerable<EreplyCreateManyTeventInput>
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutTeventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutTeventsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeventsInput, TeamUncheckedCreateWithoutTeventsInput>
  }

  export type UserCreateWithoutTeventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutTeventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutTeventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeventsInput, UserUncheckedCreateWithoutTeventsInput>
  }

  export type UserCreateWithoutInvitedInEventInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutInvitedInEventInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutInvitedInEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedInEventInput, UserUncheckedCreateWithoutInvitedInEventInput>
  }

  export type UserParticipeEventCreateWithoutTeventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
    user?: UserCreateNestedManyWithoutUserPartInEventsInput
  }

  export type UserParticipeEventUncheckedCreateWithoutTeventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teventId: string
    participantId: string
  }

  export type UserParticipeEventCreateOrConnectWithoutTeventInput = {
    where: UserParticipeEventWhereUniqueInput
    create: XOR<UserParticipeEventCreateWithoutTeventInput, UserParticipeEventUncheckedCreateWithoutTeventInput>
  }

  export type EreplyUpsertWithWhereUniqueWithoutTeventInput = {
    where: EreplyWhereUniqueInput
    update: XOR<EreplyUpdateWithoutTeventInput, EreplyUncheckedUpdateWithoutTeventInput>
    create: XOR<EreplyCreateWithoutTeventInput, EreplyUncheckedCreateWithoutTeventInput>
  }

  export type EreplyUpdateWithWhereUniqueWithoutTeventInput = {
    where: EreplyWhereUniqueInput
    data: XOR<EreplyUpdateWithoutTeventInput, EreplyUncheckedUpdateWithoutTeventInput>
  }

  export type EreplyUpdateManyWithWhereWithoutTeventInput = {
    where: EreplyScalarWhereInput
    data: XOR<EreplyUpdateManyMutationInput, EreplyUncheckedUpdateManyWithoutEreplysInput>
  }

  export type TeamUpsertWithoutTeventsInput = {
    update: XOR<TeamUpdateWithoutTeventsInput, TeamUncheckedUpdateWithoutTeventsInput>
    create: XOR<TeamCreateWithoutTeventsInput, TeamUncheckedCreateWithoutTeventsInput>
  }

  export type TeamUpdateWithoutTeventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTeventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type UserUpsertWithoutTeventsInput = {
    update: XOR<UserUpdateWithoutTeventsInput, UserUncheckedUpdateWithoutTeventsInput>
    create: XOR<UserCreateWithoutTeventsInput, UserUncheckedCreateWithoutTeventsInput>
  }

  export type UserUpdateWithoutTeventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutTeventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUpsertWithWhereUniqueWithoutInvitedInEventInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutInvitedInEventInput, UserUncheckedUpdateWithoutInvitedInEventInput>
    create: XOR<UserCreateWithoutInvitedInEventInput, UserUncheckedCreateWithoutInvitedInEventInput>
  }

  export type UserUpdateWithWhereUniqueWithoutInvitedInEventInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutInvitedInEventInput, UserUncheckedUpdateWithoutInvitedInEventInput>
  }

  export type UserUpdateManyWithWhereWithoutInvitedInEventInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutInvitedUsersInput>
  }

  export type UserParticipeEventUpsertWithWhereUniqueWithoutTeventInput = {
    where: UserParticipeEventWhereUniqueInput
    update: XOR<UserParticipeEventUpdateWithoutTeventInput, UserParticipeEventUncheckedUpdateWithoutTeventInput>
    create: XOR<UserParticipeEventCreateWithoutTeventInput, UserParticipeEventUncheckedCreateWithoutTeventInput>
  }

  export type UserParticipeEventUpdateWithWhereUniqueWithoutTeventInput = {
    where: UserParticipeEventWhereUniqueInput
    data: XOR<UserParticipeEventUpdateWithoutTeventInput, UserParticipeEventUncheckedUpdateWithoutTeventInput>
  }

  export type UserParticipeEventUpdateManyWithWhereWithoutTeventInput = {
    where: UserParticipeEventScalarWhereInput
    data: XOR<UserParticipeEventUpdateManyMutationInput, UserParticipeEventUncheckedUpdateManyWithoutUsersParticipeEventInput>
  }

  export type TeventCreateWithoutUsersParticipeEventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyCreateNestedManyWithoutTeventInput
    teamRef: TeamCreateNestedOneWithoutTeventsInput
    user: UserCreateNestedOneWithoutTeventsInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedInEventInput
  }

  export type TeventUncheckedCreateWithoutUsersParticipeEventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    ereplys?: EreplyUncheckedCreateNestedManyWithoutTeventInput
  }

  export type TeventCreateOrConnectWithoutUsersParticipeEventInput = {
    where: TeventWhereUniqueInput
    create: XOR<TeventCreateWithoutUsersParticipeEventInput, TeventUncheckedCreateWithoutUsersParticipeEventInput>
  }

  export type UserCreateWithoutUserPartInEventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutUserPartInEventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutUserPartInEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPartInEventsInput, UserUncheckedCreateWithoutUserPartInEventsInput>
  }

  export type TeventUpsertWithWhereUniqueWithoutUsersParticipeEventInput = {
    where: TeventWhereUniqueInput
    update: XOR<TeventUpdateWithoutUsersParticipeEventInput, TeventUncheckedUpdateWithoutUsersParticipeEventInput>
    create: XOR<TeventCreateWithoutUsersParticipeEventInput, TeventUncheckedCreateWithoutUsersParticipeEventInput>
  }

  export type TeventUpdateWithWhereUniqueWithoutUsersParticipeEventInput = {
    where: TeventWhereUniqueInput
    data: XOR<TeventUpdateWithoutUsersParticipeEventInput, TeventUncheckedUpdateWithoutUsersParticipeEventInput>
  }

  export type TeventUpdateManyWithWhereWithoutUsersParticipeEventInput = {
    where: TeventScalarWhereInput
    data: XOR<TeventUpdateManyMutationInput, TeventUncheckedUpdateManyWithoutTeventInput>
  }

  export type UserUpsertWithWhereUniqueWithoutUserPartInEventsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUserPartInEventsInput, UserUncheckedUpdateWithoutUserPartInEventsInput>
    create: XOR<UserCreateWithoutUserPartInEventsInput, UserUncheckedCreateWithoutUserPartInEventsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUserPartInEventsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUserPartInEventsInput, UserUncheckedUpdateWithoutUserPartInEventsInput>
  }

  export type UserUpdateManyWithWhereWithoutUserPartInEventsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamCreateWithoutErepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutErepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutErepliesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutErepliesInput, TeamUncheckedCreateWithoutErepliesInput>
  }

  export type UserCreateWithoutErepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutErepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutErepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutErepliesInput, UserUncheckedCreateWithoutErepliesInput>
  }

  export type TeventCreateWithoutEreplysInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
    teamRef: TeamCreateNestedOneWithoutTeventsInput
    user: UserCreateNestedOneWithoutTeventsInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventCreateNestedManyWithoutTeventInput
  }

  export type TeventUncheckedCreateWithoutEreplysInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
  }

  export type TeventCreateOrConnectWithoutEreplysInput = {
    where: TeventWhereUniqueInput
    create: XOR<TeventCreateWithoutEreplysInput, TeventUncheckedCreateWithoutEreplysInput>
  }

  export type TeamUpsertWithoutErepliesInput = {
    update: XOR<TeamUpdateWithoutErepliesInput, TeamUncheckedUpdateWithoutErepliesInput>
    create: XOR<TeamCreateWithoutErepliesInput, TeamUncheckedCreateWithoutErepliesInput>
  }

  export type TeamUpdateWithoutErepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutErepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type UserUpsertWithoutErepliesInput = {
    update: XOR<UserUpdateWithoutErepliesInput, UserUncheckedUpdateWithoutErepliesInput>
    create: XOR<UserCreateWithoutErepliesInput, UserUncheckedCreateWithoutErepliesInput>
  }

  export type UserUpdateWithoutErepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutErepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type TeventUpsertWithoutEreplysInput = {
    update: XOR<TeventUpdateWithoutEreplysInput, TeventUncheckedUpdateWithoutEreplysInput>
    create: XOR<TeventCreateWithoutEreplysInput, TeventUncheckedCreateWithoutEreplysInput>
  }

  export type TeventUpdateWithoutEreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    teamRef?: TeamUpdateOneRequiredWithoutTeventsInput
    user?: UserUpdateOneRequiredWithoutTeventsInput
    invitedUsers?: UserUpdateManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateWithoutEreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TpostCreateWithoutTreplysInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamRef: TeamCreateNestedOneWithoutTpostsInput
    user: UserCreateNestedOneWithoutTpostsInput
  }

  export type TpostUncheckedCreateWithoutTreplysInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type TpostCreateOrConnectWithoutTreplysInput = {
    where: TpostWhereUniqueInput
    create: XOR<TpostCreateWithoutTreplysInput, TpostUncheckedCreateWithoutTreplysInput>
  }

  export type TeamCreateWithoutTrepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    users?: UserCreateNestedManyWithoutTeamsInput
    tposts?: TpostCreateNestedManyWithoutTeamRefInput
    tevents?: TeventCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyCreateNestedManyWithoutTeamRefInput
    tags?: TagCreateNestedManyWithoutTeamsInput
    teamFollowers?: TeamFollowerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTrepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description: string
    corpus?: string
    anneeCreation: number
    secteur: string
    typeOrg: string
    taille: number
    teamLatitude: number
    teamLongitude: number
    image?: string
    imageCover?: string
    public?: boolean
    findIndex?: number
    publishDemand?: boolean
    TeamMastersID?: TeamCreateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamCreateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedCreateNestedManyWithoutTeamRefInput
    tevents?: TeventUncheckedCreateNestedManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutTeamRefInput
  }

  export type TeamCreateOrConnectWithoutTrepliesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTrepliesInput, TeamUncheckedCreateWithoutTrepliesInput>
  }

  export type UserCreateWithoutTrepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutTrepliesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutTrepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrepliesInput, UserUncheckedCreateWithoutTrepliesInput>
  }

  export type TpostUpsertWithoutTreplysInput = {
    update: XOR<TpostUpdateWithoutTreplysInput, TpostUncheckedUpdateWithoutTreplysInput>
    create: XOR<TpostCreateWithoutTreplysInput, TpostUncheckedCreateWithoutTreplysInput>
  }

  export type TpostUpdateWithoutTreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamRef?: TeamUpdateOneRequiredWithoutTpostsInput
    user?: UserUpdateOneRequiredWithoutTpostsInput
  }

  export type TpostUncheckedUpdateWithoutTreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpsertWithoutTrepliesInput = {
    update: XOR<TeamUpdateWithoutTrepliesInput, TeamUncheckedUpdateWithoutTrepliesInput>
    create: XOR<TeamCreateWithoutTrepliesInput, TeamUncheckedCreateWithoutTrepliesInput>
  }

  export type TeamUpdateWithoutTrepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTrepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type UserUpsertWithoutTrepliesInput = {
    update: XOR<UserUpdateWithoutTrepliesInput, UserUncheckedUpdateWithoutTrepliesInput>
    create: XOR<UserCreateWithoutTrepliesInput, UserUncheckedCreateWithoutTrepliesInput>
  }

  export type UserUpdateWithoutTrepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutTrepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageCreateNestedManyWithoutSentInInput
    participatingUsers?: UserCreateNestedManyWithoutParticipatesInInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    adminMessages?: AdminMessageUncheckedCreateNestedManyWithoutSentInInput
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUpsertWithWhereUniqueWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateManyWithWhereWithoutReceivedMessagesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSentToInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUpdateManyWithoutSentInInput
    participatingUsers?: UserUpdateManyWithoutParticipatesInInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUncheckedUpdateManyWithoutSentInInput
  }

  export type UserCreateWithoutSignalsToAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSignalsToAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSignalsToAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignalsToAdminInput, UserUncheckedCreateWithoutSignalsToAdminInput>
  }

  export type UserUpsertWithoutSignalsToAdminInput = {
    update: XOR<UserUpdateWithoutSignalsToAdminInput, UserUncheckedUpdateWithoutSignalsToAdminInput>
    create: XOR<UserCreateWithoutSignalsToAdminInput, UserUncheckedCreateWithoutSignalsToAdminInput>
  }

  export type UserUpdateWithoutSignalsToAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSignalsToAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
  }

  export type AdminMessageCreateWithoutSentInInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    wasReadBy?: UserCreateNestedManyWithoutHasReadInput
  }

  export type AdminMessageUncheckedCreateWithoutSentInInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
  }

  export type AdminMessageCreateOrConnectWithoutSentInInput = {
    where: AdminMessageWhereUniqueInput
    create: XOR<AdminMessageCreateWithoutSentInInput, AdminMessageUncheckedCreateWithoutSentInInput>
  }

  export type AdminMessageCreateManySentInInputEnvelope = {
    data: Enumerable<AdminMessageCreateManySentInInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSentInInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
    sentFrom: UserCreateNestedOneWithoutSentMessagesInput
    sentTo?: UserCreateNestedManyWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSentInInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentFromId: string
    sentToId?: MessageCreatesentToIdInput | Enumerable<string>
  }

  export type MessageCreateOrConnectWithoutSentInInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSentInInput, MessageUncheckedCreateWithoutSentInInput>
  }

  export type MessageCreateManySentInInputEnvelope = {
    data: Enumerable<MessageCreateManySentInInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutParticipatesInInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    images?: ImageCreateNestedManyWithoutUserInput
    hasRead?: AdminMessageCreateNestedManyWithoutWasReadByInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutParticipatesInInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutParticipatesInInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipatesInInput, UserUncheckedCreateWithoutParticipatesInInput>
  }

  export type AdminMessageUpsertWithWhereUniqueWithoutSentInInput = {
    where: AdminMessageWhereUniqueInput
    update: XOR<AdminMessageUpdateWithoutSentInInput, AdminMessageUncheckedUpdateWithoutSentInInput>
    create: XOR<AdminMessageCreateWithoutSentInInput, AdminMessageUncheckedCreateWithoutSentInInput>
  }

  export type AdminMessageUpdateWithWhereUniqueWithoutSentInInput = {
    where: AdminMessageWhereUniqueInput
    data: XOR<AdminMessageUpdateWithoutSentInInput, AdminMessageUncheckedUpdateWithoutSentInInput>
  }

  export type AdminMessageUpdateManyWithWhereWithoutSentInInput = {
    where: AdminMessageScalarWhereInput
    data: XOR<AdminMessageUpdateManyMutationInput, AdminMessageUncheckedUpdateManyWithoutAdminMessagesInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSentInInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSentInInput, MessageUncheckedUpdateWithoutSentInInput>
    create: XOR<MessageCreateWithoutSentInInput, MessageUncheckedCreateWithoutSentInInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSentInInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSentInInput, MessageUncheckedUpdateWithoutSentInInput>
  }

  export type MessageUpdateManyWithWhereWithoutSentInInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutParticipatesInInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutParticipatesInInput, UserUncheckedUpdateWithoutParticipatesInInput>
    create: XOR<UserCreateWithoutParticipatesInInput, UserUncheckedCreateWithoutParticipatesInInput>
  }

  export type UserUpdateWithWhereUniqueWithoutParticipatesInInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutParticipatesInInput, UserUncheckedUpdateWithoutParticipatesInInput>
  }

  export type UserUpdateManyWithWhereWithoutParticipatesInInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutParticipatingUsersInput>
  }

  export type ChatCreateWithoutAdminMessagesInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    messages?: MessageCreateNestedManyWithoutSentInInput
    participatingUsers?: UserCreateNestedManyWithoutParticipatesInInput
  }

  export type ChatUncheckedCreateWithoutAdminMessagesInput = {
    id: string
    subject: string
    private: boolean
    IsDeletedByAdmin?: boolean
    messages?: MessageUncheckedCreateNestedManyWithoutSentInInput
  }

  export type ChatCreateOrConnectWithoutAdminMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutAdminMessagesInput, ChatUncheckedCreateWithoutAdminMessagesInput>
  }

  export type UserCreateWithoutHasReadInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    tposts?: TpostCreateNestedManyWithoutUserInput
    tevents?: TeventCreateNestedManyWithoutUserInput
    treplies?: TreplyCreateNestedManyWithoutUserInput
    aposts?: ApostCreateNestedManyWithoutUserInput
    following?: TeamFollowerCreateNestedManyWithoutUserInput
    ereplies?: EreplyCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSentFromInput
    receivedMessages?: MessageCreateNestedManyWithoutSentToInput
    participatesIn?: ChatCreateNestedManyWithoutParticipatingUsersInput
    images?: ImageCreateNestedManyWithoutUserInput
    invitedInEvent?: TeventCreateNestedManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventCreateNestedManyWithoutUserInput
    Areply?: AreplyCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminCreateNestedManyWithoutUserSendingInput
  }

  export type UserUncheckedCreateWithoutHasReadInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    hashedPassword: string
    userDescription?: string
    lien?: string
    getNotifications: boolean
    isActive?: boolean
    emailIsVerified?: boolean
    bio?: string
    role?: string
    avatar?: string
    isPublic?: boolean
    userLat: number
    userLon: number
    ip?: UserCreateipInput | Enumerable<string>
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tposts?: TpostUncheckedCreateNestedManyWithoutUserInput
    tevents?: TeventUncheckedCreateNestedManyWithoutUserInput
    treplies?: TreplyUncheckedCreateNestedManyWithoutUserInput
    aposts?: ApostUncheckedCreateNestedManyWithoutUserInput
    ereplies?: EreplyUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSentFromInput
    images?: ImageUncheckedCreateNestedManyWithoutUserInput
    Areply?: AreplyUncheckedCreateNestedManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedCreateNestedManyWithoutUserSendingInput
  }

  export type UserCreateOrConnectWithoutHasReadInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHasReadInput, UserUncheckedCreateWithoutHasReadInput>
  }

  export type ChatUpsertWithoutAdminMessagesInput = {
    update: XOR<ChatUpdateWithoutAdminMessagesInput, ChatUncheckedUpdateWithoutAdminMessagesInput>
    create: XOR<ChatCreateWithoutAdminMessagesInput, ChatUncheckedCreateWithoutAdminMessagesInput>
  }

  export type ChatUpdateWithoutAdminMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    messages?: MessageUpdateManyWithoutSentInInput
    participatingUsers?: UserUpdateManyWithoutParticipatesInInput
  }

  export type ChatUncheckedUpdateWithoutAdminMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    messages?: MessageUncheckedUpdateManyWithoutSentInInput
  }

  export type UserUpsertWithWhereUniqueWithoutHasReadInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutHasReadInput, UserUncheckedUpdateWithoutHasReadInput>
    create: XOR<UserCreateWithoutHasReadInput, UserUncheckedCreateWithoutHasReadInput>
  }

  export type UserUpdateWithWhereUniqueWithoutHasReadInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutHasReadInput, UserUncheckedUpdateWithoutHasReadInput>
  }

  export type UserUpdateManyWithWhereWithoutHasReadInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutWasReadByInput>
  }

  export type TokenCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hashedToken: string
    type: string
    expiresAt: Date | string
    sentTo: string
  }

  export type SessionCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    handle: string
    hashedSessionToken?: string | null
    antiCSRFToken?: string | null
    publicData?: string | null
    privateData?: string | null
    name?: string | null
    emailIsVerified?: boolean | null
  }

  export type TpostCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    teamId: string
  }

  export type TeventCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    teamId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
  }

  export type TreplyCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    teamId: string
  }

  export type ApostCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
  }

  export type EreplyCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    teamId: string
  }

  export type MessageCreateManySentFromInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentInId: string
    sentToId?: MessageCreateManysentToIdInput | Enumerable<string>
  }

  export type ImageCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    asset_id: string
    url: string
  }

  export type AreplyCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    apostId: string
  }

  export type SignalAdminCreateManyUserSendingInput = {
    id?: string
    createdAt?: Date | string
    content: string
    isTreated?: boolean
    chatId: string
    subject: string
  }

  export type TokenUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUncheckedUpdateManyWithoutTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentTo?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handle?: StringFieldUpdateOperationsInput | string
    hashedSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    antiCSRFToken?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableStringFieldUpdateOperationsInput | string | null
    privateData?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailIsVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TeamUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
  }

  export type TpostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    treplys?: TreplyUpdateManyWithoutTpostInput
    teamRef?: TeamUpdateOneRequiredWithoutTpostsInput
  }

  export type TpostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    treplys?: TreplyUncheckedUpdateManyWithoutTpostInput
  }

  export type TpostUncheckedUpdateManyWithoutTpostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUpdateManyWithoutTeventInput
    teamRef?: TeamUpdateOneRequiredWithoutTeventsInput
    invitedUsers?: UserUpdateManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUncheckedUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateManyWithoutTeventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpost?: TpostUpdateOneRequiredWithoutTreplysInput
    teamRef?: TeamUpdateOneRequiredWithoutTrepliesInput
  }

  export type TreplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpostId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TreplyUncheckedUpdateManyWithoutTrepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpostId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type ApostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    areplys?: AreplyUpdateManyWithoutApostInput
  }

  export type ApostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    areplys?: AreplyUncheckedUpdateManyWithoutApostInput
  }

  export type ApostUncheckedUpdateManyWithoutApostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateManyWithoutTeamFollowersInput
  }

  export type TeamFollowerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamRef?: TeamUpdateOneRequiredWithoutErepliesInput
    tevent?: TeventUpdateOneRequiredWithoutEreplysInput
  }

  export type EreplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teventId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyUncheckedUpdateManyWithoutErepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teventId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutSentFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
    sentTo?: UserUpdateManyWithoutReceivedMessagesInput
    sentIn?: ChatUpdateOneRequiredWithoutMessagesInput
  }

  export type MessageUncheckedUpdateWithoutSentFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageUncheckedUpdateManyWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageUpdateWithoutSentToInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
    sentFrom?: UserUpdateOneRequiredWithoutSentMessagesInput
    sentIn?: ChatUpdateOneRequiredWithoutMessagesInput
  }

  export type MessageUncheckedUpdateWithoutSentToInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageUncheckedUpdateManyWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentInId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type ChatUpdateWithoutParticipatingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUpdateManyWithoutSentInInput
    messages?: MessageUpdateManyWithoutSentInInput
  }

  export type ChatUncheckedUpdateWithoutParticipatingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
    adminMessages?: AdminMessageUncheckedUpdateManyWithoutSentInInput
    messages?: MessageUncheckedUpdateManyWithoutSentInInput
  }

  export type ChatUncheckedUpdateManyWithoutParticipatesInInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    IsDeletedByAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type AdminMessageUpdateWithoutWasReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentIn?: ChatUpdateOneRequiredWithoutAdminMessagesInput
  }

  export type AdminMessageUncheckedUpdateWithoutWasReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminMessageUncheckedUpdateManyWithoutHasReadInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentInId?: StringFieldUpdateOperationsInput | string
  }

  export type TeventUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUpdateManyWithoutTeventInput
    teamRef?: TeamUpdateOneRequiredWithoutTeventsInput
    user?: UserUpdateOneRequiredWithoutTeventsInput
    usersParticipeEvent?: UserParticipeEventUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUncheckedUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateManyWithoutInvitedInEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserParticipeEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    tevent?: TeventUpdateManyWithoutUsersParticipeEventInput
  }

  export type UserParticipeEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserParticipeEventUncheckedUpdateManyWithoutUserPartInEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    apost?: ApostUpdateOneRequiredWithoutAreplysInput
  }

  export type AreplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    apostId?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyUncheckedUpdateManyWithoutAreplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    apostId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalAdminUpdateWithoutUserSendingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SignalAdminUncheckedUpdateWithoutUserSendingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SignalAdminUncheckedUpdateManyWithoutSignalsToAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyCreateManyApostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    userId: string
  }

  export type AreplyUpdateWithoutApostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAreplyInput
  }

  export type AreplyUncheckedUpdateWithoutApostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AreplyUncheckedUpdateManyWithoutAreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TpostCreateManyTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    number?: number
    userId: string
  }

  export type TeventCreateManyTeamRefInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: string
    startAt: Date | string
    endsAt: Date | string
    content: string
    maxParticipants: number
    userId: string
    eventLat: number
    eventLon: number
    locationDescription?: string | null
    visioPres: boolean
    linkVisio?: string | null
    visioCode?: string | null
    infoPostscritum?: string | null
    isCancel?: boolean
    visible: boolean
    postScriptWriterId?: string | null
    recallEmailSent?: boolean
  }

  export type TreplyCreateManyTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    tpostId: string
    userId: string
  }

  export type EreplyCreateManyTeamRefInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teventId: string
    userId: string
  }

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type TpostUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    treplys?: TreplyUpdateManyWithoutTpostInput
    user?: UserUpdateOneRequiredWithoutTpostsInput
  }

  export type TpostUncheckedUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    treplys?: TreplyUncheckedUpdateManyWithoutTpostInput
  }

  export type TeventUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUpdateManyWithoutTeventInput
    user?: UserUpdateOneRequiredWithoutTeventsInput
    invitedUsers?: UserUpdateManyWithoutInvitedInEventInput
    usersParticipeEvent?: UserParticipeEventUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUncheckedUpdateManyWithoutTeventInput
  }

  export type TreplyUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpost?: TpostUpdateOneRequiredWithoutTreplysInput
    user?: UserUpdateOneRequiredWithoutTrepliesInput
  }

  export type TreplyUncheckedUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    tpostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutErepliesInput
    tevent?: TeventUpdateOneRequiredWithoutEreplysInput
  }

  export type EreplyUncheckedUpdateWithoutTeamRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutTeamsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutTeamsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutTagsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    catSpecific?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutFollowingInput
  }

  export type TeamFollowerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamFollowerUncheckedUpdateManyWithoutTeamFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    teamFollowers?: TeamFollowerUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type TeamUpdateWithoutTeamFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    users?: UserUpdateManyWithoutTeamsInput
    tposts?: TpostUpdateManyWithoutTeamRefInput
    tevents?: TeventUpdateManyWithoutTeamRefInput
    treplies?: TreplyUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUpdateManyWithoutTeamRefInput
    tags?: TagUpdateManyWithoutTeamsInput
  }

  export type TeamUncheckedUpdateWithoutTeamFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
    tposts?: TpostUncheckedUpdateManyWithoutTeamRefInput
    tevents?: TeventUncheckedUpdateManyWithoutTeamRefInput
    treplies?: TreplyUncheckedUpdateManyWithoutTeamRefInput
    ereplies?: EreplyUncheckedUpdateManyWithoutTeamRefInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    corpus?: StringFieldUpdateOperationsInput | string
    anneeCreation?: IntFieldUpdateOperationsInput | number
    secteur?: StringFieldUpdateOperationsInput | string
    typeOrg?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    teamLatitude?: FloatFieldUpdateOperationsInput | number
    teamLongitude?: FloatFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    imageCover?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    findIndex?: IntFieldUpdateOperationsInput | number
    publishDemand?: BoolFieldUpdateOperationsInput | boolean
    TeamMastersID?: TeamUpdateTeamMastersIDInput | Enumerable<string>
    TeamMemberId?: TeamUpdateTeamMemberIdInput | Enumerable<string>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type TreplyCreateManyTpostInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type TreplyUpdateWithoutTpostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamRef?: TeamUpdateOneRequiredWithoutTrepliesInput
    user?: UserUpdateOneRequiredWithoutTrepliesInput
  }

  export type TreplyUncheckedUpdateWithoutTpostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TreplyUncheckedUpdateManyWithoutTreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyCreateManyTeventInput = {
    id?: string
    createdAt?: Date | string
    content: string
    number?: number
    teamId: string
    userId: string
  }

  export type EreplyUpdateWithoutTeventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamRef?: TeamUpdateOneRequiredWithoutErepliesInput
    user?: UserUpdateOneRequiredWithoutErepliesInput
  }

  export type EreplyUncheckedUpdateWithoutTeventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EreplyUncheckedUpdateManyWithoutEreplysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutInvitedInEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutInvitedInEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type UserParticipeEventUpdateWithoutTeventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutUserPartInEventsInput
  }

  export type UserParticipeEventUncheckedUpdateWithoutTeventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserParticipeEventUncheckedUpdateManyWithoutUsersParticipeEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teventId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type TeventUpdateWithoutUsersParticipeEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUpdateManyWithoutTeventInput
    teamRef?: TeamUpdateOneRequiredWithoutTeventsInput
    user?: UserUpdateOneRequiredWithoutTeventsInput
    invitedUsers?: UserUpdateManyWithoutInvitedInEventInput
  }

  export type TeventUncheckedUpdateWithoutUsersParticipeEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
    ereplys?: EreplyUncheckedUpdateManyWithoutTeventInput
  }

  export type TeventUncheckedUpdateManyWithoutTeventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventLat?: FloatFieldUpdateOperationsInput | number
    eventLon?: FloatFieldUpdateOperationsInput | number
    locationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    visioPres?: BoolFieldUpdateOperationsInput | boolean
    linkVisio?: NullableStringFieldUpdateOperationsInput | string | null
    visioCode?: NullableStringFieldUpdateOperationsInput | string | null
    infoPostscritum?: NullableStringFieldUpdateOperationsInput | string | null
    isCancel?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    postScriptWriterId?: NullableStringFieldUpdateOperationsInput | string | null
    recallEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpdateWithoutUserPartInEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutUserPartInEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutSentToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type AdminMessageCreateManySentInInput = {
    id?: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
  }

  export type MessageCreateManySentInInput = {
    id: string
    sentAt?: Date | string
    content: string
    htmlContent?: string | null
    sentFromId: string
    sentToId?: MessageCreateManysentToIdInput | Enumerable<string>
  }

  export type AdminMessageUpdateWithoutSentInInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    wasReadBy?: UserUpdateManyWithoutHasReadInput
  }

  export type AdminMessageUncheckedUpdateWithoutSentInInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminMessageUncheckedUpdateManyWithoutAdminMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSentInInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
    sentFrom?: UserUpdateOneRequiredWithoutSentMessagesInput
    sentTo?: UserUpdateManyWithoutReceivedMessagesInput
  }

  export type MessageUncheckedUpdateWithoutSentInInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    sentFromId?: StringFieldUpdateOperationsInput | string
    sentToId?: MessageUpdatesentToIdInput | Enumerable<string>
  }

  export type UserUpdateWithoutParticipatesInInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    images?: ImageUpdateManyWithoutUserInput
    hasRead?: AdminMessageUpdateManyWithoutWasReadByInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutParticipatesInInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutParticipatingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }

  export type UserUpdateWithoutHasReadInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    teams?: TeamUpdateManyWithoutUsersInput
    tposts?: TpostUpdateManyWithoutUserInput
    tevents?: TeventUpdateManyWithoutUserInput
    treplies?: TreplyUpdateManyWithoutUserInput
    aposts?: ApostUpdateManyWithoutUserInput
    following?: TeamFollowerUpdateManyWithoutUserInput
    ereplies?: EreplyUpdateManyWithoutUserInput
    sentMessages?: MessageUpdateManyWithoutSentFromInput
    receivedMessages?: MessageUpdateManyWithoutSentToInput
    participatesIn?: ChatUpdateManyWithoutParticipatingUsersInput
    images?: ImageUpdateManyWithoutUserInput
    invitedInEvent?: TeventUpdateManyWithoutInvitedUsersInput
    UserPartInEvents?: UserParticipeEventUpdateManyWithoutUserInput
    Areply?: AreplyUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateWithoutHasReadInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
    tokens?: TokenUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    tposts?: TpostUncheckedUpdateManyWithoutUserInput
    tevents?: TeventUncheckedUpdateManyWithoutUserInput
    treplies?: TreplyUncheckedUpdateManyWithoutUserInput
    aposts?: ApostUncheckedUpdateManyWithoutUserInput
    ereplies?: EreplyUncheckedUpdateManyWithoutUserInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSentFromInput
    images?: ImageUncheckedUpdateManyWithoutUserInput
    Areply?: AreplyUncheckedUpdateManyWithoutUserInput
    signalsToAdmin?: SignalAdminUncheckedUpdateManyWithoutUserSendingInput
  }

  export type UserUncheckedUpdateManyWithoutWasReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    hashedPassword?: StringFieldUpdateOperationsInput | string
    userDescription?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    getNotifications?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    bio?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userLat?: FloatFieldUpdateOperationsInput | number
    userLon?: FloatFieldUpdateOperationsInput | number
    ip?: UserUpdateipInput | Enumerable<string>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}