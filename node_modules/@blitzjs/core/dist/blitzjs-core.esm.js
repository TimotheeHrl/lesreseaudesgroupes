import { _ as _createForOfIteratorHelperLoose, a as _extends, L as LOCALSTORAGE_PREFIX, C as COOKIE_PUBLIC_DATA_TOKEN, b as COOKIE_CSRF_TOKEN, c as COOKIE_LEGACY_CSRF_TOKEN, H as HEADER_PUBLIC_DATA_TOKEN, d as HEADER_SESSION_REVOKED, e as HEADER_SESSION_CREATED, f as HEADER_CSRF_ERROR, g as HEADER_CSRF } from './constants-9247c749.esm.js';
export { k as COOKIE_ANONYMOUS_SESSION_TOKEN, b as COOKIE_CSRF_TOKEN, c as COOKIE_LEGACY_CSRF_TOKEN, C as COOKIE_PUBLIC_DATA_TOKEN, m as COOKIE_REFRESH_TOKEN, l as COOKIE_SESSION_TOKEN, h as HANDLE_SEPARATOR, g as HEADER_CSRF, f as HEADER_CSRF_ERROR, H as HEADER_PUBLIC_DATA_TOKEN, e as HEADER_SESSION_CREATED, d as HEADER_SESSION_REVOKED, L as LOCALSTORAGE_PREFIX, j as SESSION_TOKEN_VERSION_0, i as SESSION_TYPE_ANONYMOUS_JWT, S as SESSION_TYPE_OPAQUE_TOKEN_SIMPLE, T as TOKEN_SEPARATOR } from './constants-9247c749.esm.js';
import NextRouter, { useRouter as useRouter$1, withRouter as withRouter$1 } from 'next/router';
export { createRouter, makePublicRouterInstance } from 'next/router';
import React, { useMemo, useRef, isValidElement, createElement, Component, useState, useEffect } from 'react';
import fromPairs from 'lodash.frompairs';
import { RouterContext } from 'next/dist/next-server/lib/router-context';
export { RouterContext } from 'next/dist/next-server/lib/router-context';
export { default as Link } from 'next/link';
export { default as ErrorComponent } from 'next/error';
import { QueryClient, QueryClientProvider, useQuery as useQuery$1, useInfiniteQuery as useInfiniteQuery$1, useMutation as useMutation$1 } from 'react-query';
export { QueryClient, useQueryErrorResetBoundary } from 'react-query';
import { Hydrate } from 'react-query/hydration';
export { dehydrate } from 'react-query/hydration';
import SuperJSON, { serialize, deserialize } from 'superjson';
import { i as isClient, g as getBlitzRuntimeData, c as clientDebug, a as isServer } from './blitz-data-e8ab5731.esm.js';
export { f as formatZodError, g as getBlitzRuntimeData, v as validateZodSchema } from './blitz-data-e8ab5731.esm.js';
import { RedirectError, AuthenticationError, CSRFTokenMismatchError } from 'next/stdlib';
import { formatWithValidation } from 'next/dist/next-server/lib/utils';
import BadBehavior from 'bad-behavior';
import { fromBase64 } from 'b64-lite';
import Head from 'next/head';
import { addBasePath } from 'next/dist/next-server/lib/router/router';
export { Routes } from '.blitz';
import { spawn } from 'cross-spawn';
import which from 'npm-which';
import '@blitzjs/config';
import 'htmlescape';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function useRouterQuery() {
  var router = useRouter$1();
  var query = useMemo(function () {
    var query = decode(router.asPath.split("?", 2)[1]);
    return query;
  }, [router.asPath]);
  return query;
}

function areQueryValuesEqual(value1, value2) {
  // Check if their type match
  if (typeof value1 !== typeof value2) {
    return false;
  }

  if (Array.isArray(value1) && Array.isArray(value2)) {
    if (value1.length !== value2.length) {
      return false;
    }

    for (var i = 0; i < value1.length; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }

  return value1 === value2;
}

function extractRouterParams(routerQuery, query) {
  return fromPairs(Object.entries(routerQuery).filter(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    return typeof query[key] === "undefined" || !areQueryValuesEqual(value, query[key]);
  }));
}
function useParams(returnType) {
  var router = useRouter$1();
  var query = useRouterQuery();
  var params = useMemo(function () {
    var rawParams = extractRouterParams(router.query, query);

    if (returnType === "string") {
      var _params = {};

      for (var _key in rawParams) {
        if (typeof rawParams[_key] === "string") {
          _params[_key] = rawParams[_key];
        }
      }

      return _params;
    }

    if (returnType === "number") {
      var _params2 = {};

      for (var _key2 in rawParams) {
        if (rawParams[_key2]) {
          var num = Number(rawParams[_key2]);
          _params2[_key2] = isNaN(num) ? undefined : num;
        }
      }

      return _params2;
    }

    if (returnType === "array") {
      var _params3 = {};

      for (var _key3 in rawParams) {
        var rawValue = rawParams[_key3];

        if (Array.isArray(rawParams[_key3])) {
          _params3[_key3] = rawValue;
        } else if (typeof rawValue === "string") {
          _params3[_key3] = [rawValue];
        }
      }

      return _params3;
    }

    return rawParams;
  }, [router.query, query, returnType]);
  return params;
}
function useParam(key, returnType) {
  var params = useParams(returnType);
  var value = params[key];
  return value;
}
/*
 * Based on the code of https://github.com/lukeed/qss
 */

var decodeString = function decodeString(str) {
  return decodeURIComponent(str.replace(/\+/g, "%20"));
};

function decode(str) {
  if (!str) return {};
  var out = {};

  for (var _iterator = _createForOfIteratorHelperLoose(str.split("&")), _step; !(_step = _iterator()).done;) {
    var current = _step.value;

    var _current$split = current.split("="),
        _key4 = _current$split[0],
        _current$split$ = _current$split[1],
        value = _current$split$ === void 0 ? "" : _current$split$;

    _key4 = decodeString(_key4);
    value = decodeString(value);
    if (_key4.length === 0) continue;

    if (_key4 in out) {
      out[_key4] = [].concat(out[_key4], value);
    } else {
      out[_key4] = value;
    }
  }

  return out;
}

var Router = NextRouter;
var withRouter = function withRouter(WrappedComponent) {
  function Wrapper(_ref) {
    var router = _ref.router,
        props = _objectWithoutPropertiesLoose(_ref, ["router"]);

    var query = useRouterQuery();
    var params = useParams();
    return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
      router: _extends({}, router, {
        query: query,
        params: params
      })
    }, props));
  }

  return withRouter$1(Wrapper);
};
function useRouter() {
  var router = useRouter$1();
  var query = useRouterQuery();
  var params = useParams(); // TODO - we have to explicitly define the return type otherwise TS complains about
  // NextHistoryState and TransitionOptions not being exported from Next.js code

  return React.useMemo(function () {
    return _extends({}, router, {
      query: query,
      params: params
    });
  }, [params, query, router]);
}

function requestIdleCallbackShim(cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}

var requestIdleCallback = isClient ? window.requestIdleCallback || requestIdleCallbackShim : requestIdleCallbackShim;

var initializeQueryClient = function initializeQueryClient() {
  var suspenseEnabled = true;

  if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
    var data = getBlitzRuntimeData();
    suspenseEnabled = data.suspenseEnabled;
  }

  return new QueryClient({
    defaultOptions: {
      queries: {
        suspense: !!suspenseEnabled,
        retry: function retry(failureCount, error) {
          if (process.env.NODE_ENV !== "production") return false; // Retry (max. 3 times) only if network error detected

          if (error.message === "Network request failed" && failureCount <= 3) return true;
          return false;
        }
      }
    }
  });
}; // Create internal QueryClient instance

var queryClient = /*#__PURE__*/initializeQueryClient();

function isEnhancedResolverRpcClient(f) {
  return !!f._meta;
}

var getQueryCacheFunctions = function getQueryCacheFunctions(resolver, params) {
  return {
    setQueryData: function setQueryData(newData, opts) {
      if (opts === void 0) {
        opts = {
          refetch: true
        };
      }

      return _setQueryData(resolver, params, newData, opts);
    }
  };
};
var emptyQueryFn = /*#__PURE__*/function () {
  var fn = function fn() {
    return new Promise(function () {});
  };

  fn._meta = {
    name: "emptyQueryFn",
    type: "n/a",
    filePath: "n/a",
    apiUrl: ""
  };
  return fn;
}();

var isNotInUserTestEnvironment = function isNotInUserTestEnvironment() {
  if (process.env.JEST_WORKER_ID === undefined) return true;
  if (process.env.BLITZ_TEST_ENVIRONMENT !== undefined) return true;
  return false;
};

var validateQueryFn = function validateQueryFn(queryFn) {
  if (!isEnhancedResolverRpcClient(queryFn) && isNotInUserTestEnvironment()) {
    throw new Error("Either the file path to your resolver is incorrect (must be in a \"queries\" or \"mutations\" folder that isn't nested inside \"pages\" or \"api\") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from \"react-query\")");
  }
};

var sanitize = function sanitize(type) {
  return function (queryFn) {
    var _enhancedResolver$_me;

    validateQueryFn(queryFn);
    var enhancedResolver = queryFn;
    var queryFnName = type === "mutation" ? "useMutation" : "useQuery";

    if (((_enhancedResolver$_me = enhancedResolver._meta) == null ? void 0 : _enhancedResolver$_me.type) !== type && isNotInUserTestEnvironment()) {
      throw new Error("\"" + queryFnName + "\" was expected to be called with a " + type + " but was called with a \"" + enhancedResolver._meta.type + "\"");
    }

    return enhancedResolver;
  };
};

var sanitizeQuery = /*#__PURE__*/sanitize("query");
var sanitizeMutation = /*#__PURE__*/sanitize("mutation");
var getQueryKeyFromUrlAndParams = function getQueryKeyFromUrlAndParams(url, params) {
  var queryKey = [url];
  var args = typeof params === "function" ? params() : params;
  queryKey.push(serialize(args));
  return queryKey;
};
function getQueryKey(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryKey is missing the first argument - it must be a resolver function");
  }

  return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._meta.apiUrl, params);
}
function invalidateQuery(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("invalidateQuery is missing the first argument - it must be a resolver function");
  }

  var fullQueryKey = getQueryKey(resolver, params);
  var queryKey;

  if (params) {
    queryKey = fullQueryKey;
  } else {
    // Params not provided, only use first query key item (url)
    queryKey = fullQueryKey[0];
  }

  return queryClient.invalidateQueries(queryKey);
}

function _setQueryData(resolver, params, newData, opts) {
  if (opts === void 0) {
    opts = {
      refetch: true
    };
  }

  if (typeof resolver === "undefined") {
    throw new Error("setQueryData is missing the first argument - it must be a resolver function");
  }

  var queryKey = getQueryKey(resolver, params);
  return new Promise(function (res) {
    queryClient.setQueryData(queryKey, newData);
    var result;

    if (opts.refetch) {
      result = invalidateQuery(resolver, params);
    }

    if (isClient) {
      // Fix for https://github.com/blitz-js/blitz/issues/1174
      requestIdleCallback(function () {
        res(result);
      });
    } else {
      res(result);
    }
  });
}

var BlitzProvider = function BlitzProvider(_ref) {
  var client = _ref.client,
      _ref$contextSharing = _ref.contextSharing,
      contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing,
      dehydratedState = _ref.dehydratedState,
      hydrateOptions = _ref.hydrateOptions,
      children = _ref.children;
  var queryClientRef = useRef();

  if (!queryClientRef.current) {
    queryClientRef.current = queryClient;
  }

  return /*#__PURE__*/React.createElement(QueryClientProvider, {
    client: client != null ? client : queryClient,
    contextSharing: contextSharing
  }, /*#__PURE__*/React.createElement(Hydrate, {
    state: dehydratedState,
    options: hydrateOptions
  }, children));
};

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var changedArray = function changedArray(a, b) {
  if (a === void 0) {
    a = [];
  }

  if (b === void 0) {
    b = [];
  }

  return (//eslint-disable-next-line es5/no-es6-static-methods
    a.length !== b.length || a.some(function (item, index) {
      return !Object.is(item, b[index]);
    })
  );
};

var initialState = {
  error: null
};

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;
    _this.updatedWithError = false;

    _this.resetErrorBoundary = function () {
      var _this$props;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);

      _this.reset();
    };

    _this.handleRouteChange = function () {
      clientDebug("Resetting error boundary on route change");
      _this.props.onReset == null ? void 0 : _this.props.onReset();

      _this.reset();
    };

    return _this;
  }

  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };

  var _proto = ErrorBoundary.prototype;

  _proto.reset = function reset() {
    this.updatedWithError = false;
    this.setState(initialState);
  };

  _proto.componentDidCatch = async function componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;

    if (error instanceof RedirectError) {
      var _this$context;

      clientDebug("Redirecting from ErrorBoundary to", error.url);
      await ((_this$context = this.context) == null ? void 0 : _this$context.push(error.url));
      return;
    }

    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
  };

  _proto.componentDidMount = function componentDidMount() {
    var _this$context2, _this$context2$events;

    var error = this.state.error;

    if (error !== null) {
      this.updatedWithError = true;
    } // Automatically reset on route change
    (_this$context2 = this.context) == null ? void 0 : (_this$context2$events = _this$context2.events) == null ? void 0 : _this$context2$events.on("routeChangeComplete", this.handleRouteChange);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$context3, _this$context3$events;
    (_this$context3 = this.context) == null ? void 0 : (_this$context3$events = _this$context3.events) == null ? void 0 : _this$context3$events.off("routeChangeComplete", this.handleRouteChange);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var error = this.state.error;
    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error
    // happens to *also* be in the resetKeys array, we'd end up resetting
    // the error boundary immediately. This would likely trigger a second
    // error to be thrown.
    // So we make sure that we don't check the resetKeys on the first call
    // of cDU after the error is set

    if (error !== null && !this.updatedWithError) {
      this.updatedWithError = true;
      return;
    }

    if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;

      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.reset();
    }
  };

  _proto.render = function render() {
    var error = this.state.error;
    var _this$props4 = this.props,
        fallbackRender = _this$props4.fallbackRender,
        FallbackComponent = _this$props4.FallbackComponent,
        fallback = _this$props4.fallback;

    if (error !== null) {
      var _props = {
        error: error,
        resetErrorBoundary: this.resetErrorBoundary
      };

      if (error instanceof RedirectError) {
        // Don't render children because redirect is imminent
        return null;
      } else if ( /*#__PURE__*/isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === "function") {
        return fallbackRender(_props);
      } else if (FallbackComponent) {
        return /*#__PURE__*/createElement(FallbackComponent, _props);
      } else {
        throw new Error("<ErrorBoundary> requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }

    return this.props.children;
  };

  return ErrorBoundary;
}(Component);

ErrorBoundary.contextType = RouterContext;

function withErrorBoundary(Component, errorBoundaryProps) {
  var Wrapped = function Wrapped(props) {
    return /*#__PURE__*/createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/createElement(Component, props));
  }; // Format for display in DevTools


  var name = Component.displayName || Component.name || "Unknown";
  Wrapped.displayName = "withErrorBoundary(" + name + ")";
  return Wrapped;
}

function useErrorHandler(givenError) {
  var _React$useState = useState(null),
      error = _React$useState[0],
      setError = _React$useState[1];

  if (givenError != null) throw givenError;
  if (error != null) throw error;
  return setError;
}
/*
eslint
  @typescript-eslint/no-throw-literal: "off",
  @typescript-eslint/prefer-nullish-coalescing: "off"
*/

// Taken from https://github.com/HenrikJoreteg/cookie-getter
// simple commonJS cookie reader, best perf according to http://jsperf.com/cookie-parsing
function readCookie(name) {
  if (typeof document === "undefined") return null;
  var cookie = document.cookie;
  var setPos = cookie.search(new RegExp("\\b" + name + "="));
  var stopPos = cookie.indexOf(";", setPos);
  var res;
  if (!~setPos) return null;
  res = decodeURIComponent(cookie.substring(setPos, ~stopPos ? stopPos : undefined).split("=")[1]);
  return res.charAt(0) === "{" ? JSON.parse(res) : res;
}
var setCookie = function setCookie(name, value, expires) {
  var result = name + "=" + value + ";path=/;expires=" + expires;
  document.cookie = result;
};
var deleteCookie = function deleteCookie(name) {
  return setCookie(name, "", "Thu, 01 Jan 1970 00:00:01 GMT");
};

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

var parsePublicDataToken = function parsePublicDataToken(token) {
  assert(token, "[parsePublicDataToken] Failed: token is empty");
  var publicDataStr = fromBase64(token);

  try {
    var publicData = JSON.parse(publicDataStr);
    return {
      publicData: publicData
    };
  } catch (error) {
    throw new Error("[parsePublicDataToken] Failed to parse publicDataStr: " + publicDataStr);
  }
};

var PublicDataStore = /*#__PURE__*/function () {
  function PublicDataStore() {
    var _this = this;

    this.eventKey = LOCALSTORAGE_PREFIX + "publicDataUpdated";
    this.emptyPublicData = {
      userId: null
    };
    this.observable = BadBehavior();

    if (typeof window !== "undefined") {
      // Set default value & prevent infinite loop
      this.updateState(undefined, {
        suppressEvent: true
      });
      window.addEventListener("storage", function (event) {
        if (event.key === _this.eventKey) {
          // Prevent infinite loop
          _this.updateState(undefined, {
            suppressEvent: true
          });
        }
      });
    }
  }

  var _proto = PublicDataStore.prototype;

  _proto.updateState = function updateState(value, opts) {
    // We use localStorage as a message bus between tabs.
    // Setting the current time in ms will cause other tabs to receive the `storage` event
    if (!(opts != null && opts.suppressEvent)) {
      // Prevent infinite loop
      try {
        localStorage.setItem(this.eventKey, Date.now().toString());
      } catch (err) {
        console.error("LocalStorage is not available", err);
      }
    }

    this.observable.next(value != null ? value : this.getData());
  };

  _proto.clear = function clear() {
    deleteCookie(COOKIE_PUBLIC_DATA_TOKEN());
    this.updateState(this.emptyPublicData);
  };

  _proto.getData = function getData() {
    var publicDataToken = this.getToken();

    if (!publicDataToken) {
      return this.emptyPublicData;
    }

    var _parsePublicDataToken = parsePublicDataToken(publicDataToken),
        publicData = _parsePublicDataToken.publicData;

    return publicData;
  };

  _proto.getToken = function getToken() {
    return readCookie(COOKIE_PUBLIC_DATA_TOKEN());
  };

  return PublicDataStore;
}();

var publicDataStore = /*#__PURE__*/new PublicDataStore();

var getAntiCSRFToken = function getAntiCSRFToken() {
  return readCookie(COOKIE_CSRF_TOKEN()) || readCookie(COOKIE_LEGACY_CSRF_TOKEN());
};
var useSession = function useSession(options) {
  var _options$suspense, _options;

  if (options === void 0) {
    options = {};
  }

  var suspense = (_options$suspense = (_options = options) == null ? void 0 : _options.suspense) != null ? _options$suspense : getBlitzRuntimeData().suspenseEnabled;
  var initialState;

  if (options.initialPublicData) {
    initialState = _extends({}, options.initialPublicData, {
      isLoading: false
    });
  } else if (suspense) {
    if (isServer) {
      throw new Promise(function (_) {});
    } else {
      initialState = _extends({}, publicDataStore.getData(), {
        isLoading: false
      });
    }
  } else {
    initialState = _extends({}, publicDataStore.emptyPublicData, {
      isLoading: true
    });
  }

  var _useState = useState(initialState),
      session = _useState[0],
      setSession = _useState[1];

  useEffect(function () {
    // Initialize on mount
    setSession(_extends({}, publicDataStore.getData(), {
      isLoading: false
    }));
    var subscription = publicDataStore.observable.subscribe(function (data) {
      return setSession(_extends({}, data, {
        isLoading: false
      }));
    });
    return subscription.unsubscribe;
  }, []);
  return session;
};
var useAuthenticatedSession = function useAuthenticatedSession(options) {
  if (options === void 0) {
    options = {};
  }

  useAuthorize();
  return useSession(options);
};
var useAuthorize = function useAuthorize() {
  useAuthorizeIf(true);
};
var useAuthorizeIf = function useAuthorizeIf(condition) {
  if (typeof window !== "undefined" && condition && !publicDataStore.getData().userId) {
    var error = new AuthenticationError();
    error.stack = null;
    throw error;
  }
};
var useRedirectAuthenticated = function useRedirectAuthenticated(to) {
  if (typeof window !== "undefined" && publicDataStore.getData().userId) {
    var error = new RedirectError(to);
    error.stack = null;
    throw error;
  }
};

var customCSS = "\n  body::before {\n    content: \"\";\n    display: block;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    z-index: 99999;\n    background-color: white;\n  }\n\n  .blitz-first-render-complete body::before {\n    display: none;\n  }\n";
var noscriptCSS = "\n  body::before {\n    content: none\n  }\n";

var NoPageFlicker = function NoPageFlicker() {
  return /*#__PURE__*/React.createElement(Head, null, /*#__PURE__*/React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: customCSS
    }
  }), /*#__PURE__*/React.createElement("noscript", null, /*#__PURE__*/React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: noscriptCSS
    }
  })));
};

function withBlitzInnerWrapper(Page) {
  var BlitzInnerRoot = function BlitzInnerRoot(props) {
    // We call useSession so this will rerender anytime session changes
    useSession({
      suspense: false
    });
    useAuthorizeIf(Page.authenticate === true);

    if (typeof window !== "undefined") {
      var publicData = publicDataStore.getData(); // We read directly from publicData.userId instead of useSession
      // so we can access userId on first render. useSession is always empty on first render

      if (publicData.userId) {
        clientDebug("[BlitzInnerRoot] logged in");
        var redirectAuthenticatedTo = typeof Page.redirectAuthenticatedTo === "function" ? Page.redirectAuthenticatedTo({
          session: publicData
        }) : Page.redirectAuthenticatedTo;

        if (redirectAuthenticatedTo) {
          var redirectUrl = typeof redirectAuthenticatedTo === "string" ? redirectAuthenticatedTo : formatWithValidation(redirectAuthenticatedTo);
          clientDebug("[BlitzInnerRoot] redirecting to", redirectUrl);
          var error = new RedirectError(redirectUrl);
          error.stack = null;
          throw error;
        }
      } else {
        clientDebug("[BlitzInnerRoot] logged out");
        var authenticate = Page.authenticate;

        if (authenticate && typeof authenticate === "object" && authenticate.redirectTo) {
          var redirectTo = authenticate.redirectTo;

          if (typeof redirectTo !== "string") {
            redirectTo = formatWithValidation(redirectTo);
          }

          var url = new URL(redirectTo, window.location.href);
          url.searchParams.append("next", window.location.pathname);
          clientDebug("[BlitzInnerRoot] redirecting to", url.toString());

          var _error = new RedirectError(url.toString());

          _error.stack = null;
          throw _error;
        }
      }
    }

    return /*#__PURE__*/React.createElement(Page, props);
  };

  for (var _i = 0, _Object$entries = Object.entries(Page); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
    BlitzInnerRoot[key] = value;
  }

  if (process.env.NODE_ENV !== "production") {
    BlitzInnerRoot.displayName = "BlitzInnerRoot";
  }

  return BlitzInnerRoot;
}
function withBlitzAppRoot(UserAppRoot) {
  var BlitzOuterRoot = function BlitzOuterRoot(props) {
    var component = React.useMemo(function () {
      return withBlitzInnerWrapper(props.Component);
    }, [props.Component]);
    var noPageFlicker = props.Component.suppressFirstRenderFlicker || props.Component.authenticate !== undefined || props.Component.redirectAuthenticatedTo;
    useEffect(function () {
      document.documentElement.classList.add("blitz-first-render-complete");
    }, []);
    var _props$pageProps = props.pageProps,
        dehydratedState = _props$pageProps.dehydratedState,
        _superjson = _props$pageProps._superjson;

    if (dehydratedState && _superjson) {
      var deserializedProps = SuperJSON.deserialize({
        json: {
          dehydratedState: dehydratedState
        },
        meta: _superjson
      });
      dehydratedState = deserializedProps == null ? void 0 : deserializedProps.dehydratedState;
    }

    return /*#__PURE__*/React.createElement(BlitzProvider, {
      dehydratedState: dehydratedState
    }, noPageFlicker && /*#__PURE__*/React.createElement(NoPageFlicker, null), /*#__PURE__*/React.createElement(UserAppRoot, _extends({}, props, {
      Component: component
    })));
  };

  return BlitzOuterRoot;
}

function useQuery(queryFn, params, options) {
  var _options$enabled, _options, _options2, _options3;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("useQuery is missing the first argument - it must be a query function");
  }

  var suspenseConfig = getBlitzRuntimeData().suspenseEnabled;
  var enabled = isServer && suspenseConfig ? false : (_options$enabled = (_options = options) == null ? void 0 : _options.enabled) != null ? _options$enabled : ((_options2 = options) == null ? void 0 : _options2.enabled) !== null;
  var suspense = enabled === false ? false : (_options3 = options) == null ? void 0 : _options3.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    enabled = false;
  }

  var routerIsReady = useRouter().isReady || isServer && suspenseConfig;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery = useQuery$1(_extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    enabled: enabled
  })),
      data = _useReactQuery.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery, ["data"]);

  if (queryRest.isIdle && isServer && suspenseConfig !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    throw new Promise(function () {});
  }

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestQueryResult<TResult>]


  return [data, rest];
} // -------------------------
// usePaginatedQuery
// -------------------------

function usePaginatedQuery(queryFn, params, options) {
  var _options4, _options5, _options6;

  if (options === void 0) {
    options = {};
  }

  if (typeof queryFn === "undefined") {
    throw new Error("usePaginatedQuery is missing the first argument - it must be a query function");
  }

  var suspense = ((_options4 = options) == null ? void 0 : _options4.enabled) === false || ((_options5 = options) == null ? void 0 : _options5.enabled) === null ? false : (_options6 = options) == null ? void 0 : _options6.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, params);

  var _useReactQuery2 = useQuery$1(_extends({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? function () {
      return enhancedResolverRpcClient(params, {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options, {
    keepPreviousData: true
  })),
      data = _useReactQuery2.data,
      queryRest = _objectWithoutPropertiesLoose(_useReactQuery2, ["data"]);

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, params)); // return [data, rest as RestPaginatedResult<TResult>]


  return [data, rest];
} // -------------------------
// useInfiniteQuery
// -------------------------

function useInfiniteQuery(queryFn, getQueryParams, options) {
  if (typeof queryFn === "undefined") {
    throw new Error("useInfiniteQuery is missing the first argument - it must be a query function");
  }

  var suspense = (options == null ? void 0 : options.enabled) === false || (options == null ? void 0 : options.enabled) === null ? false : options == null ? void 0 : options.suspense;
  var session = useSession({
    suspense: suspense
  });

  if (session.isLoading) {
    options.enabled = false;
  }

  var routerIsReady = useRouter().isReady;
  var enhancedResolverRpcClient = sanitizeQuery(queryFn);
  var queryKey = getQueryKey(queryFn, getQueryParams);

  var _useInfiniteReactQuer = useInfiniteQuery$1(_extends({
    // we need an extra cache key for infinite loading so that the cache for
    // for this query is stored separately since the hook result is an array of results.
    // Without this cache for usePaginatedQuery and this will conflict and break.
    queryKey: routerIsReady ? [].concat(queryKey, ["infinite"]) : ["_routerNotReady_"],
    queryFn: routerIsReady ? function (_ref) {
      var pageParam = _ref.pageParam;
      return enhancedResolverRpcClient(getQueryParams(pageParam), {
        fromQueryHook: true
      });
    } : emptyQueryFn
  }, options)),
      data = _useInfiniteReactQuer.data,
      queryRest = _objectWithoutPropertiesLoose(_useInfiniteReactQuer, ["data"]);

  var rest = _extends({}, queryRest, getQueryCacheFunctions(queryFn, getQueryParams), {
    pageParams: data == null ? void 0 : data.pageParams
  });

  return [data == null ? void 0 : data.pages, rest];
}

var executeRpcCall = function executeRpcCall(apiUrl, params, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (!opts.fromQueryHook && !opts.fromInvoke) {
    console.warn("[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)");
  }

  if (isServer) return Promise.resolve();
  clientDebug("Starting request for", apiUrl, "with", params, "and", opts);
  var headers = {
    "Content-Type": "application/json"
  };
  var antiCSRFToken = getAntiCSRFToken();

  if (antiCSRFToken) {
    clientDebug("Adding antiCSRFToken cookie header", antiCSRFToken);
    headers[HEADER_CSRF] = antiCSRFToken;
  } else {
    clientDebug("No antiCSRFToken cookie found");
  }

  var serialized;

  if (opts.alreadySerialized) {
    // params is already serialized with superjson when it gets here
    // We have to serialize the params before passing to react-query in the query key
    // because otherwise react-query will use JSON.parse(JSON.stringify)
    // so by the time the arguments come here the real JS objects are lost
    serialized = params;
  } else {
    serialized = serialize(params);
  } // Create a new AbortController instance for this request


  var controller = new AbortController();
  var promise = window.fetch(addBasePath(apiUrl), {
    method: "POST",
    headers: headers,
    credentials: "include",
    redirect: "follow",
    body: JSON.stringify({
      params: serialized.json,
      meta: {
        params: serialized.meta
      }
    }),
    signal: controller.signal
  }).then(async function (response) {
    clientDebug("Received request for", apiUrl);

    if (response.headers) {
      if (response.headers.get(HEADER_PUBLIC_DATA_TOKEN)) {
        publicDataStore.updateState();
        clientDebug("Public data updated");
      }

      if (response.headers.get(HEADER_SESSION_REVOKED)) {
        clientDebug("Session revoked, clearing publicData");
        publicDataStore.clear();
        setTimeout(async function () {
          // Do these in the next tick to prevent various bugs like https://github.com/blitz-js/blitz/issues/2207
          clientDebug("Clearing and invalidating react-query cache...");
          await queryClient.cancelQueries();
          await queryClient.resetQueries();
          queryClient.getMutationCache().clear(); // We have a 100ms delay here to prevent unnecessary stale queries from running
          // This prevents the case where you logout on a page with
          // Page.authenticate = {redirectTo: '/login'}
          // Without this delay, queries that require authentication on the original page
          // will still run (but fail because you are now logged out)
          // Ref: https://github.com/blitz-js/blitz/issues/1935
        }, 100);
      }

      if (response.headers.get(HEADER_SESSION_CREATED)) {
        clientDebug("Session created"); // await queryClient.invalidateQueries("")

        setTimeout(async function () {
          // Do these in the next tick to prevent various bugs like https://github.com/blitz-js/blitz/issues/2207
          clientDebug("Invalidating react-query cache...");
          await queryClient.cancelQueries();
          await queryClient.resetQueries();
        });
      }

      if (response.headers.get(HEADER_CSRF_ERROR)) {
        var err = new CSRFTokenMismatchError();
        err.stack = null;
        throw err;
      }
    }

    if (!response.ok) {
      var error = new Error(response.statusText);
      error.statusCode = response.status;
      error.path = apiUrl;
      error.stack = null;
      throw error;
    } else {
      var payload;

      try {
        payload = await response.json();
      } catch (error) {
        var _err = new Error("Failed to parse json from " + apiUrl);

        _err.stack = null;
        throw _err;
      }

      if (payload.error) {
        var _payload$meta;

        var _error = deserialize({
          json: payload.error,
          meta: (_payload$meta = payload.meta) == null ? void 0 : _payload$meta.error
        }); // We don't clear the publicDataStore for anonymous users


        if (_error.name === "AuthenticationError" && publicDataStore.getData().userId) {
          publicDataStore.clear();
        }

        var prismaError = _error.message.match(/invalid.*prisma.*invocation/i);

        if (prismaError && !("code" in _error)) {
          _error = new Error(prismaError[0]);
          _error.statusCode = 500;
        }

        _error.stack = null;
        throw _error;
      } else {
        var _payload$meta2;

        var data = deserialize({
          json: payload.result,
          meta: (_payload$meta2 = payload.meta) == null ? void 0 : _payload$meta2.result
        });

        if (!opts.fromQueryHook) {
          var queryKey = getQueryKeyFromUrlAndParams(apiUrl, params);
          queryClient.setQueryData(queryKey, data);
        }

        return data;
      }
    }
  }); // Disable react-query request cancellation for now
  // Having too many weird bugs with it enabled
  // promise.cancel = () => controller.abort()

  return promise;
};

executeRpcCall.warm = function (apiUrl) {
  if (!isClient) {
    return;
  }

  return window.fetch(addBasePath(apiUrl), {
    method: "HEAD"
  });
};

var ensureTrailingSlash = function ensureTrailingSlash(url) {
  var lastChar = url.substr(-1);

  if (lastChar !== "/") {
    url = url + "/";
  }

  return url;
};

var getApiUrlFromResolverFilePath = function getApiUrlFromResolverFilePath(resolverFilePath) {
  var url = resolverFilePath.replace(/^app\/_resolvers/, "/api");
  return getBlitzRuntimeData().trailingSlash ? ensureTrailingSlash(url) : url;
};

function getIsomorphicEnhancedResolver( // resolver is undefined on the client
resolver, resolverFilePath, resolverName, resolverType, target, options) {
  if (target === void 0) {
    target = isClient ? "client" : "server";
  }

  if (options === void 0) {
    options = {};
  }

  var apiUrl = getApiUrlFromResolverFilePath(resolverFilePath);

  if (target === "client") {
    var resolverRpc = function resolverRpc(params, opts) {
      return executeRpcCall(apiUrl, params, opts);
    };

    var enhancedResolverRpcClient = resolverRpc;
    enhancedResolverRpcClient._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    }; // Warm the lambda

    if (options.warmApiEndpoints) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      executeRpcCall.warm(apiUrl);
    }

    return enhancedResolverRpcClient;
  } else {
    if (!resolver) throw new Error("resolver is missing on the server");
    var enhancedResolver = resolver["default"];
    enhancedResolver.middleware = resolver.middleware;
    enhancedResolver.config = resolver.config;
    enhancedResolver._meta = {
      name: resolverName,
      type: resolverType,
      filePath: resolverFilePath,
      apiUrl: apiUrl
    };
    return enhancedResolver;
  }
}

/*
 * We have to override react-query's MutationFunction and MutationResultPair
 * types so because we have throwOnError:true by default. And by the RQ types
 * have the mutate function result typed as TData|undefined which isn't typed
 * properly with throwOnError.
 *
 * So this fixes that.
 */

function useMutation(mutationResolver, config) {
  var enhancedResolverRpcClient = sanitizeMutation(mutationResolver);

  var _useReactQueryMutatio = useMutation$1(function (variables) {
    return enhancedResolverRpcClient(variables, {
      fromQueryHook: true
    });
  }, _extends({
    throwOnError: true
  }, config));
      _useReactQueryMutatio.mutate;
      var mutateAsync = _useReactQueryMutatio.mutateAsync,
      rest = _objectWithoutPropertiesLoose(_useReactQueryMutatio, ["mutate", "mutateAsync"]);

  return [mutateAsync, rest];
}

function invoke(queryFn, params) {
  if (typeof queryFn === "undefined") {
    throw new Error("invoke is missing the first argument - it must be a query or mutation function");
  }

  if (isClient) {
    var fn = queryFn;
    return fn(params, {
      fromInvoke: true
    });
  } else {
    var _fn = queryFn;
    return _fn(params);
  }
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

var enhancePrisma = function enhancePrisma(client) {
  return new Proxy(client, {
    construct: function construct(target, args) {
      if (typeof window !== "undefined" && process.env.JEST_WORKER_ID === undefined) {
        // Return object with $use method if in the browser
        // Skip in Jest tests because window is defined in Jest tests
        return {
          $use: function $use() {}
        };
      }

      if (!global._blitz_prismaClient) {
        var _client = _construct(target, args);

        _client.$reset = async function reset() {
          if (process.env.NODE_ENV === "production") {
            throw new Error("You are calling db.$reset() in a production environment. We think you probably didn't mean to do that, so we are throwing this error instead of destroying your life's work.");
          }

          var prismaBin = which(process.cwd()).sync("prisma");
          await new Promise(function (res, rej) {
            var process = spawn(prismaBin, ["migrate", "reset", "--force", "--skip-generate"], {
              stdio: "ignore"
            });
            process.on("exit", function (code) {
              return code === 0 ? res(0) : rej(code);
            });
          });

          global._blitz_prismaClient.$disconnect();
        };

        global._blitz_prismaClient = _client;
      }

      return global._blitz_prismaClient;
    }
  });
};

export { BlitzProvider, ErrorBoundary, Router, enhancePrisma, getAntiCSRFToken, getIsomorphicEnhancedResolver, getQueryKey, invalidateQuery, invoke, queryClient, _setQueryData as setQueryData, useAuthenticatedSession, useAuthorize, useErrorHandler, useInfiniteQuery, useMutation, usePaginatedQuery, useParam, useParams, useQuery, useRedirectAuthenticated, useRouter, useRouterQuery, useSession, withBlitzAppRoot, withErrorBoundary, withRouter };
