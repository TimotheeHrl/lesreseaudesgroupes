import { UseInfiniteQueryOptions, UseInfiniteQueryResult, UseQueryOptions, UseQueryResult } from "react-query";
import { FirstParam, PromiseReturnType, QueryFn } from "./types";
import { QueryCacheFunctions } from "./utils/react-query-utils";
declare type QueryLazyOptions = {
    suspense: unknown;
} | {
    enabled: unknown;
};
declare type QueryNonLazyOptions = {
    suspense: true;
    enabled?: never;
} | {
    suspense?: never;
    enabled: true;
} | {
    suspense: true;
    enabled: true;
} | {
    suspense?: never;
    enabled?: never;
};
declare type RestQueryResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, "data"> & QueryCacheFunctions<TResult>;
export declare function useQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestQueryResult<TSelectedData, TError>];
export declare function useQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestQueryResult<TSelectedData, TError>];
declare type RestPaginatedResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, "data"> & QueryCacheFunctions<TResult>;
export declare function usePaginatedQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestPaginatedResult<TSelectedData, TError>];
export declare function usePaginatedQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestPaginatedResult<TSelectedData, TError>];
interface RestInfiniteResult<TResult, TError> extends Omit<UseInfiniteQueryResult<TResult, TError>, "data">, QueryCacheFunctions<TResult> {
    pageParams: any;
}
interface InfiniteQueryConfig<TResult, TError, TSelectedData> extends UseInfiniteQueryOptions<TResult, TError, TSelectedData, TResult> {
}
export declare function useInfiniteQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData[], RestInfiniteResult<TSelectedData, TError>];
export declare function useInfiniteQuery<T extends QueryFn, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData[] | undefined, RestInfiniteResult<TSelectedData, TError>];
export {};
