'use strict';

var blitzData = require('./blitz-data-173dd352.cjs.dev.js');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var TOKEN_SEPARATOR = ";";
var HANDLE_SEPARATOR = ":";
var SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = "ots";
var SESSION_TYPE_ANONYMOUS_JWT = "ajwt";
var SESSION_TOKEN_VERSION_0 = "v0";
var COOKIE_ANONYMOUS_SESSION_TOKEN = function COOKIE_ANONYMOUS_SESSION_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sAnonymousSessionToken";
};
var COOKIE_SESSION_TOKEN = function COOKIE_SESSION_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sSessionToken";
};
var COOKIE_REFRESH_TOKEN = function COOKIE_REFRESH_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sIdRefreshToken";
};
var COOKIE_CSRF_TOKEN = function COOKIE_CSRF_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sAntiCsrfToken";
}; // TODO remove before 1.0 -
// This is here for legacy compatability (misspelling)

var COOKIE_LEGACY_CSRF_TOKEN = function COOKIE_LEGACY_CSRF_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sAntiCrfToken";
};
var COOKIE_PUBLIC_DATA_TOKEN = function COOKIE_PUBLIC_DATA_TOKEN() {
  return blitzData.getBlitzRuntimeData().sessionCookiePrefix + "_sPublicDataToken";
}; // Headers always all lower case

var HEADER_CSRF = "anti-csrf";
var HEADER_PUBLIC_DATA_TOKEN = "public-data-token";
var HEADER_SESSION_CREATED = "session-created";
var HEADER_SESSION_REVOKED = "session-revoked";
var HEADER_CSRF_ERROR = "csrf-error";
var LOCALSTORAGE_PREFIX = "_blitz-";

exports.COOKIE_ANONYMOUS_SESSION_TOKEN = COOKIE_ANONYMOUS_SESSION_TOKEN;
exports.COOKIE_CSRF_TOKEN = COOKIE_CSRF_TOKEN;
exports.COOKIE_LEGACY_CSRF_TOKEN = COOKIE_LEGACY_CSRF_TOKEN;
exports.COOKIE_PUBLIC_DATA_TOKEN = COOKIE_PUBLIC_DATA_TOKEN;
exports.COOKIE_REFRESH_TOKEN = COOKIE_REFRESH_TOKEN;
exports.COOKIE_SESSION_TOKEN = COOKIE_SESSION_TOKEN;
exports.HANDLE_SEPARATOR = HANDLE_SEPARATOR;
exports.HEADER_CSRF = HEADER_CSRF;
exports.HEADER_CSRF_ERROR = HEADER_CSRF_ERROR;
exports.HEADER_PUBLIC_DATA_TOKEN = HEADER_PUBLIC_DATA_TOKEN;
exports.HEADER_SESSION_CREATED = HEADER_SESSION_CREATED;
exports.HEADER_SESSION_REVOKED = HEADER_SESSION_REVOKED;
exports.LOCALSTORAGE_PREFIX = LOCALSTORAGE_PREFIX;
exports.SESSION_TOKEN_VERSION_0 = SESSION_TOKEN_VERSION_0;
exports.SESSION_TYPE_ANONYMOUS_JWT = SESSION_TYPE_ANONYMOUS_JWT;
exports.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
exports.TOKEN_SEPARATOR = TOKEN_SEPARATOR;
exports._createForOfIteratorHelperLoose = _createForOfIteratorHelperLoose;
exports._extends = _extends;
