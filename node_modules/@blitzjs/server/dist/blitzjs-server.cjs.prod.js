'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filePipeline = require('@blitzjs/file-pipeline');
var fs = require('fs-extra');
var path = require('path');
var fs$1 = require('fs');
var display = require('@blitzjs/display');
var spawn = require('cross-spawn');
var expandTilde = require('expand-tilde');
var fastGlob = require('fast-glob');
var partition = require('lodash/partition');
var parseGitignore = require('parse-gitignore');
var pkgDir = require('pkg-dir');
var resolveCwd = require('resolve-cwd');
var config = require('@blitzjs/config');
var detect = require('detect-port');
var esbuild = require('esbuild');
var slash = require('slash');
var File = require('vinyl');
var through = require('through2');
require('parallel-transform');
var pumpify = require('pumpify');
var debounce = require('lodash/debounce');
var lodash = require('lodash');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var fs__default = /*#__PURE__*/_interopDefault(fs$1);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var expandTilde__default = /*#__PURE__*/_interopDefault(expandTilde);
var fastGlob__default = /*#__PURE__*/_interopDefault(fastGlob);
var partition__default = /*#__PURE__*/_interopDefault(partition);
var parseGitignore__default = /*#__PURE__*/_interopDefault(parseGitignore);
var pkgDir__default = /*#__PURE__*/_interopDefault(pkgDir);
var resolveCwd__default = /*#__PURE__*/_interopDefault(resolveCwd);
var detect__default = /*#__PURE__*/_interopDefault(detect);
var slash__default = /*#__PURE__*/_interopDefault(slash);
var File__default = /*#__PURE__*/_interopDefault(File);
var through__default = /*#__PURE__*/_interopDefault(through);
var pumpify__default = /*#__PURE__*/_interopDefault(pumpify);
var debounce__default = /*#__PURE__*/_interopDefault(debounce);

var blitzVersionFilename = "_blitz-version.txt";
function getBlitzVersion() {
  try {
    var pkgJson = require("blitz/package.json");

    return pkgJson.version;
  } catch (_unused) {
    return "";
  }
}
async function isVersionMatched(buildFolder) {
  if (buildFolder === void 0) {
    buildFolder = ".blitz/build";
  }

  var versionStore = path.resolve(buildFolder, blitzVersionFilename);
  if (!(await fs.pathExists(versionStore))) return false;

  try {
    var buffer = await fs.readFile(versionStore);
    var version = getBlitzVersion();
    var read = buffer.toString().trim().replace("\n", "");
    return read === version;
  } catch (err) {
    return false;
  }
}
async function saveBlitzVersion(buildFolder) {
  if (buildFolder === void 0) {
    buildFolder = ".blitz/build";
  }

  var versionStore = path.resolve(buildFolder, blitzVersionFilename);
  var version = getBlitzVersion();
  await fs.writeFile(versionStore, version);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var _process$env$GIT_DIR = process.env.GIT_DIR,
    GIT_DIR = _process$env$GIT_DIR === void 0 ? ".git" : _process$env$GIT_DIR;

function globalGitIgnore() {
  var versionResult = spawn__default['default'].sync("git", ["version"]);

  if (!(versionResult.status === 0)) {
    display.log.warning("Git doesn't seem to be installed. Get it here: https://git-scm.com/downloads.");
    return null;
  }

  var configResult = spawn__default['default'].sync("git", ["config", "--get", "core.excludesfile"], {
    stdio: "pipe"
  });

  if (!(configResult.status === 0)) {
    // Git config core.excludesFile is unset. Inferring .gitignore file locations.
    return null;
  }

  var output = String(configResult.stdout).trim();
  return process.platform === "win32" ? output : expandTilde__default['default'](output);
}

function isControlledByUser(file) {
  if (file.startsWith("node_modules")) {
    return false;
  }

  return true;
}
function getAllGitIgnores(rootFolder) {
  var globalIgnore = globalGitIgnore();
  var localRepoIgnore = GIT_DIR + "/info/exclude";
  var files = fastGlob__default['default'].sync([localRepoIgnore, "**/.gitignore", "**/" + localRepoIgnore], {
    cwd: rootFolder
  });
  if (fs__default['default'].existsSync(globalIgnore)) files.push(globalIgnore);
  return files.filter(isControlledByUser).map(function (file) {
    var prefix = "";
    if (file.match(localRepoIgnore)) prefix = file.split(localRepoIgnore)[0];else if (file.match(globalIgnore)) prefix = "";else prefix = file.split(".gitignore")[0];
    return {
      gitIgnore: fs__default['default'].readFileSync(file, {
        encoding: "utf8"
      }),
      prefix: prefix
    };
  });
}
function chokidarRulesFromGitignore(_ref) {
  var gitIgnore = _ref.gitIgnore,
      prefix = _ref.prefix;
  var rules = parseGitignore__default['default'](gitIgnore);

  var isInclusionRule = function isInclusionRule(rule) {
    return rule.startsWith("!");
  };

  var _partition = partition__default['default'](rules, isInclusionRule),
      includePaths = _partition[0],
      ignoredPaths = _partition[1];

  var trimExclamationMark = function trimExclamationMark(rule) {
    return rule.substring(1);
  };

  var prefixPath = function prefixPath(_rule) {
    var rule = _rule.startsWith("/") ? _rule.substring(1) : _rule;

    if (!prefix) {
      return rule;
    } else {
      return prefix + rule;
    }
  };

  return {
    includePaths: includePaths.map(trimExclamationMark).map(prefixPath),
    ignoredPaths: ignoredPaths.map(prefixPath)
  };
}
function parseChokidarRulesFromGitignore(rootFolder) {
  var result = {
    includePaths: [],
    ignoredPaths: []
  };
  getAllGitIgnores(rootFolder).map(chokidarRulesFromGitignore).forEach(function (_ref2) {
    var _result$includePaths, _result$ignoredPaths;

    var ignoredPaths = _ref2.ignoredPaths,
        includePaths = _ref2.includePaths;

    (_result$includePaths = result.includePaths).push.apply(_result$includePaths, includePaths);

    (_result$ignoredPaths = result.ignoredPaths).push.apply(_result$ignoredPaths, ignoredPaths);
  });
  return result;
}

async function resolveBinAsync(pkg, executable) {
  if (executable === void 0) {
    executable = pkg;
  }

  var packageDir = await pkgDir__default['default'](resolveCwd__default['default'](pkg));
  if (!packageDir) throw new Error("Could not find package.json for '" + pkg + "'");

  var _await$readJSON = await fs.readJSON(path__default['default'].join(packageDir, "package.json")),
      bin = _await$readJSON.bin;

  var binPath = typeof bin === "object" ? bin[executable] : bin;
  if (!binPath) throw new Error("No bin '" + executable + "' in module '" + pkg + "'");
  return path__default['default'].join(packageDir, binPath);
}

var standardBuildFolderPath = ".blitz/build";
var standardBuildFolderPathRegex = /\.blitz[\\/]build[\\/]/g; // https://stackoverflow.com/questions/20010199/how-to-determine-if-a-process-runs-inside-lxc-docker

function isInDocker() {
  var cgroupFile = path.join("proc", "self", "cgroup");

  if (fs__default['default'].existsSync(cgroupFile)) {
    var content = fs__default['default'].readFileSync(cgroupFile, "utf-8");
    return content.includes("docker");
  }

  return false;
}

var defaults = {
  hostname: /*#__PURE__*/isInDocker() ? "0.0.0.0" : "127.0.0.1",
  // -
  env: "prod",
  // -
  buildFolder: standardBuildFolderPath,
  routesFolder: ".blitz/routes",
  // -
  writeManifestFile: true,
  // -
  ignoredPaths: ["./build/**/*", "**/.blitz-*/**/*", "**/.blitz/**/*", "**/.heroku/**/*", "**/.profile.d/**/*", "**/.cache/**/*", "./.config/**/*", "**/.DS_Store", "**/.git/**/*", "**/.next/**/*", "**/*.log", "**/.vercel/**/*", "**/.now/**/*", "**/*.pnp.js", "**/*.sqlite*", "coverage/**/*", ".coverage/**/*", "dist/**/*", "**/node_modules/**/*", "cypress/**/*", "test/**/*", "tests/**/*", "spec/**/*", "specs/**/*", "**/*.test.*", "**/*.spec.*", "**/.yalc/**/*"],
  includePaths: ["**/*"]
};
async function normalize(config) {
  var _config$hostname, _config$buildFolder, _config$routesFolder, _config$isTypeScript, _config$watch, _config$transformFile, _config$writeManifest;

  var rootFolder = path.resolve(process.cwd(), config.rootFolder);
  var git = parseChokidarRulesFromGitignore(rootFolder);
  var env = config.env || defaults.env;
  return _extends({}, config, {
    hostname: (_config$hostname = config.hostname) != null ? _config$hostname : defaults.hostname,
    env: env,
    // -
    rootFolder: rootFolder,
    buildFolder: path.resolve(rootFolder, (_config$buildFolder = config.buildFolder) != null ? _config$buildFolder : defaults.buildFolder),
    routesFolder: path.resolve(rootFolder, (_config$routesFolder = config.routesFolder) != null ? _config$routesFolder : defaults.routesFolder),
    // -
    isTypeScript: (_config$isTypeScript = config.isTypeScript) != null ? _config$isTypeScript : await getIsTypeScript(rootFolder),
    watch: (_config$watch = config.watch) != null ? _config$watch : env === "dev",
    clean: config.clean,
    // -
    transformFiles: (_config$transformFile = config.transformFiles) != null ? _config$transformFile : filePipeline.transformFiles,
    writeManifestFile: (_config$writeManifest = config.writeManifestFile) != null ? _config$writeManifest : defaults.writeManifestFile,
    // -
    ignore: defaults.ignoredPaths.concat(git.ignoredPaths),
    include: defaults.includePaths.concat(git.includePaths),
    // -
    nextBin: await getNextBin(rootFolder, env === "dev")
  });
}

async function getNextBin(rootFolder, usePatched) {
  if (usePatched === void 0) {
    usePatched = false;
  }

  // do not await for both bin-pkg because just one is used at a time
  var nextBinPkg = usePatched ? "@blitzjs/server" : "next";
  var nextBinExec = usePatched ? "next-patched" : undefined;
  var nextBin = await resolveBinAsync(nextBinPkg, nextBinExec);
  return path.resolve(rootFolder, nextBin);
}

async function getIsTypeScript(rootFolder) {
  try {
    await fs$1.promises.access(path.join(rootFolder, "tsconfig.json"));
    return true;
  } catch (_unused) {
    return false;
  }
}

var absolutePathTransform = function absolutePathTransform(sourceFolder) {
  if (sourceFolder === void 0) {
    sourceFolder = "";
  }

  return function (relativeTransformer) {
    return function (filePath) {
      var startingPath = path.relative(sourceFolder, filePath);
      var transformedPath = relativeTransformer(startingPath);
      return path.resolve(sourceFolder, transformedPath);
    };
  };
};

var debug$1 = /*#__PURE__*/require("debug")("blitz:stage:rpc");

var resolverFullBuildPathRegex = /[\\/]app[\\/]_resolvers[\\/]/;
var resolverBuildFolderReplaceRegex = /_resolvers[\\/]/g;
var resolverPathRegex = /(?:app[\\/])(?!_resolvers).*(?:queries|mutations)[\\/].+/;
function isResolverPath(filePath) {
  return resolverPathRegex.exec(filePath);
}

var isomorhicHandlerTemplateClient = function isomorhicHandlerTemplateClient(resolverFilePath, resolverName, resolverType, warmApiEndpoints) {
  return "\nimport {getIsomorphicEnhancedResolver} from '@blitzjs/core'\nexport * from '" + resolverFilePath + "'\nexport default getIsomorphicEnhancedResolver(\n  undefined,\n  '" + resolverFilePath + "',\n  '" + resolverName + "',\n  '" + resolverType + "',\n  undefined,\n  {\n    warmApiEndpoints: " + warmApiEndpoints + "\n  }\n)\n";
};

var isomorhicHandlerTemplateServer = function isomorhicHandlerTemplateServer(resolverFilePath, resolverName, resolverType, warmApiEndpoints) {
  return "\nimport {getIsomorphicEnhancedResolver} from '@blitzjs/core'\nimport * as resolverModule from '" + resolverFilePath + "'\nexport * from '" + resolverFilePath + "'\nexport default getIsomorphicEnhancedResolver(\n  resolverModule,\n  '" + resolverFilePath + "',\n  '" + resolverName + "',\n  '" + resolverType + "',\n  undefined,\n  {\n    warmApiEndpoints: " + warmApiEndpoints + "\n  }\n)\n";
};

var apiHandlerTemplate = function apiHandlerTemplate(originalPath, useTypes, useDb) {
  return "\n// This imports the output of getIsomorphicEnhancedResolver()\nimport enhancedResolver from '" + originalPath + "'\nimport {getAllMiddlewareForModule} from '@blitzjs/core/server'\nimport {rpcApiHandler} from '@blitzjs/core/server'\n\nlet db" + (useTypes ? ": any" : "") + "\nlet connect" + (useTypes ? ": any" : "") + "\n\n" + (useDb ? "\ndb = require('db').default\nif (require('db').connect) {\n  connect = require('db').connect\n} else if (db?.$connect || db?.connect) {\n  connect = () => db.$connect ? db.$connect() : db.connect()\n} else {\n  connect = () => {}\n}" : "") + "\n\nexport default rpcApiHandler(\n  enhancedResolver,\n  getAllMiddlewareForModule(enhancedResolver),\n  () => db && connect?.(),\n)\n\nexport const config = {\n  ...enhancedResolver.config,\n  api: {\n    ...enhancedResolver.config?.[\"api\"],\n    externalResolver: true,\n  },\n}\n";
};
/**
 * Returns a Stage that manages generating the internal RPC commands and handlers
 */


var createStageRpc = function createStageRpc(isTypeScript) {
  if (isTypeScript === void 0) {
    isTypeScript = true;
  }

  return function configure(_ref) {
    var _target$includes;

    var src = _ref.config.src;
    var fileTransformer = absolutePathTransform(src);
    var getResolverPath = fileTransformer(resolverFilePath);
    var getApiHandlerPath = fileTransformer(apiHandlerPath);

    var _getConfig = config.getConfig(),
        target = _getConfig.target;

    var warmApiEndpoints = (_target$includes = target == null ? void 0 : target.includes("serverless")) != null ? _target$includes : false;
    var stream = filePipeline.transform.file(function (file, _ref2) {
      var next = _ref2.next,
          push = _ref2.push;

      if (!isResolverPath(file.path)) {
        return file;
      }

      debug$1("Event:", file.event);
      var originalPath = resolutionPath(src, file.path);
      var resolverImportPath = resolverFilePath(originalPath);

      var _extractTemplateVars = extractTemplateVars(resolverImportPath),
          resolverType = _extractTemplateVars.resolverType,
          resolverName = _extractTemplateVars.resolverName; // Isomorphic client - original file path


      push(new File__default['default']({
        path: file.path,
        contents: Buffer.from(isomorhicHandlerTemplateServer(resolverImportPath, resolverName, resolverType, warmApiEndpoints)),
        event: file.event
      }));
      push(new File__default['default']({
        path: getResolverPath(file.path),
        contents: file.contents,
        // Appending a new file to the output of this particular stream
        // We don't want to reprocess this file but simply add it to the output
        // of the stream here we provide a hash with some information for how
        // this file came to be here
        hash: [file.hash, "rpc", "resolver"].join("|"),
        event: file.event
      })); // File API route handler

      if (["add", "unlink"].includes(file.event)) {
        push(new File__default['default']({
          path: getApiHandlerPath(file.path),
          contents: Buffer.from(apiHandlerTemplate(originalPath, isTypeScript, fs$1.existsSync("db/index." + (isTypeScript ? "ts" : "js")))),
          // Appending a new file to the output of this particular stream
          // We don't want to reprocess this file but simply add it to the output
          // of the stream here we provide a hash with some information for how
          // this file came to be here
          hash: [file.hash, "rpc", "handler"].join("|"),
          event: file.event === "add" ? "add" : "unlink",
          originalPath: file.path,
          originalRelative: file.relative
        }));
      } // Isomorphic client with export


      if (["add", "unlink"].includes(file.event)) {
        // For some reason, setting `clientWithExport.basename` doesn't work like it should
        // so we have to set the basename with this temp file
        var temp = new File__default['default']({
          path: file.path
        });
        temp.basename = clientResolverBasename(temp.basename);
        var clientWithExport = new File__default['default']({
          path: temp.path,
          contents: Buffer.from(isomorhicHandlerTemplateClient(resolverImportPath, resolverName, resolverType, warmApiEndpoints)),
          hash: [file.hash, "rpc", "client"].join("|"),
          event: file.event === "add" ? "add" : "unlink",
          originalPath: file.path,
          originalRelative: file.relative
        });
        push(clientWithExport);
      }

      return next();
    });
    return {
      stream: stream
    };
  };
};

function removeExt(filePath) {
  return filePath.replace(/[.][^./\s]+$/, "");
}

function resolutionPath(srcPath, filePath) {
  return removeExt(slash__default['default'](path.relative(srcPath, filePath)));
}

function extractTemplateVars(resolverImportPath) {
  var _ref3 = /(queries|mutations)\/(.*)$/.exec(resolverImportPath) || [],
      resolverTypePlural = _ref3[1],
      resolverName = _ref3[2];

  var resolverType = resolverTypePlural === "mutations" ? "mutation" : "query";
  return {
    resolverImportPath: resolverImportPath,
    resolverType: resolverType,
    resolverName: resolverName
  };
}

function resolverFilePath(path) {
  return path.replace(/^app/, "app/_resolvers");
}

function apiHandlerPath(path) {
  return path.replace(/^app/, "pages/api");
}
/**
 * "query.ts" => "query.client.ts"
 */


function clientResolverBasename(basename) {
  var parts = basename.split(".");
  parts.splice(parts.length - 1, 0, "client");
  return parts.join(".");
}

// The following are a loose collaction of stream

/*#__PURE__*/require("from2");

/*#__PURE__*/require("flush-write-stream");

// const pipeline = (pumpifyFn as any) as PumpifyFn & {obj: PumpifyFn}
/*#__PURE__*/pumpify__default['default'].ctor({
  autoDestroy: false,
  destroy: false,
  objectMode: true,
  highWaterMark: 160
});

var pathToGlobalRegex = function pathToGlobalRegex(path) {
  return new RegExp(path.replace(/\//g, "\\/"), "g");
};

function createOutputTransformer(buildFolder, manifest) {
  var projectRoot = config.getProjectRoot();
  var stream = through__default['default'](function (data, _, next) {
    var outputStr = data.toString(); // Remove the blitz build path from the output path so that the
    // printed path is the original file path

    outputStr = outputStr.replace(standardBuildFolderPathRegex, ""); // If find a resolver path, restore printed path to original path

    if (outputStr.match(resolverFullBuildPathRegex)) {
      outputStr = outputStr.replace(resolverBuildFolderReplaceRegex, "");
    }

    if (outputStr.match(/Error:.*find.*production build/)) {
      outputStr = display.log.withError("Could not find a production build, you must run `blitz build` before starting\n\n");
    } else if (manifest) {
      /*
       * Here we look any page files that got moved during the compilation step.
       * And then replace the compiled path with the original path
       */
      var pageMatches = /[\\/](pages[\\/].*.(j|t)sx?)/g.exec(outputStr);

      if (pageMatches) {
        var fullMatch = pageMatches[0],
            simplePath = pageMatches[1];

        if (fullMatch) {
          var builtPath = path__default['default'].join(buildFolder, simplePath);
          var originalPath = manifest.getByValue(builtPath);

          if (originalPath) {
            outputStr = outputStr.replace(pathToGlobalRegex(fullMatch), originalPath.replace(projectRoot, ""));
          }
        }
      }
    }

    next(null, Buffer.from(outputStr));
  });
  return stream;
}

function getSpawnEnv(config) {
  var spawnEnv = process.env;
  spawnEnv.FORCE_COLOR = "3";

  if (config.inspect) {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_OPTIONS: "--inspect"
    });
  }

  return spawnEnv;
}

async function createCommandAndPort(config, command) {
  var spawnCommand = [command];
  var availablePort;
  availablePort = await detect__default['default']({
    port: config.port ? config.port : 3000
  });
  spawnCommand = spawnCommand.concat(["-p", "" + availablePort]);

  if (config.hostname) {
    spawnCommand = spawnCommand.concat(["-H", "" + config.hostname]);
  }

  var spawnEnv = getSpawnEnv(config);
  return {
    spawnCommand: spawnCommand,
    spawnEnv: spawnEnv,
    availablePort: availablePort
  };
}

async function nextStartDev(nextBin, cwd, manifest, buildFolder, config) {
  var _await$createCommandA = await createCommandAndPort(config, "dev"),
      spawnCommand = _await$createCommandA.spawnCommand,
      spawnEnv = _await$createCommandA.spawnEnv,
      availablePort = _await$createCommandA.availablePort;

  process.env.BLITZ_DEV_SERVER_ORIGIN = "http://localhost:" + availablePort;
  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      display.log.error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      var nextjs = spawn.spawn(nextBin, spawnCommand, {
        cwd: cwd,
        env: spawnEnv,
        stdio: [process.stdin, "pipe", "pipe"]
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", rej);
      nextjs.stdout.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stdout);
      nextjs.stderr.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stderr);
    }
  });
}
function nextBuild(nextBin, buildFolder, manifest, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    var nextjs = spawn.spawn(nextBin, ["build"], {
      cwd: buildFolder,
      env: spawnEnv,
      stdio: [process.stdin, "pipe", "pipe"]
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
    nextjs.stdout.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stdout);
    nextjs.stderr.pipe(createOutputTransformer(buildFolder, manifest)).pipe(process.stderr);
  });
}
function nextExport(nextBin, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    var nextjs = spawn.spawn(nextBin, ["export"], {
      env: spawnEnv,
      stdio: [process.stdin, "pipe", "pipe"]
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
    nextjs.stdout.pipe(process.stdout);
    nextjs.stderr.pipe(process.stderr);
  });
}
async function nextStart(nextBin, buildFolder, config) {
  var _await$createCommandA2 = await createCommandAndPort(config, "start"),
      spawnCommand = _await$createCommandA2.spawnCommand,
      spawnEnv = _await$createCommandA2.spawnEnv,
      availablePort = _await$createCommandA2.availablePort;

  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      display.log.error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      var nextjs = spawn.spawn(nextBin, spawnCommand, {
        cwd: buildFolder,
        env: spawnEnv,
        stdio: [process.stdin, "pipe", "pipe"]
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
      nextjs.stdout.pipe(createOutputTransformer(buildFolder)).pipe(process.stdout);
      nextjs.stderr.pipe(createOutputTransformer(buildFolder)).pipe(process.stderr);
    }
  });
}
function getCustomServerPath() {
  var projectRoot = config.getProjectRoot();
  var serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server.ts"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server.js"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server/index.ts"));
  if (fs.existsSync(serverPath)) return serverPath;
  serverPath = path__default['default'].resolve(path__default['default'].join(projectRoot, "server/index.js"));
  if (fs.existsSync(serverPath)) return serverPath;
  throw new Error("Unable to find custom server");
}
function getCustomServerBuildPath() {
  var projectRoot = config.getProjectRoot();
  return path__default['default'].resolve(projectRoot, ".blitz", "custom-server.js");
}
function customServerExists() {
  try {
    getCustomServerPath();
    return true;
  } catch (_unused) {
    return false;
  }
}

var getEsbuildOptions = function getEsbuildOptions() {
  var _pkg$dependencies, _pkg$devDependencies;

  var pkg = fs.readJSONSync(path__default['default'].join(pkgDir__default['default'].sync(), "package.json"));
  return {
    entryPoints: [getCustomServerPath()],
    outfile: getCustomServerBuildPath(),
    format: "cjs",
    bundle: true,
    platform: "node",
    external: ["blitz", "next"].concat(Object.keys(require("blitz/package").dependencies), Object.keys((_pkg$dependencies = pkg == null ? void 0 : pkg.dependencies) != null ? _pkg$dependencies : {}), Object.keys((_pkg$devDependencies = pkg == null ? void 0 : pkg.devDependencies) != null ? _pkg$devDependencies : {}))
  };
};

function buildCustomServer(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      watch = _ref.watch;

  var esbuildOptions = getEsbuildOptions();

  if (watch) {
    esbuildOptions.watch = {
      onRebuild: function onRebuild(error) {
        if (error) {
          display.log.error("Failed to re-build custom server");
        } else {
          display.log.newline();
          display.log.progress("Custom server changed - rebuilding...");
        }
      }
    };
  }

  return esbuild.build(esbuildOptions);
}
function startCustomServer(cwd, config, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      watch = _ref2.watch;

  var serverBuildPath = getCustomServerBuildPath();
  var spawnEnv = getSpawnEnv(config);

  if (config.env === "prod") {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_ENV: "production"
    });
  }

  return new Promise(function (res, rej) {
    var process;
    var RESTART_CODE = 777777;

    var spawnServer = function spawnServer() {
      process = spawn.spawn("node", [serverBuildPath], {
        cwd: cwd,
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else if (watch && code === RESTART_CODE) {
          spawnServer();
        } else {
          rej("server.js failed with status code: " + code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
    };

    if (watch) {
      // Handle build & Starting server
      var esbuildOptions = getEsbuildOptions();
      esbuildOptions.watch = {
        onRebuild: function onRebuild(error) {
          if (error) {
            display.log.error("Failed to re-build custom server");
          } else {
            display.log.newline();
            display.log.progress("Custom server changed - restarting...");
            display.log.newline(); //@ts-ignore -- incorrect TS type from node

            process.exitCode = RESTART_CODE;
            process.kill("SIGABRT");
          }
        }
      }; // eslint-disable-next-line @typescript-eslint/no-floating-promises

      esbuild.build(esbuildOptions).then(function () {
        spawnServer();
      });
    } else {
      // No build required, Start server
      spawnServer();
    }
  });
}

var debug = /*#__PURE__*/require("debug")("blitz:manifest");

var Manifest = /*#__PURE__*/function () {
  function Manifest(obj) {
    this.keys = {};
    this.values = {};
    this.events = [];

    if (obj) {
      this.keys = obj.keys;
      this.values = obj.values;
    }
  }

  var _proto = Manifest.prototype;

  _proto.getByKey = function getByKey(key) {
    return this.keys[key];
  };

  _proto.getByValue = function getByValue(value) {
    return this.values[value];
  };

  _proto.setEntry = function setEntry(key, dest) {
    debug("Setting key: " + key);
    this.keys[key] = dest;
    this.values[dest] = key;
    this.events.push("set:" + dest);
  };

  _proto.removeKey = function removeKey(key) {
    debug("Removing key: " + key);
    var dest = this.getByKey(key);

    if (!dest) {
      throw new Error("Key \"" + key + "\" returns");
    }

    delete this.values[dest];
    delete this.keys[key];
    this.events.push("del:" + key);
    return dest;
  };

  _proto.getEvents = function getEvents() {
    return this.events;
  };

  _proto.toJson = function toJson(compact) {
    if (compact === void 0) {
      compact = false;
    }

    return JSON.stringify(this.toObject(), null, compact ? undefined : 2);
  };

  _proto.toObject = function toObject() {
    return {
      keys: this.keys,
      values: this.values
    };
  };

  Manifest.create = function create(obj) {
    return new Manifest(obj);
  };

  return Manifest;
}();
/**
 * Returns a stage to create and write the file error manifest so we can
 * link to the correct files on a NextJS browser error.
 */

var createStageManifest = async function createStageManifest(writeManifestFile, buildFolder, env, manifestPath) {
  if (writeManifestFile === void 0) {
    writeManifestFile = true;
  }

  if (manifestPath === void 0) {
    manifestPath = "_manifest.json";
  }

  var manifest;

  if (env !== "prod" && (await fs.pathExists(path__default['default'].join(buildFolder, manifestPath)))) {
    manifest = await ManifestLoader.load(path__default['default'].join(buildFolder, manifestPath));
  } else {
    manifest = Manifest.create();
  }

  var stage = function stage() {
    var debouncePushItem = debounce__default['default'](function (push, file) {
      push(file);
    }, 500);
    var stream = filePipeline.transform.file(function (file, _ref) {
      var next = _ref.next,
          push = _ref.push;
      push(file); // Send file on through to be written

      var _file$history = file.history,
          origin = _file$history[0];
      var dest = file.path;

      if (file.event === "add" || file.event === "change") {
        debug("event:", file.event);
        manifest.setEntry(origin, dest);
      }

      if (file.event === "unlink" || file.event === "unlinkDir") {
        debug("event:", file.event);
        manifest.removeKey(origin);
      }

      if (writeManifestFile) {
        debouncePushItem(push, new File__default['default']({
          // NOTE:  no need to for hash because this is a manifest
          //        and doesn't count as work
          path: manifestPath,
          contents: Buffer.from(manifest.toJson(false))
        }));
      }

      next();
    });
    return {
      stream: stream,
      ready: {
        manifest: manifest
      }
    };
  };

  return stage;
};
var ManifestLoader = {
  load: function load(filename) {
    return new Promise(function (resolve, reject) {
      fs$1.readFile(filename, "utf8", function (err, data) {
        if (err) {
          return reject(err);
        }

        resolve(Manifest.create(JSON.parse(data)));
      });
    });
  }
};

var isJavaScriptFile$1 = function isJavaScriptFile(filepath) {
  return filepath.match(/\.(ts|tsx|js|jsx)$/);
};

var isInSpecialFolderInAppFolder = function isInSpecialFolderInAppFolder(s, cwd) {
  var filepath = s.replace(cwd + path__default['default'].sep, "");
  return /^app[/\\].*(pages|api|queries|mutations)[/\\]/.test(filepath);
};
/**
 * Returns a Stage that converts relative files paths to absolute
 */


var createStageRelative = function createStageRelative(_ref) {
  var cwd = _ref.config.cwd;
  var stream = filePipeline.transform.file(function (file) {
    // const cwd = process.cwd()
    var filecontents = file.contents;
    var filepath = file.path;

    if (!isJavaScriptFile$1(filepath) || !isInSpecialFolderInAppFolder(filepath, cwd) || filecontents === null) {
      return file;
    }

    var contents = filecontents.toString();
    var newContents = replaceRelativeImports(contents, relativeToAbsolute(cwd, filepath));
    file.contents = Buffer.from(newContents);
    return file;
  });
  return {
    stream: stream
  };
};
var patternRelativeImportSingle = /(import(?:\s|\()(?:{[^}]*})?.*(?=(?:['"])(?:\.[^'"]+)(?:['"]))(?:['"]))(\.[^'"]+)(['"])/;
var patternRelativeImportGlobal = /*#__PURE__*/new RegExp(patternRelativeImportSingle, "g");
function replaceRelativeImports(content, replacer) {
  return content.replace(patternRelativeImportGlobal, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var start = args[1],
        importPath = args[2],
        end = args[3];
    return [start, replacer(importPath), end].join("");
  });
}

function isAbsolute(path) {
  if (path.indexOf("./") === 0) {
    return false;
  }

  if (path.indexOf("../") === 0) {
    return false;
  }

  return true;
}

function relativeToAbsolute(_cwd, _filename) {
  return function (filePath) {
    if (isAbsolute(filePath)) return filePath;
    return slash__default['default'](path__default['default'].join(path__default['default'].dirname(_filename), filePath).replace(_cwd + path__default['default'].sep, ""));
  };
}

var isJavaScriptFile = function isJavaScriptFile(filepath) {
  return filepath.match(/\.(ts|tsx|js|jsx)$/);
};

var isInAppFolder = function isInAppFolder(s, cwd) {
  return s.replace(cwd + path__default['default'].sep, "").indexOf("app") === 0;
};
/**
 * Returns a Stage that converts relative files paths to absolute
 */


var createStageRewriteImports = function createStageRewriteImports(_ref) {
  var cwd = _ref.config.cwd;
  var stream = filePipeline.transform.file(function (file) {
    var filecontents = file.contents;
    var filepath = file.path;

    if (!isJavaScriptFile(filepath) || !isInAppFolder(filepath, cwd) || filecontents === null) {
      return file;
    }

    var contents = filecontents.toString();
    var newContents = replaceImports(contents, cwd);
    file.contents = Buffer.from(newContents);
    return file;
  });
  return {
    stream: stream
  };
};
var patternImport = /(import[\s\S]*?["'])([\s\S]+?)(["'])/g;
function replaceImports(content, cwd) {
  return content.replace(patternImport, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _ref2 = args,
        original = _ref2[0],
        start = _ref2[1],
        resource = _ref2[2],
        end = _ref2[3];

    if (resource.startsWith("@")) {
      return original;
    }

    return start + rewriteImportOrigin(resource, cwd) + end;
  });
}
/**
 * Check wether `someDir/api` links to `someDir/api.js` or `someDir/api/index.js`.
 */

function getImportType(absoluteOrigin, cwd) {
  var foundFiles = fastGlob__default['default'].sync( // if absoluteOrigin is a file import,
  // we'll find a matching file.
  //
  [absoluteOrigin + ".[jt]s", absoluteOrigin + ".[jt]sx"], {
    cwd: cwd
  });
  return foundFiles.length > 0 ? "file" : "directory";
}

function rewriteImportOrigin(origin, cwd) {
  var parts = origin.split("/");

  if (parts.indexOf("pages") === parts.length - 1 || parts.indexOf("api") === parts.length - 1) {
    if (getImportType(origin, cwd) === "file") {
      return origin;
    }
  }

  return parts.join("/");
}

function makeDebouncedWriter(path, ms) {
  if (ms === void 0) {
    ms = 100;
  }

  return lodash.debounce(function (contents) {
    fs.outputFileSync(path, contents, {
      encoding: "utf-8"
    });
  }, ms);
}

function parseDefaultExportName(contents) {
  var _result$;

  var result = contents.match(/export\s+default(?:\s+(?:const|let|class|var|function))?\s+(\w+)/);

  if (!result) {
    return null;
  }

  return (_result$ = result[1]) != null ? _result$ : null;
}

var isPage = function isPage(path$1) {
  return path$1.includes(path.join("pages", "/")) && !path$1.includes(path.join("pages", "api", "/")) && !path$1.includes(path.join("/", "_app.")) && !path$1.includes(path.join("/", "_document."));
};

function dedupeBy(arr, by) {
  var allKeys = arr.map(by);
  return arr.filter(function (v, index) {
    var key = by(v);
    var first = allKeys.indexOf(key);
    var last = allKeys.lastIndexOf(key);

    if (first !== last && first !== index) {
      var _ref = arr[first],
          firstPath = _ref[0];
      var _ref2 = arr[last],
          lastPath = _ref2[0];
      throw Error("The page component is named \"" + key + "\" on both the " + firstPath + " and " + lastPath + " routes. The page component must have a unique name across all routes, so change the component name on one of those routes to avoid conflict.");
    }

    return true;
  });
}

function generateManifest(routes) {
  var routesWithoutDuplicates = dedupeBy(Object.entries(routes), function (_ref3) {
    _ref3[0];
        var name = _ref3[1].name;
    return name;
  });
  var implementationLines = routesWithoutDuplicates.map(function (_ref4) {
    var path = _ref4[0],
        name = _ref4[1].name;
    return name + ": (query) => ({ pathname: \"" + path + "\", query })";
  });
  var declarationLines = routesWithoutDuplicates.map(function (_ref5) {
    _ref5[0];
        var _ref5$ = _ref5[1],
        name = _ref5$.name,
        parameters = _ref5$.parameters,
        multipleParameters = _ref5$.multipleParameters;

    if (parameters.length === 0 && multipleParameters.length === 0) {
      return name + "(query?: ParsedUrlQueryInput): RouteUrlObject";
    }

    return name + "(query: { " + [].concat(parameters.map(function (param) {
      return param.name + (param.optional ? "?" : "") + ": string | number";
    }), multipleParameters.map(function (param) {
      return param.name + (param.optional ? "?" : "") + ": (string | number)[]";
    })).join("; ") + " } & ParsedUrlQueryInput): RouteUrlObject";
  });
  return {
    implementation: "exports.Routes = {\n" + implementationLines.map(function (line) {
      return "  " + line;
    }).join(",\n") + "\n}",
    declaration: ("\nimport type { ParsedUrlQueryInput } from \"querystring\"\nimport type { RouteUrlObject } from \"blitz\"\n\nexport const Routes: {\n" + declarationLines.map(function (line) {
      return "  " + line;
    }).join(";\n") + ";\n}").trim()
  };
}

function removeSquareBracketsFromSegments(value) {
  if (typeof value === "string") {
    return value.replace("[", "").replace("]", "");
  }

  return value.map(function (val) {
    return val.replace("[", "").replace("]", "");
  });
}

var squareBracketsRegex = /\[\[.*?\]\]|\[.*?\]/g;
function parseParametersFromRoute(path) {
  var _path$match;

  var parameteredSegments = (_path$match = path.match(squareBracketsRegex)) != null ? _path$match : [];
  var withoutBrackets = removeSquareBracketsFromSegments(parameteredSegments);

  var _partition = lodash.partition(withoutBrackets, function (p) {
    return p.includes("...");
  }),
      multipleParameters = _partition[0],
      parameters = _partition[1];

  return {
    parameters: parameters.map(function (value) {
      var containsSquareBrackets = squareBracketsRegex.test(value);

      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(value),
          optional: true
        };
      }

      return {
        name: value,
        optional: false
      };
    }),
    multipleParameters: multipleParameters.map(function (param) {
      var withoutEllipsis = param.replace("...", "");
      var containsSquareBrackets = squareBracketsRegex.test(withoutEllipsis);

      if (containsSquareBrackets) {
        return {
          name: removeSquareBracketsFromSegments(withoutEllipsis),
          optional: true
        };
      }

      return {
        name: withoutEllipsis,
        optional: false
      };
    })
  };
}
/**
 * Will resolve the real node_modules root.
 * We're not fooled by you, `yarn workspace`!
 */

function findNodeModulesRoot(src) {
  var nodeModules = path.join(src, "node_modules");
  var includesBlitzPackage = fs.existsSync(path.join(nodeModules, "blitz"));
  var count = 0;

  while (!includesBlitzPackage) {
    // Check for node_modules at the next level up
    nodeModules = path.join(nodeModules, "../../node_modules");
    includesBlitzPackage = fs.existsSync(path.join(nodeModules, "blitz"));
    count++;

    if (count > 5) {
      display.log.warning("We couldn't determine your actual node_modules location, so defaulting to normal location");
      nodeModules = path.join(src, "node_modules");
      break;
    }
  }

  return nodeModules;
}

var createStageRouteImportManifest = function createStageRouteImportManifest(_ref6) {
  var getRouteCache = _ref6.getRouteCache,
      config = _ref6.config;
  var routeCache = getRouteCache();
  var routes = {};
  var dotBlitz = path.join(findNodeModulesRoot(config.src), ".blitz");
  var writeManifestImplementation = makeDebouncedWriter(path.join(dotBlitz, "index.js"));
  var writeManifestBrowserImplementation = makeDebouncedWriter(path.join(dotBlitz, "index-browser.js"));
  var writeManifestDeclaration = makeDebouncedWriter(path.join(dotBlitz, "index.d.ts"));
  var stream = filePipeline.transform.file(function (file) {
    var _file$contents$toStri, _file$contents;

    if (!isPage(file.relative)) {
      return file;
    }

    var defaultExportName = parseDefaultExportName((_file$contents$toStri = (_file$contents = file.contents) == null ? void 0 : _file$contents.toString()) != null ? _file$contents$toStri : "");

    if (!defaultExportName) {
      return file;
    }

    var entry = routeCache.get(file);

    if (!entry) {
      return file;
    }

    function addRoute(path, defaultExportName) {
      routes[path] = _extends({}, parseParametersFromRoute(path), {
        name: defaultExportName
      });

      var _generateManifest = generateManifest(routes),
          declaration = _generateManifest.declaration,
          implementation = _generateManifest.implementation;

      writeManifestImplementation(implementation);
      writeManifestBrowserImplementation(implementation);
      writeManifestDeclaration(declaration);
    }

    addRoute(entry.uri, defaultExportName);
    return file;
  });
  return {
    stream: stream
  };
};

createStageRouteImportManifest.overrideTriage = function (file) {
  if (isPage(file.relative)) {
    return "proceed";
  }

  return undefined;
};

/**
 * Returns a Stage to populate route cache based on the regex path
 */

var createStageRoutes = function createStageRoutes(_ref) {
  var getRouteCache = _ref.getRouteCache;
  var routeCache = getRouteCache();
  var stream = filePipeline.transform.file(function (file) {
    routeCache.add(file);
    return file;
  });
  return {
    stream: stream,
    ready: {
      routeCache: getRouteCache()
    }
  };
};

// These create pipeline stages that are run as the business rules for Blitz
// Read this folders README for more information
var configureStages = async function configureStages(config) {
  return {
    overrideTriage: createStageRouteImportManifest.overrideTriage,
    stages: [// Order is important
    createStageRelative, createStageRewriteImports, createStageRpc(config.isTypeScript), createStageRoutes, createStageRouteImportManifest, await createStageManifest(config.writeManifestFile, config.buildFolder, config.env)]
  };
};
var configureRouteStages = function configureRouteStages(config) {
  return [createStageRpc(config.isTypeScript), createStageRoutes];
};
var configureGenerateStages = function configureGenerateStages() {
  return [createStageRoutes, createStageRouteImportManifest];
};

async function build(config) {
  var _await$normalize = await normalize(config),
      rootFolder = _await$normalize.rootFolder,
      transformFiles = _await$normalize.transformFiles,
      buildFolder = _await$normalize.buildFolder,
      nextBin = _await$normalize.nextBin,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      watch = _await$normalize.watch,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      env = _await$normalize.env;

  var _await$configureStage = await configureStages({
    isTypeScript: isTypeScript,
    writeManifestFile: writeManifestFile,
    buildFolder: buildFolder,
    env: env
  }),
      stages = _await$configureStage.stages,
      overrideTriage = _await$configureStage.overrideTriage;

  var _await$transformFiles = await transformFiles(rootFolder, stages, buildFolder, {
    ignore: ignore,
    include: include,
    watch: watch,
    clean: true,
    // always clean in build
    overrideTriage: overrideTriage
  }),
      manifest = _await$transformFiles.manifest;

  await saveBlitzVersion(buildFolder);
  if (customServerExists()) await buildCustomServer({
    watch: watch
  });
  await nextBuild(nextBin, buildFolder, manifest, config);
  var rootNextFolder = path.resolve(rootFolder, ".next");
  var buildNextFolder = path.resolve(buildFolder, ".next");
  await filePipeline.rimraf(rootNextFolder);
  await fs.copy(buildNextFolder, rootNextFolder);
}

async function blitzExport(config) {
  var _await$normalize = await normalize(config),
      nextBin = _await$normalize.nextBin;

  await nextExport(nextBin, config);
}

async function dev(config$1) {
  var _await$normalize = await normalize(_extends({}, config$1, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      transformFiles = _await$normalize.transformFiles,
      nextBin = _await$normalize.nextBin,
      buildFolder = _await$normalize.buildFolder,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      watch = _await$normalize.watch,
      clean = _await$normalize.clean,
      env = _await$normalize.env; // if blitz version is mismatched, we need to bust the cache by cleaning the buildFolder


  var versionMatched = await isVersionMatched(buildFolder);

  var _await$configureStage = await configureStages({
    writeManifestFile: writeManifestFile,
    isTypeScript: isTypeScript,
    buildFolder: buildFolder,
    env: env
  }),
      stages = _await$configureStage.stages,
      overrideTriage = _await$configureStage.overrideTriage;

  var _await$transformFiles = await transformFiles(rootFolder, stages, buildFolder, {
    ignore: ignore,
    include: include,
    watch: watch,
    clean: !versionMatched || clean,
    overrideTriage: overrideTriage
  }),
      manifest = _await$transformFiles.manifest;

  if (!versionMatched) await saveBlitzVersion(buildFolder);

  if (customServerExists()) {
    var _blitzConfig$customSe, _blitzConfig$customSe2;

    display.log.success("Using your custom server");
    var blitzConfig = config.getConfig();

    var _watch = (_blitzConfig$customSe = (_blitzConfig$customSe2 = blitzConfig.customServer) == null ? void 0 : _blitzConfig$customSe2.hotReload) != null ? _blitzConfig$customSe : true;

    await startCustomServer(buildFolder, config$1, {
      watch: _watch
    });
  } else {
    await nextStartDev(nextBin, buildFolder, manifest, buildFolder, config$1);
  }
}

async function prod(config) {
  var _await$normalize = await normalize(config),
      buildFolder = _await$normalize.buildFolder,
      nextBin = _await$normalize.nextBin;

  if (!fs$1.existsSync(buildFolder)) {
    display.log.error("Could not find a production build, you must run `blitz build` before starting");
    process.exit(1);
  }

  if (customServerExists()) {
    display.log.success("Using your custom server");
    await startCustomServer(buildFolder, config);
  } else {
    await nextStart(nextBin, buildFolder, config);
  }
}

function defaultSitemapFunction(_) {
  return [];
}

async function routes(config$1) {
  var _await$normalize = await normalize(_extends({}, config$1, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      routesFolder = _await$normalize.routesFolder,
      transformFiles = _await$normalize.transformFiles,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include,
      isTypeScript = _await$normalize.isTypeScript,
      writeManifestFile = _await$normalize.writeManifestFile,
      env = _await$normalize.env;

  var _ref = config.getConfig(),
      _ref$sitemap = _ref.sitemap,
      sitemap = _ref$sitemap === void 0 ? defaultSitemapFunction : _ref$sitemap;

  var stages = configureRouteStages({
    writeManifestFile: writeManifestFile,
    isTypeScript: isTypeScript,
    buildFolder: routesFolder,
    env: env
  });

  var _ref2 = await transformFiles(rootFolder, stages, routesFolder, {
    ignore: ignore,
    include: include,
    watch: false,
    clean: true
  }),
      routeCache = _ref2.routeCache;

  sitemap(routeCache).forEach(function (sitemap_) {
    routeCache.set(sitemap_.uri, sitemap_);
  });
  return Object.values(routeCache.get());
}

async function generate(config) {
  var _await$normalize = await normalize(_extends({}, config, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      routesFolder = _await$normalize.routesFolder,
      transformFiles = _await$normalize.transformFiles,
      ignore = _await$normalize.ignore,
      include = _await$normalize.include;

  var stages = configureGenerateStages();
  await transformFiles(rootFolder, stages, routesFolder, {
    ignore: ignore,
    include: include,
    watch: false,
    clean: true
  });
}

exports.ManifestLoader = ManifestLoader;
exports.blitzExport = blitzExport;
exports.build = build;
exports.dev = dev;
exports.generate = generate;
exports.normalize = normalize;
exports.prod = prod;
exports.resolveBinAsync = resolveBinAsync;
exports.routes = routes;
